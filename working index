<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIF/USDT ML Price Predictor - Production</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.1.1/dist/chartjs-chart-financial.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/9.0.1/simple-statistics.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 10px;
        }

        .header {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .status-bar {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .status-item {
            background: #222;
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .status-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .status-indicator.connected {
            background: #4caf50;
        }

        .status-indicator.disconnected {
            background: #f44336;
        }

        .status-indicator.training {
            background: #ff9800;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 15px;
            margin-bottom: 15px;
        }

        .chart-container {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            position: relative;
        }

        .controls-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 6px 0;
            padding: 6px;
            background: #222;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .toggle-switch:hover {
            background: #2a2a2a;
        }

        .toggle-switch input {
            width: 36px;
            height: 18px;
            appearance: none;
            background: #444;
            border-radius: 9px;
            position: relative;
            cursor: pointer;
            transition: 0.2s;
        }

        .toggle-switch input:checked {
            background: #4caf50;
        }

        .toggle-switch input::before {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: 0.2s;
        }

        .toggle-switch input:checked::before {
            left: 20px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .metric-card {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
        }

        .metric-card h3 {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 20px;
            font-weight: bold;
            margin: 5px 0;
        }

        .metric-change {
            font-size: 12px;
            color: #888;
        }

        .metric-change.positive {
            color: #4caf50;
        }

        .metric-change.negative {
            color: #f44336;
        }

        .data-table {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            overflow-x: auto;
        }

        .data-table h2 {
            font-size: 16px;
            margin-bottom: 12px;
        }

        .data-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid #333;
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            font-weight: normal;
        }

        .data-table td {
            padding: 8px;
            border-bottom: 1px solid #222;
            font-size: 13px;
        }

        .signal-buy {
            color: #4caf50;
        }

        .signal-sell {
            color: #f44336;
        }

        .signal-hold {
            color: #888;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 2px solid #333;
            border-top-color: #4caf50;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .btn {
            padding: 8px 16px;
            background: #4caf50;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: 0.2s;
            width: 100%;
            margin-top: 5px;
        }

        .btn:hover {
            background: #45a049;
        }

        .btn:disabled {
            background: #444;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: #555;
        }

        .btn.secondary:hover {
            background: #666;
        }

        canvas {
            max-width: 100%;
            height: 100% !important;
        }

        .training-progress {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #45a049);
            transition: width 0.3s;
        }

        .log-window {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            margin-top: 10px;
        }

        .log-entry {
            margin: 2px 0;
            color: #888;
        }

        .log-entry.error {
            color: #f44336;
        }

        .log-entry.success {
            color: #4caf50;
        }

        .log-entry.warning {
            color: #ff9800;
        }

        .indicator-value {
            display: inline-block;
            padding: 2px 6px;
            background: #333;
            border-radius: 3px;
            font-size: 11px;
            margin-left: 5px;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #222;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .model-card {
            background: #222;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .model-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .model-name {
            font-size: 13px;
            font-weight: 500;
        }

        .model-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            background: #333;
        }

        .model-status.trained {
            background: #1b5e20;
            color: #4caf50;
        }

        .model-status.training {
            background: #e65100;
            color: #ff9800;
        }

        .model-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            font-size: 11px;
        }

        .model-metric {
            display: flex;
            justify-content: space-between;
            color: #888;
        }

        .model-metric span:last-child {
            color: #e0e0e0;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <h2>Initializing WIF/USDT Predictor</h2>
            <p id="loadingStatus">Loading historical data...</p>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>WIF/USDT ML Price Predictor</h1>
            <div class="status-bar">
                <div class="status-item">
                    <span class="status-indicator connected" id="wsIndicator"></span>
                    <span>WebSocket: <span id="wsStatus">Connecting</span></span>
                </div>
                <div class="status-item">
                    <span>Price: $<span id="currentPrice">-</span></span>
                </div>
                <div class="status-item">
                    <span>24h Change: <span id="change24h">-</span>%</span>
                </div>
                <div class="status-item">
                    <span>Volume: <span id="volume24h">-</span></span>
                </div>
                <div class="status-item">
                    <span class="status-indicator" id="modelsIndicator"></span>
                    <span>Models: <span id="modelsStatus">Initializing</span></span>
                </div>
                <div class="status-item">
                    <span>Data Points: <span id="dataPoints">0</span></span>
                </div>
            </div>
        </div>

        <div class="training-progress" id="trainingProgress">
            <h3>Model Training Progress</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <p style="font-size: 12px; color: #888; margin-top: 5px;">
                <span id="trainingStatus">Preparing training data...</span>
                <span style="float: right;" id="trainingEpoch"></span>
            </p>
            <div class="log-window" id="logWindow"></div>
        </div>

        <div class="main-grid">
            <div class="chart-container">
                <canvas id="mainChart"></canvas>
            </div>
            
            <div class="controls-panel">
                <div class="control-section">
                    <h3>Indicators</h3>
                    <div class="toggle-switch">
                        <label>EMA <span class="indicator-value" id="emaStatus">9,21</span></label>
                        <input type="checkbox" id="toggleEMA" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>SMA <span class="indicator-value" id="smaStatus">20,50</span></label>
                        <input type="checkbox" id="toggleSMA">
                    </div>
                    <div class="toggle-switch">
                        <label>RSI <span class="indicator-value" id="rsiValue">-</span></label>
                        <input type="checkbox" id="toggleRSI" checked>
                    </div>
                    <div class="toggle-switch">
                        <label>MACD</label>
                        <input type="checkbox" id="toggleMACD">
                    </div>
                    <div class="toggle-switch">
                        <label>Bollinger</label>
                        <input type="checkbox" id="toggleBB">
                    </div>
                    <div class="toggle-switch">
                        <label>VWAP</label>
                        <input type="checkbox" id="toggleVWAP" checked>
                    </div>
                </div>

                <div class="control-section">
                    <h3>ML Models</h3>
                    <div id="modelControls">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>

                <div class="control-section">
                    <h3>Actions</h3>
                    <button class="btn" id="btnTrain" onclick="trainModels()">Train All Models</button>
                    <button class="btn secondary" id="btnBacktest" onclick="runBacktest()">Run Backtest</button>
                    <button class="btn secondary" onclick="clearSignals()">Clear Signals</button>
                    <button class="btn secondary" onclick="exportResults()">Export Results</button>
                </div>
            </div>
        </div>

        <div class="metrics-grid">
            <div class="metric-card">
                <h3>Best Model</h3>
                <div class="metric-value" id="bestModel">-</div>
                <div class="metric-change" id="bestModelAccuracy">Training required</div>
            </div>
            <div class="metric-card">
                <h3>Direction Accuracy</h3>
                <div class="metric-value" id="directionAccuracy">-%</div>
                <div class="metric-change" id="directionChange">No predictions yet</div>
            </div>
            <div class="metric-card">
                <h3>Avg Error (RMSE)</h3>
                <div class="metric-value" id="avgError">-</div>
                <div class="metric-change" id="errorTrend">Awaiting data</div>
            </div>
            <div class="metric-card">
                <h3>Signal Confidence</h3>
                <div class="metric-value" id="signalConfidence">-%</div>
                <div class="metric-change" id="confidenceTrend">No active signals</div>
            </div>
            <div class="metric-card">
                <h3>Backtest P&L</h3>
                <div class="metric-value" id="backtestPnL">$0</div>
                <div class="metric-change" id="backtestReturn">0%</div>
            </div>
            <div class="metric-card">
                <h3>Market Regime</h3>
                <div class="metric-value" id="marketRegime">-</div>
                <div class="metric-change" id="regimeConfidence">Analyzing...</div>
            </div>
        </div>

        <div class="data-table">
            <h2>Recent Predictions & Signals</h2>
            <table>
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Price</th>
                        <th>Model</th>
                        <th>Prediction</th>
                        <th>Error</th>
                        <th>Signal</th>
                        <th>Confidence</th>
                        <th>Features</th>
                        <th>Result</th>
                    </tr>
                </thead>
                <tbody id="predictionsTable">
                    <tr>
                        <td colspan="9" style="text-align: center; color: #888;">No predictions yet - models need training</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="data-table">
            <h2>Model Performance Comparison</h2>
            <div id="modelPerformance">
                <p style="text-align: center; color: #888; padding: 20px;">Models will be evaluated after training completes</p>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // REAL IMPLEMENTATION - NO FAKE DATA
        // ============================================
        
        class RealWIFPredictor {
            constructor() {
                this.data = {
                    candles: [],
                    orderbook: { bids: [], asks: [] },
                    trades: [],
                    features: [],
                    predictions: [],
                    signals: []
                };
                
                this.models = {};
                this.indicators = {};
                this.ws = null;
                this.chart = null;
                this.isTraining = false;
                this.modelStats = {};
                
                this.config = {
                    symbol: 'WIFUSDT',
                    interval: '1m',
                    lookback: 100,
                    predictionWindow: 5,
                    minDataPoints: 200,
                    trainTestSplit: 0.8
                };
                
                this.log = [];
            }

            async initialize() {
                try {
                    this.addLog('Initializing WIF/USDT predictor...', 'info');
                    
                    // Load historical data first
                    await this.loadHistoricalData();
                    
                    // Initialize chart
                    this.initializeChart();
                    
                    // Connect to WebSocket
                    await this.connectWebSocket();
                    
                    // Initialize models structure
                    this.initializeModels();
                    
                    // Update UI
                    this.updateUI();
                    
                    // Hide loading overlay
                    document.getElementById('loadingOverlay').style.display = 'none';
                    document.getElementById('trainingProgress').style.display = 'block';
                    
                    this.addLog('System initialized. Click "Train All Models" to begin.', 'success');
                    
                } catch (error) {
                    this.addLog(`Initialization error: ${error.message}`, 'error');
                    console.error('Init error:', error);
                }
            }

            addLog(message, type = 'info') {
                const logWindow = document.getElementById('logWindow');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;
                logWindow.appendChild(entry);
                logWindow.scrollTop = logWindow.scrollHeight;
                
                this.log.push({ timestamp, message, type });
                console.log(`[${type.toUpperCase()}] ${message}`);
            }

            async loadHistoricalData() {
                try {
                    document.getElementById('loadingStatus').textContent = 'Fetching historical data from Binance...';
                    
                    // Fetch multiple timeframes for better training data
                    const limits = [500, 1000, 1500];
                    const allData = [];
                    
                    for (const limit of limits) {
                        const response = await fetch(
                            `https://api.binance.com/api/v3/klines?symbol=${this.config.symbol}&interval=${this.config.interval}&limit=${limit}`
                        );
                        
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const data = await response.json();
                        
                        const candles = data.map(d => ({
                            time: d[0],
                            open: parseFloat(d[1]),
                            high: parseFloat(d[2]),
                            low: parseFloat(d[3]),
                            close: parseFloat(d[4]),
                            volume: parseFloat(d[5]),
                            trades: parseInt(d[8])
                        }));
                        
                        allData.push(...candles);
                    }
                    
                    // Deduplicate by time
                    const uniqueCandles = Array.from(
                        new Map(allData.map(c => [c.time, c])).values()
                    ).sort((a, b) => a.time - b.time);
                    
                    this.data.candles = uniqueCandles.slice(-1500); // Keep last 1500 candles
                    
                    document.getElementById('dataPoints').textContent = this.data.candles.length;
                    this.addLog(`Loaded ${this.data.candles.length} historical candles`, 'success');
                    
                    // Calculate initial indicators
                    this.calculateIndicators();
                    
                    // Fetch current 24h stats
                    await this.fetch24hStats();
                    
                } catch (error) {
                    this.addLog(`Data loading error: ${error.message}`, 'error');
                    throw error;
                }
            }

            async fetch24hStats() {
                try {
                    const response = await fetch(
                        `https://api.binance.com/api/v3/ticker/24hr?symbol=${this.config.symbol}`
                    );
                    const data = await response.json();
                    
                    document.getElementById('currentPrice').textContent = parseFloat(data.lastPrice).toFixed(6);
                    document.getElementById('change24h').textContent = parseFloat(data.priceChangePercent).toFixed(2);
                    document.getElementById('volume24h').textContent = `${(parseFloat(data.volume) / 1000000).toFixed(2)}M`;
                    
                    // Color code the change
                    const changeEl = document.getElementById('change24h');
                    changeEl.style.color = parseFloat(data.priceChangePercent) >= 0 ? '#4caf50' : '#f44336';
                    
                } catch (error) {
                    console.error('Error fetching 24h stats:', error);
                }
            }

            calculateIndicators() {
                if (this.data.candles.length < 50) return;
                
                const closes = this.data.candles.map(c => c.close);
                const highs = this.data.candles.map(c => c.high);
                const lows = this.data.candles.map(c => c.low);
                const volumes = this.data.candles.map(c => c.volume);
                
                // EMA
                this.indicators.ema9 = this.calculateEMA(closes, 9);
                this.indicators.ema21 = this.calculateEMA(closes, 21);
                
                // SMA
                this.indicators.sma20 = this.calculateSMA(closes, 20);
                this.indicators.sma50 = this.calculateSMA(closes, 50);
                
                // RSI
                this.indicators.rsi = this.calculateRSI(closes, 14);
                
                // MACD
                this.indicators.macd = this.calculateMACD(closes);
                
                // Bollinger Bands
                this.indicators.bb = this.calculateBollingerBands(closes, 20, 2);
                
                // VWAP
                this.indicators.vwap = this.calculateVWAP(closes, volumes);
                
                // ATR
                this.indicators.atr = this.calculateATR(highs, lows, closes, 14);
                
                // Update RSI display
                const latestRSI = this.indicators.rsi[this.indicators.rsi.length - 1];
                if (latestRSI) {
                    document.getElementById('rsiValue').textContent = latestRSI.toFixed(1);
                }
            }

            calculateSMA(data, period) {
                const sma = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        sma.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                        sma.push(sum / period);
                    }
                }
                return sma;
            }

            calculateEMA(data, period) {
                const ema = [];
                const multiplier = 2 / (period + 1);
                
                // Start with SMA
                let sum = 0;
                for (let i = 0; i < period; i++) {
                    sum += data[i];
                }
                ema[period - 1] = sum / period;
                
                // Calculate EMA for rest
                for (let i = period; i < data.length; i++) {
                    ema[i] = (data[i] - ema[i - 1]) * multiplier + ema[i - 1];
                }
                
                // Fill initial nulls
                for (let i = 0; i < period - 1; i++) {
                    ema[i] = null;
                }
                
                return ema;
            }

            calculateRSI(data, period = 14) {
                const rsi = [];
                const gains = [];
                const losses = [];
                
                // Calculate price changes
                for (let i = 1; i < data.length; i++) {
                    const change = data[i] - data[i - 1];
                    gains.push(change > 0 ? change : 0);
                    losses.push(change < 0 ? -change : 0);
                }
                
                // Calculate initial averages
                let avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;
                let avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;
                
                // Calculate RSI
                for (let i = period; i < data.length; i++) {
                    avgGain = (avgGain * (period - 1) + gains[i - 1]) / period;
                    avgLoss = (avgLoss * (period - 1) + losses[i - 1]) / period;
                    
                    const rs = avgGain / (avgLoss || 0.00001);
                    rsi[i] = 100 - (100 / (1 + rs));
                }
                
                // Fill initial values
                for (let i = 0; i < period; i++) {
                    rsi[i] = null;
                }
                
                return rsi;
            }

            calculateMACD(data) {
                const ema12 = this.calculateEMA(data, 12);
                const ema26 = this.calculateEMA(data, 26);
                
                const macdLine = [];
                for (let i = 0; i < data.length; i++) {
                    if (ema12[i] !== null && ema26[i] !== null) {
                        macdLine[i] = ema12[i] - ema26[i];
                    } else {
                        macdLine[i] = null;
                    }
                }
                
                const signal = this.calculateEMA(macdLine.filter(v => v !== null), 9);
                const histogram = [];
                
                let signalIndex = 0;
                for (let i = 0; i < macdLine.length; i++) {
                    if (macdLine[i] !== null && signal[signalIndex] !== undefined) {
                        histogram[i] = macdLine[i] - signal[signalIndex];
                        signalIndex++;
                    } else {
                        histogram[i] = null;
                    }
                }
                
                return { macdLine, signal, histogram };
            }

            calculateBollingerBands(data, period = 20, stdDev = 2) {
                const sma = this.calculateSMA(data, period);
                const upper = [];
                const lower = [];
                
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        upper[i] = null;
                        lower[i] = null;
                    } else {
                        const slice = data.slice(i - period + 1, i + 1);
                        const mean = sma[i];
                        const squaredDiffs = slice.map(val => Math.pow(val - mean, 2));
                        const variance = squaredDiffs.reduce((a, b) => a + b) / period;
                        const std = Math.sqrt(variance);
                        
                        upper[i] = mean + (stdDev * std);
                        lower[i] = mean - (stdDev * std);
                    }
                }
                
                return { upper, middle: sma, lower };
            }

            calculateVWAP(prices, volumes) {
                const vwap = [];
                let cumulativePV = 0;
                let cumulativeVolume = 0;
                
                // Reset at each day (simplified - should reset at market open)
                for (let i = 0; i < prices.length; i++) {
                    cumulativePV += prices[i] * volumes[i];
                    cumulativeVolume += volumes[i];
                    vwap[i] = cumulativeVolume > 0 ? cumulativePV / cumulativeVolume : prices[i];
                }
                
                return vwap;
            }

            calculateATR(high, low, close, period = 14) {
                const tr = [];
                
                // Calculate True Range
                tr[0] = high[0] - low[0];
                for (let i = 1; i < high.length; i++) {
                    const hl = high[i] - low[i];
                    const hc = Math.abs(high[i] - close[i - 1]);
                    const lc = Math.abs(low[i] - close[i - 1]);
                    tr[i] = Math.max(hl, hc, lc);
                }
                
                // Calculate ATR
                const atr = [];
                let sum = 0;
                
                for (let i = 0; i < period; i++) {
                    sum += tr[i];
                }
                atr[period - 1] = sum / period;
                
                for (let i = period; i < tr.length; i++) {
                    atr[i] = (atr[i - 1] * (period - 1) + tr[i]) / period;
                }
                
                // Fill initial values
                for (let i = 0; i < period - 1; i++) {
                    atr[i] = null;
                }
                
                return atr;
            }

            initializeChart() {
                const ctx = document.getElementById('mainChart').getContext('2d');
                
                this.chart = new Chart(ctx, {
                    type: 'candlestick',
                    data: {
                        datasets: [{
                            label: 'WIF/USDT',
                            data: []
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    color: '#888',
                                    font: { size: 11 },
                                    usePointStyle: true,
                                    padding: 10
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0,0,0,0.8)',
                                titleFont: { size: 12 },
                                bodyFont: { size: 11 },
                                padding: 8,
                                displayColors: false,
                                callbacks: {
                                    label: function(context) {
                                        if (context.raw && context.raw.o !== undefined) {
                                            return [
                                                `O: ${context.raw.o.toFixed(6)}`,
                                                `H: ${context.raw.h.toFixed(6)}`,
                                                `L: ${context.raw.l.toFixed(6)}`,
                                                `C: ${context.raw.c.toFixed(6)}`,
                                                `Vol: ${(context.raw.v / 1000).toFixed(2)}K`
                                            ];
                                        }
                                        return `${context.dataset.label}: ${context.parsed.y?.toFixed(6)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                grid: { color: '#222' },
                                ticks: { 
                                    color: '#666',
                                    font: { size: 10 },
                                    maxRotation: 0
                                }
                            },
                            y: {
                                position: 'right',
                                grid: { color: '#222' },
                                ticks: {
                                    color: '#666',
                                    font: { size: 10 }
                                }
                            }
                        }
                    }
                });
                
                this.updateChart();
            }

            updateChart() {
                if (!this.chart || this.data.candles.length === 0) return;
                
                // Prepare candlestick data
                const candleData = this.data.candles.slice(-200).map(c => ({
                    x: c.time,
                    o: c.open,
                    h: c.high,
                    l: c.low,
                    c: c.close,
                    v: c.volume
                }));
                
                // Update datasets
                const datasets = [{
                    label: 'WIF/USDT',
                    type: 'candlestick',
                    data: candleData,
                    color: {
                        up: '#4caf50',
                        down: '#f44336',
                        unchanged: '#666'
                    }
                }];
                
                // Add indicators if toggled
                const times = this.data.candles.slice(-200).map(c => c.time);
                
                if (document.getElementById('toggleEMA').checked && this.indicators.ema9) {
                    const ema9Data = this.indicators.ema9.slice(-200).map((v, i) => 
                        v !== null ? { x: times[i], y: v } : null
                    ).filter(d => d !== null);
                    
                    datasets.push({
                        label: 'EMA 9',
                        type: 'line',
                        data: ema9Data,
                        borderColor: '#9c27b0',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false
                    });
                    
                    const ema21Data = this.indicators.ema21.slice(-200).map((v, i) => 
                        v !== null ? { x: times[i], y: v } : null
                    ).filter(d => d !== null);
                    
                    datasets.push({
                        label: 'EMA 21',
                        type: 'line',
                        data: ema21Data,
                        borderColor: '#673ab7',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false
                    });
                }
                
                if (document.getElementById('toggleVWAP').checked && this.indicators.vwap) {
                    const vwapData = this.indicators.vwap.slice(-200).map((v, i) => 
                        v !== null ? { x: times[i], y: v } : null
                    ).filter(d => d !== null);
                    
                    datasets.push({
                        label: 'VWAP',
                        type: 'line',
                        data: vwapData,
                        borderColor: '#ff9800',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false
                    });
                }
                
                // Add prediction signals if any
                const recentSignals = this.data.signals.slice(-50);
                if (recentSignals.length > 0) {
                    const buySignals = recentSignals.filter(s => s.signal === 'BUY');
                    const sellSignals = recentSignals.filter(s => s.signal === 'SELL');
                    
                    if (buySignals.length > 0) {
                        datasets.push({
                            label: 'Buy',
                            type: 'scatter',
                            data: buySignals.map(s => ({ x: s.time, y: s.price })),
                            backgroundColor: '#4caf50',
                            pointStyle: 'triangle',
                            pointRadius: 8
                        });
                    }
                    
                    if (sellSignals.length > 0) {
                        datasets.push({
                            label: 'Sell',
                            type: 'scatter',
                            data: sellSignals.map(s => ({ x: s.time, y: s.price })),
                            backgroundColor: '#f44336',
                            pointStyle: 'triangleDown',
                            pointRadius: 8
                        });
                    }
                }
                
                this.chart.data.datasets = datasets;
                this.chart.update('none');
            }

            async connectWebSocket() {
                return new Promise((resolve) => {
                    const wsUrl = `wss://stream.binance.com:9443/ws/${this.config.symbol.toLowerCase()}@kline_${this.config.interval}`;
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        document.getElementById('wsStatus').textContent = 'Connected';
                        document.getElementById('wsIndicator').className = 'status-indicator connected';
                        this.addLog('WebSocket connected to Binance stream', 'success');
                        
                        // Subscribe to additional streams
                        this.ws.send(JSON.stringify({
                            method: "SUBSCRIBE",
                            params: [
                                `${this.config.symbol.toLowerCase()}@trade`,
                                `${this.config.symbol.toLowerCase()}@depth@100ms`
                            ],
                            id: 1
                        }));
                        
                        resolve();
                    };
                    
                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleWebSocketMessage(data);
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        document.getElementById('wsStatus').textContent = 'Error';
                        document.getElementById('wsIndicator').className = 'status-indicator disconnected';
                        this.addLog('WebSocket error occurred', 'error');
                    };
                    
                    this.ws.onclose = () => {
                        document.getElementById('wsStatus').textContent = 'Disconnected';
                        document.getElementById('wsIndicator').className = 'status-indicator disconnected';
                        this.addLog('WebSocket disconnected, attempting reconnection...', 'warning');
                        
                        // Reconnect after 5 seconds
                        setTimeout(() => this.connectWebSocket(), 5000);
                    };
                });
            }

            handleWebSocketMessage(data) {
                if (data.e === 'kline') {
                    const k = data.k;
                    const newCandle = {
                        time: k.t,
                        open: parseFloat(k.o),
                        high: parseFloat(k.h),
                        low: parseFloat(k.l),
                        close: parseFloat(k.c),
                        volume: parseFloat(k.v),
                        trades: k.n
                    };
                    
                    // Update or add candle
                    const existingIndex = this.data.candles.findIndex(c => c.time === newCandle.time);
                    if (existingIndex >= 0) {
                        this.data.candles[existingIndex] = newCandle;
                    } else {
                        this.data.candles.push(newCandle);
                        if (this.data.candles.length > 2000) {
                            this.data.candles.shift();
                        }
                    }
                    
                    // Update current price
                    document.getElementById('currentPrice').textContent = k.c;
                    
                    // Recalculate indicators
                    this.calculateIndicators();
                    
                    // Make prediction if models are trained
                    if (Object.keys(this.modelStats).length > 0) {
                        this.makePrediction();
                    }
                    
                    // Update chart
                    this.updateChart();
                    
                } else if (data.e === 'depthUpdate') {
                    // Update orderbook
                    if (data.b) this.data.orderbook.bids = data.b.slice(0, 20);
                    if (data.a) this.data.orderbook.asks = data.a.slice(0, 20);
                    
                } else if (data.e === 'trade') {
                    // Store recent trades
                    this.data.trades.push(data);
                    if (this.data.trades.length > 100) {
                        this.data.trades.shift();
                    }
                }
            }

            initializeModels() {
                // Define model configurations
                this.modelConfigs = {
                    linearRegression: {
                        name: 'Linear Regression',
                        type: 'classical',
                        enabled: true
                    },
                    ridgeRegression: {
                        name: 'Ridge Regression',
                        type: 'classical',
                        enabled: true
                    },
                    mlp: {
                        name: 'MLP Neural Net',
                        type: 'neural',
                        enabled: true
                    },
                    lstm: {
                        name: 'LSTM',
                        type: 'neural',
                        enabled: true
                    },
                    cnn: {
                        name: '1D CNN',
                        type: 'neural',
                        enabled: false
                    }
                };
                
                // Create model controls UI
                const modelControlsDiv = document.getElementById('modelControls');
                modelControlsDiv.innerHTML = '';
                
                Object.entries(this.modelConfigs).forEach(([key, config]) => {
                    const card = document.createElement('div');
                    card.className = 'model-card';
                    card.innerHTML = `
                        <div class="model-header">
                            <span class="model-name">${config.name}</span>
                            <span class="model-status" id="status-${key}">Not trained</span>
                        </div>
                        <div class="model-metrics" id="metrics-${key}">
                            <div class="model-metric">
                                <span>RMSE:</span>
                                <span>-</span>
                            </div>
                            <div class="model-metric">
                                <span>Accuracy:</span>
                                <span>-</span>
                            </div>
                        </div>
                    `;
                    modelControlsDiv.appendChild(card);
                });
                
                document.getElementById('modelsStatus').textContent = 'Ready';
            }

            createFeatures() {
                const features = [];
                const labels = [];
                
                // Need enough data for all indicators
                const startIndex = Math.max(50, this.config.lookback);
                
                for (let i = startIndex; i < this.data.candles.length - this.config.predictionWindow; i++) {
                    const feature = [];
                    
                    // Price features
                    const currentPrice = this.data.candles[i].close;
                    const returns = [];
                    for (let j = 1; j <= 5; j++) {
                        if (i >= j) {
                            returns.push((currentPrice - this.data.candles[i - j].close) / this.data.candles[i - j].close);
                        } else {
                            returns.push(0);
                        }
                    }
                    feature.push(...returns);
                    
                    // Volume features
                    const currentVolume = this.data.candles[i].volume;
                    const avgVolume = this.data.candles.slice(i - 20, i).reduce((a, b) => a + b.volume, 0) / 20;
                    feature.push(currentVolume / (avgVolume || 1));
                    
                    // Technical indicators
                    if (this.indicators.rsi && this.indicators.rsi[i] !== null) {
                        feature.push(this.indicators.rsi[i] / 100);
                    } else {
                        feature.push(0.5);
                    }
                    
                    if (this.indicators.macd && this.indicators.macd.histogram[i] !== null) {
                        feature.push(this.indicators.macd.histogram[i]);
                    } else {
                        feature.push(0);
                    }
                    
                    // Price position relative to moving averages
                    if (this.indicators.ema9[i] !== null) {
                        feature.push((currentPrice - this.indicators.ema9[i]) / currentPrice);
                    } else {
                        feature.push(0);
                    }
                    
                    if (this.indicators.ema21[i] !== null) {
                        feature.push((currentPrice - this.indicators.ema21[i]) / currentPrice);
                    } else {
                        feature.push(0);
                    }
                    
                    // Bollinger Band position
                    if (this.indicators.bb && this.indicators.bb.upper[i] !== null) {
                        const bbWidth = this.indicators.bb.upper[i] - this.indicators.bb.lower[i];
                        const bbPosition = (currentPrice - this.indicators.bb.lower[i]) / (bbWidth || 1);
                        feature.push(bbPosition);
                    } else {
                        feature.push(0.5);
                    }
                    
                    // VWAP divergence
                    if (this.indicators.vwap[i] !== null) {
                        feature.push((currentPrice - this.indicators.vwap[i]) / currentPrice);
                    } else {
                        feature.push(0);
                    }
                    
                    // Market microstructure (simplified)
                    feature.push(this.data.candles[i].trades / 1000); // Normalized trade count
                    
                    // Label: future return
                    const futurePrice = this.data.candles[i + this.config.predictionWindow].close;
                    const futureReturn = (futurePrice - currentPrice) / currentPrice;
                    
                    features.push(feature);
                    labels.push(futureReturn);
                }
                
                return { features, labels };
            }

            async trainModels() {
                if (this.isTraining) {
                    this.addLog('Training already in progress', 'warning');
                    return;
                }
                
                this.isTraining = true;
                document.getElementById('btnTrain').disabled = true;
                document.getElementById('modelsIndicator').className = 'status-indicator training';
                document.getElementById('modelsStatus').textContent = 'Training';
                
                try {
                    // Prepare data
                    this.addLog('Preparing training data...', 'info');
                    document.getElementById('trainingStatus').textContent = 'Extracting features...';
                    
                    const { features, labels } = this.createFeatures();
                    
                    if (features.length < this.config.minDataPoints) {
                        throw new Error(`Insufficient data: ${features.length} samples, need ${this.config.minDataPoints}`);
                    }
                    
                    this.addLog(`Created ${features.length} training samples with ${features[0].length} features each`, 'success');
                    
                    // Split data
                    const splitIndex = Math.floor(features.length * this.config.trainTestSplit);
                    const trainX = features.slice(0, splitIndex);
                    const trainY = labels.slice(0, splitIndex);
                    const testX = features.slice(splitIndex);
                    const testY = labels.slice(splitIndex);
                    
                    this.addLog(`Train: ${trainX.length} samples, Test: ${testX.length} samples`, 'info');
                    
                    // Train each model
                    let progress = 0;
                    const totalModels = Object.keys(this.modelConfigs).filter(k => this.modelConfigs[k].enabled).length;
                    
                    for (const [modelKey, config] of Object.entries(this.modelConfigs)) {
                        if (!config.enabled) continue;
                        
                        document.getElementById('trainingStatus').textContent = `Training ${config.name}...`;
                        document.getElementById(`status-${modelKey}`).textContent = 'Training';
                        document.getElementById(`status-${modelKey}`).className = 'model-status training';
                        
                        try {
                            if (config.type === 'classical') {
                                await this.trainClassicalModel(modelKey, trainX, trainY, testX, testY);
                            } else {
                                await this.trainNeuralModel(modelKey, trainX, trainY, testX, testY);
                            }
                            
                            document.getElementById(`status-${modelKey}`).textContent = 'Trained';
                            document.getElementById(`status-${modelKey}`).className = 'model-status trained';
                            
                        } catch (error) {
                            this.addLog(`Error training ${config.name}: ${error.message}`, 'error');
                            document.getElementById(`status-${modelKey}`).textContent = 'Failed';
                        }
                        
                        progress++;
                        const progressPercent = (progress / totalModels) * 100;
                        document.getElementById('progressFill').style.width = progressPercent + '%';
                    }
                    
                    // Find best model
                    this.selectBestModel();
                    
                    document.getElementById('trainingStatus').textContent = 'Training complete!';
                    this.addLog('All models trained successfully', 'success');
                    
                } catch (error) {
                    this.addLog(`Training error: ${error.message}`, 'error');
                    document.getElementById('trainingStatus').textContent = 'Training failed';
                    
                } finally {
                    this.isTraining = false;
                    document.getElementById('btnTrain').disabled = false;
                    document.getElementById('modelsIndicator').className = 'status-indicator connected';
                    document.getElementById('modelsStatus').textContent = 'Trained';
                }
            }

            async trainClassicalModel(modelKey, trainX, trainY, testX, testY) {
                // Simple linear regression implementation
                const model = {
                    weights: [],
                    bias: 0,
                    predict: function(X) {
                        if (Array.isArray(X[0])) {
                            return X.map(x => this.predictOne(x));
                        }
                        return this.predictOne(X);
                    },
                    predictOne: function(x) {
                        let sum = this.bias;
                        for (let i = 0; i < x.length; i++) {
                            sum += x[i] * this.weights[i];
                        }
                        return sum;
                    }
                };
                
                // Initialize weights
                const numFeatures = trainX[0].length;
                model.weights = new Array(numFeatures).fill(0).map(() => (Math.random() - 0.5) * 0.01);
                model.bias = 0;
                
                // Training parameters
                const learningRate = modelKey === 'ridgeRegression' ? 0.001 : 0.01;
                const epochs = 100;
                const lambda = modelKey === 'ridgeRegression' ? 0.01 : 0; // L2 regularization
                
                // Gradient descent
                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalLoss = 0;
                    
                    for (let i = 0; i < trainX.length; i++) {
                        const pred = model.predictOne(trainX[i]);
                        const error = pred - trainY[i];
                        totalLoss += error * error;
                        
                        // Update weights
                        for (let j = 0; j < numFeatures; j++) {
                            const gradient = error * trainX[i][j] + lambda * model.weights[j];
                            model.weights[j] -= learningRate * gradient;
                        }
                        model.bias -= learningRate * error;
                    }
                    
                    if (epoch % 20 === 0) {
                        const avgLoss = totalLoss / trainX.length;
                        document.getElementById('trainingEpoch').textContent = `Epoch ${epoch}/${epochs} - Loss: ${avgLoss.toFixed(6)}`;
                    }
                }
                
                // Evaluate on test set
                const predictions = model.predict(testX);
                const rmse = Math.sqrt(
                    predictions.reduce((sum, pred, i) => sum + Math.pow(pred - testY[i], 2), 0) / predictions.length
                );
                
                const directionAccuracy = predictions.reduce((acc, pred, i) => {
                    return acc + (Math.sign(pred) === Math.sign(testY[i]) ? 1 : 0);
                }, 0) / predictions.length;
                
                // Store model and stats
                this.models[modelKey] = model;
                this.modelStats[modelKey] = {
                    rmse: rmse,
                    accuracy: directionAccuracy,
                    trainSamples: trainX.length,
                    testSamples: testX.length
                };
                
                // Update UI
                document.getElementById(`metrics-${modelKey}`).innerHTML = `
                    <div class="model-metric">
                        <span>RMSE:</span>
                        <span>${rmse.toFixed(6)}</span>
                    </div>
                    <div class="model-metric">
                        <span>Accuracy:</span>
                        <span>${(directionAccuracy * 100).toFixed(1)}%</span>
                    </div>
                `;
                
                this.addLog(`${this.modelConfigs[modelKey].name} - RMSE: ${rmse.toFixed(6)}, Accuracy: ${(directionAccuracy * 100).toFixed(1)}%`, 'success');
            }

            async trainNeuralModel(modelKey, trainX, trainY, testX, testY) {
                const numFeatures = trainX[0].length;
                
                // Create model architecture based on type
                let model;
                
                if (modelKey === 'mlp') {
                    model = tf.sequential({
                        layers: [
                            tf.layers.dense({ units: 32, activation: 'relu', inputShape: [numFeatures] }),
                            tf.layers.dropout({ rate: 0.2 }),
                            tf.layers.dense({ units: 16, activation: 'relu' }),
                            tf.layers.dropout({ rate: 0.1 }),
                            tf.layers.dense({ units: 1 })
                        ]
                    });
                } else if (modelKey === 'lstm') {
                    // Reshape data for LSTM (samples, timesteps, features)
                    const lookback = 10;
                    const reshapedTrainX = [];
                    const reshapedTrainY = [];
                    
                    for (let i = lookback; i < trainX.length; i++) {
                        reshapedTrainX.push(trainX.slice(i - lookback, i));
                        reshapedTrainY.push(trainY[i]);
                    }
                    
                    model = tf.sequential({
                        layers: [
                            tf.layers.lstm({ units: 32, returnSequences: false, inputShape: [lookback, numFeatures] }),
                            tf.layers.dropout({ rate: 0.2 }),
                            tf.layers.dense({ units: 16, activation: 'relu' }),
                            tf.layers.dense({ units: 1 })
                        ]
                    });
                    
                    trainX = reshapedTrainX;
                    trainY = reshapedTrainY;
                } else if (modelKey === 'cnn') {
                    model = tf.sequential({
                        layers: [
                            tf.layers.conv1d({ filters: 32, kernelSize: 3, activation: 'relu', inputShape: [numFeatures, 1] }),
                            tf.layers.maxPooling1d({ poolSize: 2 }),
                            tf.layers.flatten(),
                            tf.layers.dense({ units: 16, activation: 'relu' }),
                            tf.layers.dense({ units: 1 })
                        ]
                    });
                }
                
                // Compile model
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                // Convert data to tensors
                const trainXTensor = tf.tensor2d(trainX);
                const trainYTensor = tf.tensor2d(trainY, [trainY.length, 1]);
                const testXTensor = tf.tensor2d(testX);
                const testYTensor = tf.tensor2d(testY, [testY.length, 1]);
                
                // Train model
                const epochs = 50;
                const batchSize = 32;
                
                await model.fit(trainXTensor, trainYTensor, {
                    epochs: epochs,
                    batchSize: batchSize,
                    validationSplit: 0.1,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            if (epoch % 10 === 0) {
                                document.getElementById('trainingEpoch').textContent = 
                                    `Epoch ${epoch}/${epochs} - Loss: ${logs.loss.toFixed(6)}`;
                            }
                        }
                    },
                    verbose: 0
                });
                
                // Evaluate
                const evalResult = await model.evaluate(testXTensor, testYTensor);
                const predictions = await model.predict(testXTensor).data();
                const actuals = await testYTensor.data();
                
                const rmse = Math.sqrt(
                    predictions.reduce((sum, pred, i) => sum + Math.pow(pred - actuals[i], 2), 0) / predictions.length
                );
                
                const directionAccuracy = predictions.reduce((acc, pred, i) => {
                    return acc + (Math.sign(pred) === Math.sign(actuals[i]) ? 1 : 0);
                }, 0) / predictions.length;
                
                // Store model and stats
                this.models[modelKey] = model;
                this.modelStats[modelKey] = {
                    rmse: rmse,
                    accuracy: directionAccuracy,
                    trainSamples: trainX.length,
                    testSamples: testX.length
                };
                
                // Update UI
                document.getElementById(`metrics-${modelKey}`).innerHTML = `
                    <div class="model-metric">
                        <span>RMSE:</span>
                        <span>${rmse.toFixed(6)}</span>
                    </div>
                    <div class="model-metric">
                        <span>Accuracy:</span>
                        <span>${(directionAccuracy * 100).toFixed(1)}%</span>
                    </div>
                `;
                
                this.addLog(`${this.modelConfigs[modelKey].name} - RMSE: ${rmse.toFixed(6)}, Accuracy: ${(directionAccuracy * 100).toFixed(1)}%`, 'success');
                
                // Cleanup tensors
                trainXTensor.dispose();
                trainYTensor.dispose();
                testXTensor.dispose();
                testYTensor.dispose();
            }

            selectBestModel() {
                let bestModel = null;
                let bestScore = Infinity;
                
                for (const [modelKey, stats] of Object.entries(this.modelStats)) {
                    // Score based on RMSE and accuracy
                    const score = stats.rmse * (2 - stats.accuracy);
                    
                    if (score < bestScore) {
                        bestScore = score;
                        bestModel = modelKey;
                    }
                }
                
                if (bestModel) {
                    const config = this.modelConfigs[bestModel];
                    const stats = this.modelStats[bestModel];
                    
                    document.getElementById('bestModel').textContent = config.name;
                    document.getElementById('bestModelAccuracy').textContent = 
                        `${(stats.accuracy * 100).toFixed(1)}% accuracy`;
                    
                    this.addLog(`Best model: ${config.name} with ${(stats.accuracy * 100).toFixed(1)}% accuracy`, 'success');
                }
                
                // Update overall metrics
                const avgAccuracy = Object.values(this.modelStats).reduce((sum, s) => sum + s.accuracy, 0) / 
                                   Object.values(this.modelStats).length;
                const avgRMSE = Object.values(this.modelStats).reduce((sum, s) => sum + s.rmse, 0) / 
                               Object.values(this.modelStats).length;
                
                document.getElementById('directionAccuracy').textContent = `${(avgAccuracy * 100).toFixed(1)}%`;
                document.getElementById('avgError').textContent = avgRMSE.toFixed(6);
                
                // Create performance comparison
                this.updateModelComparison();
            }

            updateModelComparison() {
                const perfDiv = document.getElementById('modelPerformance');
                let html = '<div style="padding: 15px;">';
                
                // Sort models by accuracy
                const sortedModels = Object.entries(this.modelStats)
                    .sort((a, b) => b[1].accuracy - a[1].accuracy);
                
                sortedModels.forEach(([modelKey, stats]) => {
                    const config = this.modelConfigs[modelKey];
                    html += `
                        <div style="margin-bottom: 15px; padding: 10px; background: #222; border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <strong>${config.name}</strong>
                                <span style="color: #4caf50;">${(stats.accuracy * 100).toFixed(1)}% accurate</span>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 11px; color: #888;">
                                <div>RMSE: ${stats.rmse.toFixed(6)}</div>
                                <div>Train: ${stats.trainSamples} samples</div>
                                <div>Test: ${stats.testSamples} samples</div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                perfDiv.innerHTML = html;
            }

            async makePrediction() {
                if (!this.models || Object.keys(this.models).length === 0) return;
                
                // Create current feature vector
                const { features } = this.createFeatures();
                if (features.length === 0) return;
                
                const currentFeatures = features[features.length - 1];
                const currentPrice = this.data.candles[this.data.candles.length - 1].close;
                const currentTime = Date.now();
                
                const predictions = {};
                let totalPrediction = 0;
                let validPredictions = 0;
                
                // Get predictions from each model
                for (const [modelKey, model] of Object.entries(this.models)) {
                    try {
                        let prediction;
                        
                        if (this.modelConfigs[modelKey].type === 'classical') {
                            prediction = model.predictOne(currentFeatures);
                        } else {
                            const input = tf.tensor2d([currentFeatures]);
                            const output = await model.predict(input).data();
                            prediction = output[0];
                            input.dispose();
                        }
                        
                        predictions[modelKey] = prediction;
                        totalPrediction += prediction;
                        validPredictions++;
                        
                    } catch (error) {
                        console.error(`Prediction error for ${modelKey}:`, error);
                    }
                }
                
                if (validPredictions === 0) return;
                
                // Calculate ensemble prediction
                const ensemblePrediction = totalPrediction / validPredictions;
                const predictedPrice = currentPrice * (1 + ensemblePrediction);
                
                // Determine signal
                let signal = 'HOLD';
                let confidence = 0;
                
                const threshold = 0.001; // 0.1% movement threshold
                if (ensemblePrediction > threshold) {
                    signal = 'BUY';
                    confidence = Math.min(ensemblePrediction * 100, 100);
                } else if (ensemblePrediction < -threshold) {
                    signal = 'SELL';
                    confidence = Math.min(Math.abs(ensemblePrediction) * 100, 100);
                }
                
                // Store prediction
                const predictionRecord = {
                    time: currentTime,
                    price: currentPrice,
                    predictions: predictions,
                    ensemble: ensemblePrediction,
                    predictedPrice: predictedPrice,
                    signal: signal,
                    confidence: confidence
                };
                
                this.data.predictions.push(predictionRecord);
                if (this.data.predictions.length > 100) {
                    this.data.predictions.shift();
                }
                
                // Add signal to chart if significant
                if (signal !== 'HOLD' && confidence > 50) {
                    this.data.signals.push({
                        time: currentTime,
                        price: currentPrice,
                        signal: signal,
                        confidence: confidence
                    });
                    
                    if (this.data.signals.length > 50) {
                        this.data.signals.shift();
                    }
                }
                
                // Update predictions table
                this.updatePredictionsTable();
                
                // Update metrics
                document.getElementById('signalConfidence').textContent = `${confidence.toFixed(1)}%`;
                
                // Determine market regime
                const recentReturns = [];
                for (let i = 1; i <= 20 && i < this.data.candles.length; i++) {
                    const idx = this.data.candles.length - i;
                    recentReturns.push(
                        (this.data.candles[idx].close - this.data.candles[idx - 1].close) / 
                        this.data.candles[idx - 1].close
                    );
                }
                
                const volatility = Math.sqrt(
                    recentReturns.reduce((sum, r) => sum + r * r, 0) / recentReturns.length
                ) * Math.sqrt(1440); // Annualized for 1-minute bars
                
                let regime = 'Neutral';
                if (volatility > 0.5) regime = 'High Volatility';
                else if (volatility < 0.2) regime = 'Low Volatility';
                
                const trend = recentReturns.reduce((a, b) => a + b, 0) / recentReturns.length;
                if (trend > 0.0001) regime = 'Bullish ' + regime;
                else if (trend < -0.0001) regime = 'Bearish ' + regime;
                
                document.getElementById('marketRegime').textContent = regime;
                document.getElementById('regimeConfidence').textContent = `Vol: ${(volatility * 100).toFixed(1)}%`;
            }

            updatePredictionsTable() {
                const tbody = document.getElementById('predictionsTable');
                const recentPredictions = this.data.predictions.slice(-10).reverse();
                
                if (recentPredictions.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; color: #888;">No predictions yet - models need training</td></tr>';
                    return;
                }
                
                tbody.innerHTML = recentPredictions.map(pred => {
                    const bestModel = Object.entries(pred.predictions)
                        .reduce((a, b) => Math.abs(a[1]) > Math.abs(b[1]) ? a : b);
                    
                    // Calculate actual error if we have future data
                    let actualError = '-';
                    let result = '-';
                    const futureIndex = this.data.candles.findIndex(c => 
                        c.time > pred.time && c.time >= pred.time + this.config.predictionWindow * 60000
                    );
                    
                    if (futureIndex > 0) {
                        const actualPrice = this.data.candles[futureIndex].close;
                        const error = ((pred.predictedPrice - actualPrice) / actualPrice * 100);
                        actualError = `${error.toFixed(3)}%`;
                        
                        const actualReturn = (actualPrice - pred.price) / pred.price;
                        const predReturn = pred.ensemble;
                        result = Math.sign(actualReturn) === Math.sign(predReturn) ? 
                            '<span style="color: #4caf50;"></span>' : 
                            '<span style="color: #f44336;"></span>';
                    }
                    
                    return `
                        <tr>
                            <td>${new Date(pred.time).toLocaleTimeString()}</td>
                            <td>$${pred.price.toFixed(6)}</td>
                            <td>${this.modelConfigs[bestModel[0]].name}</td>
                            <td>$${pred.predictedPrice.toFixed(6)}</td>
                            <td>${actualError}</td>
                            <td class="signal-${pred.signal.toLowerCase()}">${pred.signal}</td>
                            <td>${pred.confidence.toFixed(1)}%</td>
                            <td>${(pred.ensemble * 100).toFixed(3)}%</td>
                            <td>${result}</td>
                        </tr>
                    `;
                }).join('');
            }

            updateUI() {
                // Update data points count
                document.getElementById('dataPoints').textContent = this.data.candles.length;
                
                // Setup auto-update for metrics
                setInterval(() => {
                    if (this.data.predictions.length > 10) {
                        // Calculate recent accuracy
                        let correct = 0;
                        let total = 0;
                        
                        this.data.predictions.forEach(pred => {
                            const futureIndex = this.data.candles.findIndex(c => 
                                c.time > pred.time && c.time >= pred.time + this.config.predictionWindow * 60000
                            );
                            
                            if (futureIndex > 0) {
                                const actualPrice = this.data.candles[futureIndex].close;
                                const actualReturn = (actualPrice - pred.price) / pred.price;
                                
                                if (Math.sign(actualReturn) === Math.sign(pred.ensemble)) {
                                    correct++;
                                }
                                total++;
                            }
                        });
                        
                        if (total > 0) {
                            const accuracy = (correct / total * 100);
                            document.getElementById('directionAccuracy').textContent = `${accuracy.toFixed(1)}%`;
                            document.getElementById('directionChange').textContent = 
                                `${correct}/${total} correct`;
                        }
                    }
                }, 5000);
            }
        }

        // Global functions
        let predictor = null;

        async function trainModels() {
            if (predictor) {
                await predictor.trainModels();
            }
        }

        async function runBacktest() {
            if (!predictor || Object.keys(predictor.models).length === 0) {
                alert('Please train models first before running backtest');
                return;
            }
            
            predictor.addLog('Starting backtest...', 'info');
            
            // Simple backtest logic
            const startCapital = 10000;
            let capital = startCapital;
            let position = 0;
            let trades = 0;
            let wins = 0;
            
            const { features, labels } = predictor.createFeatures();
            const testStart = Math.floor(features.length * 0.8);
            
            for (let i = testStart; i < features.length - 1; i++) {
                const feature = features[i];
                const currentPrice = predictor.data.candles[i + 50].close;
                
                // Get ensemble prediction
                let totalPred = 0;
                let count = 0;
                
                for (const [modelKey, model] of Object.entries(predictor.models)) {
                    try {
                        if (predictor.modelConfigs[modelKey].type === 'classical') {
                            totalPred += model.predictOne(feature);
                        } else {
                            const input = tf.tensor2d([feature]);
                            const output = await model.predict(input).data();
                            totalPred += output[0];
                            input.dispose();
                        }
                        count++;
                    } catch (e) {}
                }
                
                if (count === 0) continue;
                
                const prediction = totalPred / count;
                const actualReturn = labels[i];
                
                // Simple strategy: go long if prediction > 0.001, short if < -0.001
                if (prediction > 0.001 && position <= 0) {
                    position = capital / currentPrice;
                    trades++;
                } else if (prediction < -0.001 && position >= 0) {
                    if (position > 0) {
                        capital = position * currentPrice;
                        position = 0;
                    }
                    position = -capital / currentPrice;
                    trades++;
                }
                
                // Update capital based on position
                if (position !== 0) {
                    const nextPrice = predictor.data.candles[i + 51].close;
                    if (position > 0) {
                        capital = position * nextPrice;
                    } else {
                        capital = capital + (position * (currentPrice - nextPrice));
                    }
                    
                    if (actualReturn > 0 && prediction > 0 || actualReturn < 0 && prediction < 0) {
                        wins++;
                    }
                }
            }
            
            const totalReturn = ((capital - startCapital) / startCapital * 100);
            document.getElementById('backtestPnL').textContent = `$${(capital - startCapital).toFixed(2)}`;
            document.getElementById('backtestReturn').textContent = `${totalReturn.toFixed(2)}%`;
            document.getElementById('backtestReturn').className = totalReturn >= 0 ? 'metric-change positive' : 'metric-change negative';
            
            predictor.addLog(`Backtest complete: ${trades} trades, ${wins} wins, Return: ${totalReturn.toFixed(2)}%`, 'success');
        }

        function clearSignals() {
            if (predictor) {
                predictor.data.signals = [];
                predictor.updateChart();
                predictor.addLog('Signals cleared', 'info');
            }
        }

        function exportResults() {
            if (!predictor) return;
            
            const exportData = {
                timestamp: new Date().toISOString(),
                config: predictor.config,
                modelStats: predictor.modelStats,
                predictions: predictor.data.predictions,
                signals: predictor.data.signals,
                log: predictor.log
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `wif-predictions-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            predictor.addLog('Results exported', 'success');
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async () => {
            predictor = new RealWIFPredictor();
            await predictor.initialize();
        });

        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (predictor && predictor.ws) {
                predictor.ws.close();
            }
        });
    </script>
</body>
</html>
