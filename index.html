<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Trading Assistant</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a40 100%);
            color: #ffffff;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .trading-grid {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .sidebar {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .main-chart {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 600px;
        }
        
        .indicators-panel {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .crypto-selector {
            margin-bottom: 20px;
        }
        
        .crypto-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .crypto-btn {
            background: rgba(66, 165, 245, 0.2);
            border: 1px solid #42A5F5;
            color: white;
            padding: 8px 4px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 11px;
            text-align: center;
        }
        
        .crypto-btn:hover {
            background: rgba(66, 165, 245, 0.4);
            transform: translateY(-2px);
        }
        
        .crypto-btn.active {
            background: #42A5F5;
            box-shadow: 0 0 20px rgba(66, 165, 245, 0.5);
        }
        
        .indicator-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .indicator-title {
            color: #42A5F5;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .indicator-value {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .bullish { color: #4CAF50; }
        .bearish { color: #F44336; }
        .neutral { color: #FFC107; }
        
        .prediction-panel {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .prediction-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .price-display {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .change-display {
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        
        .loading {
            text-align: center;
            color: #42A5F5;
            font-style: italic;
        }
        
        .alert-panel {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid #FFC107;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .signal-strength {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .signal-strong { background: #4CAF50; }
        .signal-moderate { background: #FFC107; color: black; }
        .signal-weak { background: #F44336; }
        
        .timeframe-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .timeframe-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .timeframe-btn.active {
            background: #42A5F5;
        }
        
        @media (max-width: 1200px) {
            .trading-grid {
                grid-template-columns: 1fr;
            }
            
            .crypto-grid {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Advanced Trading Assistant</h1>
            <p>Professional-grade technical analysis with real-time data and AI predictions</p>
        </div>
        
        <div class="trading-grid">
            <div class="sidebar">
                <div class="crypto-selector">
                    <h3>Select Cryptocurrency</h3>
                    <div class="crypto-grid" id="cryptoGrid">
                        <!-- Crypto buttons will be populated here -->
                    </div>
                </div>
                
                <div class="timeframe-selector">
                    <button class="timeframe-btn active" data-timeframe="1h">1H</button>
                    <button class="timeframe-btn" data-timeframe="4h">4H</button>
                    <button class="timeframe-btn" data-timeframe="1d">1D</button>
                    <button class="timeframe-btn" data-timeframe="1w">1W</button>
                </div>
                
                <div id="alertsPanel">
                    <h3>🚨 Trading Alerts</h3>
                    <div id="alerts"></div>
                </div>
            </div>
            
            <div class="main-chart">
                <canvas id="mainChart"></canvas>
            </div>
            
            <div class="indicators-panel" id="indicatorsPanel">
                <h3>📊 Technical Indicators</h3>
                <div id="indicators"></div>
            </div>
        </div>
        
        <div class="prediction-panel">
            <h3>🔮 AI Predictions & Analysis</h3>
            <div class="prediction-grid" id="predictionsGrid">
                <!-- Predictions will be populated here -->
            </div>
        </div>
    </div>

    <script>
        class TradingAssistant {
            constructor() {
                this.cryptos = [
                    { symbol: 'BTCUSDT', name: 'BTC', fullName: 'Bitcoin' },
                    { symbol: 'ETHUSDT', name: 'ETH', fullName: 'Ethereum' },
                    { symbol: 'SOLUSDT', name: 'SOL', fullName: 'Solana' },
                    { symbol: 'AVAXUSDT', name: 'AVAX', fullName: 'Avalanche' },
                    { symbol: 'ADAUSDT', name: 'ADA', fullName: 'Cardano' },
                    { symbol: 'DOTUSDT', name: 'DOT', fullName: 'Polkadot' },
                    { symbol: 'MATICUSDT', name: 'MATIC', fullName: 'Polygon' },
                    { symbol: 'LINKUSDT', name: 'LINK', fullName: 'Chainlink' },
                    { symbol: 'UNIUSDT', name: 'UNI', fullName: 'Uniswap' },
                    { symbol: 'LTCUSDT', name: 'LTC', fullName: 'Litecoin' }
                ];
                
                this.currentSymbol = 'BTCUSDT';
                this.currentTimeframe = '1h';
                this.chart = null;
                this.priceData = [];
                this.wsConnection = null;
                
                this.init();
            }
            
            async init() {
                this.renderCryptoButtons();
                this.setupEventListeners();
                await this.loadInitialData();
                this.setupWebSocket();
                this.startRealTimeUpdates();
            }
            
            renderCryptoButtons() {
                const grid = document.getElementById('cryptoGrid');
                grid.innerHTML = this.cryptos.map(crypto => `
                    <button class="crypto-btn ${crypto.symbol === this.currentSymbol ? 'active' : ''}" 
                            data-symbol="${crypto.symbol}">
                        ${crypto.name}
                    </button>
                `).join('');
            }
            
            setupEventListeners() {
                // Crypto selection
                document.getElementById('cryptoGrid').addEventListener('click', (e) => {
                    if (e.target.classList.contains('crypto-btn')) {
                        document.querySelectorAll('.crypto-btn').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentSymbol = e.target.dataset.symbol;
                        this.loadInitialData();
                    }
                });
                
                // Timeframe selection
                document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentTimeframe = e.target.dataset.timeframe;
                        this.loadInitialData();
                    });
                });
            }
            
            async loadInitialData() {
                try {
                    const interval = this.getInterval(this.currentTimeframe);
                    const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${this.currentSymbol}&interval=${interval}&limit=200`);
                    const data = await response.json();
                    
                    this.priceData = data.map(candle => ({
                        timestamp: candle[0],
                        open: parseFloat(candle[1]),
                        high: parseFloat(candle[2]),
                        low: parseFloat(candle[3]),
                        close: parseFloat(candle[4]),
                        volume: parseFloat(candle[5])
                    }));
                    
                    this.renderChart();
                    this.calculateIndicators();
                    this.generatePredictions();
                    this.updateAlerts();
                    
                } catch (error) {
                    console.error('Error loading data:', error);
                }
            }
            
            getInterval(timeframe) {
                const intervals = {
                    '1h': '1h',
                    '4h': '4h',
                    '1d': '1d',
                    '1w': '1w'
                };
                return intervals[timeframe] || '1h';
            }
            
            renderChart() {
                const ctx = document.getElementById('mainChart').getContext('2d');
                
                if (this.chart) {
                    this.chart.destroy();
                }
                
                const labels = this.priceData.map(d => new Date(d.timestamp).toLocaleTimeString());
                const prices = this.priceData.map(d => d.close);
                const volumes = this.priceData.map(d => d.volume);
                
                // Calculate moving averages
                const sma20 = this.calculateSMA(prices, 20);
                const sma50 = this.calculateSMA(prices, 50);
                const ema12 = this.calculateEMA(prices, 12);
                const ema26 = this.calculateEMA(prices, 26);
                
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Price',
                                data: prices,
                                borderColor: '#42A5F5',
                                backgroundColor: 'rgba(66, 165, 245, 0.1)',
                                borderWidth: 2,
                                tension: 0.1,
                                fill: true
                            },
                            {
                                label: 'SMA 20',
                                data: sma20,
                                borderColor: '#4CAF50',
                                borderWidth: 1,
                                fill: false
                            },
                            {
                                label: 'SMA 50',
                                data: sma50,
                                borderColor: '#FF9800',
                                borderWidth: 1,
                                fill: false
                            },
                            {
                                label: 'EMA 12',
                                data: ema12,
                                borderColor: '#E91E63',
                                borderWidth: 1,
                                fill: false,
                                borderDash: [5, 5]
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            },
                            y: {
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: { color: '#ffffff' }
                            }
                        }
                    }
                });
            }
            
            calculateIndicators() {
                const prices = this.priceData.map(d => d.close);
                const highs = this.priceData.map(d => d.high);
                const lows = this.priceData.map(d => d.low);
                const volumes = this.priceData.map(d => d.volume);
                
                // RSI
                const rsi = this.calculateRSI(prices, 14);
                const currentRSI = rsi[rsi.length - 1];
                
                // MACD
                const macd = this.calculateMACD(prices);
                const currentMACD = macd[macd.length - 1];
                
                // Bollinger Bands
                const bb = this.calculateBollingerBands(prices, 20, 2);
                const currentBB = bb[bb.length - 1];
                
                // Stochastic
                const stoch = this.calculateStochastic(highs, lows, prices, 14);
                const currentStoch = stoch[stoch.length - 1];
                
                // Williams %R
                const willR = this.calculateWilliamsR(highs, lows, prices, 14);
                const currentWillR = willR[willR.length - 1];
                
                // Volume indicators
                const volumeSMA = this.calculateSMA(volumes, 20);
                const currentVolumeRatio = volumes[volumes.length - 1] / volumeSMA[volumeSMA.length - 1];
                
                // Price momentum
                const momentum = this.calculateMomentum(prices, 10);
                const currentMomentum = momentum[momentum.length - 1];
                
                // Commodity Channel Index
                const cci = this.calculateCCI(highs, lows, prices, 20);
                const currentCCI = cci[cci.length - 1];
                
                // Average True Range
                const atr = this.calculateATR(highs, lows, prices, 14);
                const currentATR = atr[atr.length - 1];
                
                this.renderIndicators({
                    rsi: currentRSI,
                    macd: currentMACD,
                    bb: currentBB,
                    stochastic: currentStoch,
                    williamsR: currentWillR,
                    volumeRatio: currentVolumeRatio,
                    momentum: currentMomentum,
                    cci: currentCCI,
                    atr: currentATR,
                    currentPrice: prices[prices.length - 1]
                });
            }
            
            renderIndicators(indicators) {
                const panel = document.getElementById('indicators');
                
                const getRSISignal = (rsi) => {
                    if (rsi > 70) return { signal: 'bearish', strength: 'strong', text: 'OVERBOUGHT' };
                    if (rsi < 30) return { signal: 'bullish', strength: 'strong', text: 'OVERSOLD' };
                    if (rsi > 60) return { signal: 'bearish', strength: 'moderate', text: 'SELLING PRESSURE' };
                    if (rsi < 40) return { signal: 'bullish', strength: 'moderate', text: 'BUYING OPPORTUNITY' };
                    return { signal: 'neutral', strength: 'weak', text: 'NEUTRAL' };
                };
                
                const getMACDSignal = (macd) => {
                    if (!macd) return { signal: 'neutral', strength: 'weak', text: 'NO SIGNAL' };
                    if (macd.macd > macd.signal && macd.histogram > 0) return { signal: 'bullish', strength: 'strong', text: 'BULLISH CROSSOVER' };
                    if (macd.macd < macd.signal && macd.histogram < 0) return { signal: 'bearish', strength: 'strong', text: 'BEARISH CROSSOVER' };
                    return { signal: 'neutral', strength: 'moderate', text: 'SIDEWAYS' };
                };
                
                const getBBSignal = (bb, price) => {
                    if (!bb) return { signal: 'neutral', strength: 'weak', text: 'NO DATA' };
                    if (price > bb.upper) return { signal: 'bearish', strength: 'moderate', text: 'ABOVE UPPER BAND' };
                    if (price < bb.lower) return { signal: 'bullish', strength: 'moderate', text: 'BELOW LOWER BAND' };
                    return { signal: 'neutral', strength: 'weak', text: 'WITHIN BANDS' };
                };
                
                const rsiSignal = getRSISignal(indicators.rsi);
                const macdSignal = getMACDSignal(indicators.macd);
                const bbSignal = getBBSignal(indicators.bb, indicators.currentPrice);
                
                panel.innerHTML = `
                    <div class="indicator-group">
                        <div class="indicator-title">💎 RSI (14)</div>
                        <div class="indicator-value">
                            <span>Value:</span>
                            <span class="${rsiSignal.signal}">${indicators.rsi?.toFixed(2) || 'N/A'}</span>
                        </div>
                        <div class="indicator-value">
                            <span>Signal:</span>
                            <span class="signal-strength signal-${rsiSignal.strength}">${rsiSignal.text}</span>
                        </div>
                    </div>
                    
                    <div class="indicator-group">
                        <div class="indicator-title">📈 MACD</div>
                        <div class="indicator-value">
                            <span>MACD:</span>
                            <span class="${macdSignal.signal}">${indicators.macd?.macd?.toFixed(4) || 'N/A'}</span>
                        </div>
                        <div class="indicator-value">
                            <span>Signal:</span>
                            <span>${indicators.macd?.signal?.toFixed(4) || 'N/A'}</span>
                        </div>
                        <div class="indicator-value">
                            <span>Status:</span>
                            <span class="signal-strength signal-${macdSignal.strength}">${macdSignal.text}</span>
                        </div>
                    </div>
                    
                    <div class="indicator-group">
                        <div class="indicator-title">🎯 Bollinger Bands</div>
                        <div class="indicator-value">
                            <span>Upper:</span>
                            <span>${indicators.bb?.upper?.toFixed(2) || 'N/A'}</span>
                        </div>
                        <div class="indicator-value">
                            <span>Middle:</span>
                            <span>${indicators.bb?.middle?.toFixed(2) || 'N/A'}</span>
                        </div>
                        <div class="indicator-value">
                            <span>Lower:</span>
                            <span>${indicators.bb?.lower?.toFixed(2) || 'N/A'}</span>
                        </div>
                        <div class="indicator-value">
                            <span>Signal:</span>
                            <span class="signal-strength signal-${bbSignal.strength}">${bbSignal.text}</span>
                        </div>
                    </div>
                    
                    <div class="indicator-group">
                        <div class="indicator-title">⚡ Stochastic</div>
                        <div class="indicator-value">
                            <span>%K:</span>
                            <span class="${indicators.stochastic?.k > 80 ? 'bearish' : indicators.stochastic?.k < 20 ? 'bullish' : 'neutral'}">${indicators.stochastic?.k?.toFixed(2) || 'N/A'}</span>
                        </div>
                        <div class="indicator-value">
                            <span>%D:</span>
                            <span>${indicators.stochastic?.d?.toFixed(2) || 'N/A'}</span>
                        </div>
                    </div>
                    
                    <div class="indicator-group">
                        <div class="indicator-title">📊 Volume Analysis</div>
                        <div class="indicator-value">
                            <span>Ratio:</span>
                            <span class="${indicators.volumeRatio > 1.5 ? 'bullish' : indicators.volumeRatio < 0.8 ? 'bearish' : 'neutral'}">${indicators.volumeRatio?.toFixed(2) || 'N/A'}x</span>
                        </div>
                    </div>
                    
                    <div class="indicator-group">
                        <div class="indicator-title">🚀 Momentum</div>
                        <div class="indicator-value">
                            <span>Value:</span>
                            <span class="${indicators.momentum > 0 ? 'bullish' : 'bearish'}">${indicators.momentum?.toFixed(4) || 'N/A'}</span>
                        </div>
                    </div>
                    
                    <div class="indicator-group">
                        <div class="indicator-title">🌊 CCI (20)</div>
                        <div class="indicator-value">
                            <span>Value:</span>
                            <span class="${indicators.cci > 100 ? 'bearish' : indicators.cci < -100 ? 'bullish' : 'neutral'}">${indicators.cci?.toFixed(2) || 'N/A'}</span>
                        </div>
                    </div>
                `;
            }
            
            generatePredictions() {
                const prices = this.priceData.map(d => d.close);
                const currentPrice = prices[prices.length - 1];
                
                // Advanced prediction algorithms
                const predictions = {
                    next1h: this.predictPrice(prices, 1),
                    next4h: this.predictPrice(prices, 4),
                    next24h: this.predictPrice(prices, 24),
                    nextWeek: this.predictPrice(prices, 168)
                };
                
                // Calculate confidence levels
                const volatility = this.calculateVolatility(prices);
                const trend = this.calculateTrend(prices);
                
                this.renderPredictions(currentPrice, predictions, volatility, trend);
            }
            
            predictPrice(prices, hoursAhead) {
                // Multiple prediction models
                const linearPrediction = this.linearRegression(prices, hoursAhead);
                const movingAveragePrediction = this.movingAveragePrediction(prices, hoursAhead);
                const momentumPrediction = this.momentumPrediction(prices, hoursAhead);
                
                // Weighted ensemble
                const prediction = (linearPrediction * 0.4 + movingAveragePrediction * 0.3 + momentumPrediction * 0.3);
                const confidence = Math.max(0.3, Math.min(0.95, 1 - (Math.abs(prices[prices.length - 1] - prediction) / prices[prices.length - 1])));
                
                return { price: prediction, confidence: confidence };
            }
            
            linearRegression(prices, periods) {
                const n = Math.min(50, prices.length);
                const recentPrices = prices.slice(-n);
                
                let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
                
                for (let i = 0; i < n; i++) {
                    sumX += i;
                    sumY += recentPrices[i];
                    sumXY += i * recentPrices[i];
                    sumXX += i * i;
                }
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                return slope * (n + periods) + intercept;
            }
            
            movingAveragePrediction(prices, periods) {
                const shortMA = this.calculateSMA(prices, 10);
                const longMA = this.calculateSMA(prices, 30);
                
                const trend = shortMA[shortMA.length - 1] - longMA[longMA.length - 1];
                return prices[prices.length - 1] + (trend * periods * 0.1);
            }
            
            momentumPrediction(prices, periods) {
                const momentum = this.calculateMomentum(prices, 14);
                const avgMomentum = momentum.slice(-10).reduce((a, b) => a + b, 0) / 10;
                
                return prices[prices.length - 1] * (1 + avgMomentum * periods * 0.01);
            }
            
            renderPredictions(currentPrice, predictions, volatility, trend) {
                const grid = document.getElementById('predictionsGrid');
                
                const formatChange = (predicted, current) => {
                    const change = ((predicted - current) / current) * 100;
                    const className = change > 0 ? 'bullish' : 'bearish';
                    return `<span class="${className}">${change > 0 ? '+' : ''}${change.toFixed(2)}%</span>`;
                };
                
                const formatConfidence = (confidence) => {
                    const percentage = (confidence * 100).toFixed(0);
                    const className = confidence > 0.7 ? 'bullish' : confidence > 0.5 ? 'neutral' : 'bearish';
                    return `<span class="${className}">${percentage}%</span>`;
                };
                
                grid.innerHTML = `
                    <div class="prediction-card">
                        <h4>Current Price</h4>
                        <div class="price-display">$${currentPrice.toFixed(2)}</div>
                        <div>Trend: <span class="${trend > 0 ? 'bullish' : 'bearish'}">${trend > 0 ? '📈 UP' : '📉 DOWN'}</span></div>
                    </div>
                    
                    <div class="prediction-card">
                        <h4>1 Hour Prediction</h4>
                        <div class="price-display">$${predictions.next1h.price.toFixed(2)}</div>
                        <div class="change-display">${formatChange(predictions.next1h.price, currentPrice)}</div>
                        <div>Confidence: ${formatConfidence(predictions.next1h.confidence)}</div>
                    </div>
                    
                    <div class="prediction-card">
                        <h4>4 Hour Prediction</h4>
                        <div class="price-display">${predictions.next4h.price.toFixed(2)}</div>
                        <div class="change-display">${formatChange(predictions.next4h.price, currentPrice)}</div>
                        <div>Confidence: ${formatConfidence(predictions.next4h.confidence)}</div>
                    </div>
                    
                    <div class="prediction-card">
                        <h4>24 Hour Prediction</h4>
                        <div class="price-display">${predictions.next24h.price.toFixed(2)}</div>
                        <div class="change-display">${formatChange(predictions.next24h.price, currentPrice)}</div>
                        <div>Confidence: ${formatConfidence(predictions.next24h.confidence)}</div>
                    </div>
                    
                    <div class="prediction-card">
                        <h4>1 Week Prediction</h4>
                        <div class="price-display">${predictions.nextWeek.price.toFixed(2)}</div>
                        <div class="change-display">${formatChange(predictions.nextWeek.price, currentPrice)}</div>
                        <div>Confidence: ${formatConfidence(predictions.nextWeek.confidence)}</div>
                    </div>
                    
                    <div class="prediction-card">
                        <h4>Market Analysis</h4>
                        <div>Volatility: <span class="${volatility > 0.05 ? 'bearish' : volatility > 0.03 ? 'neutral' : 'bullish'}">${(volatility * 100).toFixed(1)}%</span></div>
                        <div>Risk Level: <span class="${volatility > 0.05 ? 'bearish' : volatility > 0.03 ? 'neutral' : 'bullish'}">${volatility > 0.05 ? 'HIGH' : volatility > 0.03 ? 'MEDIUM' : 'LOW'}</span></div>
                        <div>Market Mood: <span class="${trend > 0 ? 'bullish' : 'bearish'}">${trend > 0 ? 'OPTIMISTIC' : 'PESSIMISTIC'}</span></div>
                    </div>
                `;
            }
            
            updateAlerts() {
                const prices = this.priceData.map(d => d.close);
                const alerts = [];
                
                // Price-based alerts
                const rsi = this.calculateRSI(prices, 14);
                const currentRSI = rsi[rsi.length - 1];
                
                if (currentRSI > 75) {
                    alerts.push({
                        type: 'warning',
                        message: '⚠️ RSI indicates extreme overbought conditions',
                        action: 'Consider taking profits or setting stop losses'
                    });
                }
                
                if (currentRSI < 25) {
                    alerts.push({
                        type: 'opportunity',
                        message: '🚀 RSI indicates oversold conditions',
                        action: 'Potential buying opportunity detected'
                    });
                }
                
                // Volume alerts
                const volumes = this.priceData.map(d => d.volume);
                const volumeMA = this.calculateSMA(volumes, 20);
                const currentVolumeRatio = volumes[volumes.length - 1] / volumeMA[volumeMA.length - 1];
                
                if (currentVolumeRatio > 2) {
                    alerts.push({
                        type: 'info',
                        message: '📊 Unusual volume spike detected',
                        action: 'Increased market activity - monitor closely'
                    });
                }
                
                // Price momentum alerts
                const momentum = this.calculateMomentum(prices, 10);
                const currentMomentum = momentum[momentum.length - 1];
                
                if (Math.abs(currentMomentum) > 0.05) {
                    alerts.push({
                        type: currentMomentum > 0 ? 'bullish' : 'bearish',
                        message: `${currentMomentum > 0 ? '📈' : '📉'} Strong ${currentMomentum > 0 ? 'upward' : 'downward'} momentum detected`,
                        action: `${currentMomentum > 0 ? 'Trend may continue upward' : 'Consider risk management'}`
                    });
                }
                
                // MACD alerts
                const macd = this.calculateMACD(prices);
                const currentMACD = macd[macd.length - 1];
                const prevMACD = macd[macd.length - 2];
                
                if (currentMACD && prevMACD) {
                    if (currentMACD.macd > currentMACD.signal && prevMACD.macd <= prevMACD.signal) {
                        alerts.push({
                            type: 'bullish',
                            message: '🟢 MACD bullish crossover detected',
                            action: 'Potential uptrend beginning'
                        });
                    } else if (currentMACD.macd < currentMACD.signal && prevMACD.macd >= prevMACD.signal) {
                        alerts.push({
                            type: 'bearish',
                            message: '🔴 MACD bearish crossover detected',
                            action: 'Potential downtrend beginning'
                        });
                    }
                }
                
                this.renderAlerts(alerts);
            }
            
            renderAlerts(alerts) {
                const alertsContainer = document.getElementById('alerts');
                
                if (alerts.length === 0) {
                    alertsContainer.innerHTML = '<div class="loading">No active alerts</div>';
                    return;
                }
                
                alertsContainer.innerHTML = alerts.map(alert => `
                    <div class="alert-panel">
                        <div style="font-weight: bold; margin-bottom: 5px;">${alert.message}</div>
                        <div style="font-size: 12px; opacity: 0.8;">${alert.action}</div>
                    </div>
                `).join('');
            }
            
            setupWebSocket() {
                if (this.wsConnection) {
                    this.wsConnection.close();
                }
                
                const wsUrl = `wss://stream.binance.com:9443/ws/${this.currentSymbol.toLowerCase()}@ticker`;
                this.wsConnection = new WebSocket(wsUrl);
                
                this.wsConnection.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.updateRealTimeData(data);
                };
                
                this.wsConnection.onerror = (error) => {
                    console.log('WebSocket connection error:', error);
                    // Fallback to polling
                    setTimeout(() => this.setupWebSocket(), 5000);
                };
            }
            
            updateRealTimeData(tickerData) {
                // Update current price and basic stats
                const currentPrice = parseFloat(tickerData.c);
                const priceChange = parseFloat(tickerData.P);
                
                // Update price display if exists
                const priceDisplays = document.querySelectorAll('.price-display');
                if (priceDisplays.length > 0) {
                    priceDisplays[0].textContent = `${currentPrice.toFixed(2)}`;
                    priceDisplays[0].className = `price-display ${priceChange >= 0 ? 'bullish' : 'bearish'}`;
                }
            }
            
            startRealTimeUpdates() {
                // Update data every 5 minutes
                setInterval(() => {
                    this.loadInitialData();
                }, 300000);
                
                // Update indicators every minute
                setInterval(() => {
                    if (this.priceData.length > 0) {
                        this.calculateIndicators();
                    }
                }, 60000);
            }
            
            // Technical Analysis Functions
            calculateSMA(data, period) {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                        result.push(sum / period);
                    }
                }
                return result;
            }
            
            calculateEMA(data, period) {
                const result = [];
                const multiplier = 2 / (period + 1);
                
                result[0] = data[0];
                
                for (let i = 1; i < data.length; i++) {
                    result[i] = (data[i] * multiplier) + (result[i - 1] * (1 - multiplier));
                }
                
                return result;
            }
            
            calculateRSI(data, period) {
                const gains = [];
                const losses = [];
                
                for (let i = 1; i < data.length; i++) {
                    const change = data[i] - data[i - 1];
                    gains.push(change > 0 ? change : 0);
                    losses.push(change < 0 ? Math.abs(change) : 0);
                }
                
                const avgGains = this.calculateSMA(gains, period);
                const avgLosses = this.calculateSMA(losses, period);
                
                const rsi = [];
                for (let i = 0; i < avgGains.length; i++) {
                    if (avgGains[i] === null || avgLosses[i] === null) {
                        rsi.push(null);
                    } else {
                        const rs = avgGains[i] / avgLosses[i];
                        rsi.push(100 - (100 / (1 + rs)));
                    }
                }
                
                return rsi;
            }
            
            calculateMACD(data) {
                const ema12 = this.calculateEMA(data, 12);
                const ema26 = this.calculateEMA(data, 26);
                
                const macdLine = [];
                for (let i = 0; i < data.length; i++) {
                    macdLine.push(ema12[i] - ema26[i]);
                }
                
                const signalLine = this.calculateEMA(macdLine, 9);
                const histogram = [];
                
                for (let i = 0; i < macdLine.length; i++) {
                    histogram.push(macdLine[i] - signalLine[i]);
                }
                
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    result.push({
                        macd: macdLine[i],
                        signal: signalLine[i],
                        histogram: histogram[i]
                    });
                }
                
                return result;
            }
            
            calculateBollingerBands(data, period, multiplier) {
                const sma = this.calculateSMA(data, period);
                const result = [];
                
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        result.push({ upper: null, middle: null, lower: null });
                    } else {
                        const slice = data.slice(i - period + 1, i + 1);
                        const mean = sma[i];
                        const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
                        const stdDev = Math.sqrt(variance);
                        
                        result.push({
                            upper: mean + (multiplier * stdDev),
                            middle: mean,
                            lower: mean - (multiplier * stdDev)
                        });
                    }
                }
                
                return result;
            }
            
            calculateStochastic(highs, lows, closes, period) {
                const result = [];
                
                for (let i = 0; i < closes.length; i++) {
                    if (i < period - 1) {
                        result.push({ k: null, d: null });
                    } else {
                        const periodHighs = highs.slice(i - period + 1, i + 1);
                        const periodLows = lows.slice(i - period + 1, i + 1);
                        
                        const highestHigh = Math.max(...periodHighs);
                        const lowestLow = Math.min(...periodLows);
                        
                        const k = ((closes[i] - lowestLow) / (highestHigh - lowestLow)) * 100;
                        result.push({ k: k, d: null });
                    }
                }
                
                // Calculate %D (3-period SMA of %K)
                const kValues = result.map(r => r.k);
                const dValues = this.calculateSMA(kValues, 3);
                
                for (let i = 0; i < result.length; i++) {
                    result[i].d = dValues[i];
                }
                
                return result;
            }
            
            calculateWilliamsR(highs, lows, closes, period) {
                const result = [];
                
                for (let i = 0; i < closes.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                    } else {
                        const periodHighs = highs.slice(i - period + 1, i + 1);
                        const periodLows = lows.slice(i - period + 1, i + 1);
                        
                        const highestHigh = Math.max(...periodHighs);
                        const lowestLow = Math.min(...periodLows);
                        
                        const willR = ((highestHigh - closes[i]) / (highestHigh - lowestLow)) * -100;
                        result.push(willR);
                    }
                }
                
                return result;
            }
            
            calculateMomentum(data, period) {
                const result = [];
                
                for (let i = 0; i < data.length; i++) {
                    if (i < period) {
                        result.push(null);
                    } else {
                        result.push((data[i] - data[i - period]) / data[i - period]);
                    }
                }
                
                return result;
            }
            
            calculateCCI(highs, lows, closes, period) {
                const typicalPrices = [];
                for (let i = 0; i < closes.length; i++) {
                    typicalPrices.push((highs[i] + lows[i] + closes[i]) / 3);
                }
                
                const smaTP = this.calculateSMA(typicalPrices, period);
                const result = [];
                
                for (let i = 0; i < closes.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                    } else {
                        const slice = typicalPrices.slice(i - period + 1, i + 1);
                        const meanDeviation = slice.reduce((sum, val) => sum + Math.abs(val - smaTP[i]), 0) / period;
                        const cci = (typicalPrices[i] - smaTP[i]) / (0.015 * meanDeviation);
                        result.push(cci);
                    }
                }
                
                return result;
            }
            
            calculateATR(highs, lows, closes, period) {
                const trueRanges = [];
                
                for (let i = 1; i < closes.length; i++) {
                    const hl = highs[i] - lows[i];
                    const hc = Math.abs(highs[i] - closes[i - 1]);
                    const lc = Math.abs(lows[i] - closes[i - 1]);
                    
                    trueRanges.push(Math.max(hl, hc, lc));
                }
                
                return this.calculateSMA(trueRanges, period);
            }
            
            calculateVolatility(data) {
                const returns = [];
                for (let i = 1; i < data.length; i++) {
                    returns.push((data[i] - data[i - 1]) / data[i - 1]);
                }
                
                const mean = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
                const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - mean, 2), 0) / returns.length;
                
                return Math.sqrt(variance);
            }
            
            calculateTrend(data) {
                const recentData = data.slice(-20);
                const x = recentData.map((_, i) => i);
                const y = recentData;
                
                const n = x.length;
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
                const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                return slope;
            }
        }
        
        // Initialize the trading assistant when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TradingAssistant();
        });
        
        // Add some additional utility functions for enhanced analysis
        class MarketAnalyzer {
            static detectPatterns(priceData) {
                // Pattern detection algorithms
                const patterns = [];
                
                // Double top/bottom detection
                const peaks = this.findPeaks(priceData);
                const valleys = this.findValleys(priceData);
                
                // Add pattern detection logic here
                return patterns;
            }
            
            static findPeaks(data) {
                const peaks = [];
                for (let i = 1; i < data.length - 1; i++) {
                    if (data[i] > data[i - 1] && data[i] > data[i + 1]) {
                        peaks.push({ index: i, value: data[i] });
                    }
                }
                return peaks;
            }
            
            static findValleys(data) {
                const valleys = [];
                for (let i = 1; i < data.length - 1; i++) {
                    if (data[i] < data[i - 1] && data[i] < data[i + 1]) {
                        valleys.push({ index: i, value: data[i] });
                    }
                }
                return valleys;
            }
            
            static calculateSupportResistance(priceData) {
                const highs = priceData.map(d => d.high);
                const lows = priceData.map(d => d.low);
                
                const resistance = Math.max(...highs.slice(-50));
                const support = Math.min(...lows.slice(-50));
                
                return { support, resistance };
            }
        }
        
        // Advanced mathematical functions for better predictions
        class PredictionEngine {
            static polynomialRegression(x, y, degree) {
                // Implement polynomial regression for better curve fitting
                const n = x.length;
                const matrix = [];
                
                for (let i = 0; i <= degree; i++) {
                    matrix[i] = [];
                    for (let j = 0; j <= degree; j++) {
                        matrix[i][j] = 0;
                        for (let k = 0; k < n; k++) {
                            matrix[i][j] += Math.pow(x[k], i + j);
                        }
                    }
                }
                
                const vector = [];
                for (let i = 0; i <= degree; i++) {
                    vector[i] = 0;
                    for (let k = 0; k < n; k++) {
                        vector[i] += Math.pow(x[k], i) * y[k];
                    }
                }
                
                // Solve the system using Gaussian elimination
                return this.gaussianElimination(matrix, vector);
            }
            
            static gaussianElimination(matrix, vector) {
                const n = matrix.length;
                
                // Forward elimination
                for (let i = 0; i < n; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(matrix[k][i]) > Math.abs(matrix[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    [matrix[maxRow], matrix[i]] = [matrix[i], matrix[maxRow]];
                    [vector[maxRow], vector[i]] = [vector[i], vector[maxRow]];
                    
                    for (let k = i + 1; k < n; k++) {
                        const factor = matrix[k][i] / matrix[i][i];
                        vector[k] -= factor * vector[i];
                        for (let j = i; j < n; j++) {
                            matrix[k][j] -= factor * matrix[i][j];
                        }
                    }
                }
                
                // Back substitution
                const solution = new Array(n);
                for (let i = n - 1; i >= 0; i--) {
                    solution[i] = vector[i];
                    for (let j = i + 1; j < n; j++) {
                        solution[i] -= matrix[i][j] * solution[j];
                    }
                    solution[i] /= matrix[i][i];
                }
                
                return solution;
            }
        }
    </script>
</body>
</html>
