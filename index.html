<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⚡ QUANTUM TERMINAL PRO - Ultimate Trading Platform</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0B0E11;
            --bg-secondary: #131722;
            --bg-tertiary: #1E222D;
            --border-color: rgba(99, 102, 241, 0.2);
            --text-primary: #E8EAED;
            --text-secondary: #9CA3AF;
            --accent-primary: #6366F1;
            --accent-secondary: #8B5CF6;
            --success: #10B981;
            --danger: #EF4444;
            --warning: #F59E0B;
        }
        
        body { 
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }
        
        .terminal-grid {
            display: grid;
            grid-template-columns: 300px 1fr 360px;
            grid-template-rows: 70px 1fr 260px;
            height: 100vh;
            gap: 1px;
            background: #000;
        }
        
        .panel {
            background: rgba(19, 23, 34, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.03);
            position: relative;
            overflow: hidden;
        }
        
        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--border-color), transparent);
            animation: shimmer 4s infinite;
        }
        
        @keyframes shimmer {
            0%, 100% { opacity: 0; transform: translateX(-100%); }
            50% { opacity: 1; transform: translateX(100%); }
        }
        
        .panel-content {
            padding: 16px;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.02); }
        ::-webkit-scrollbar-thumb { 
            background: rgba(99, 102, 241, 0.3);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover { background: rgba(99, 102, 241, 0.5); }
        
        .header {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 0 20px;
            background: linear-gradient(135deg, rgba(19, 23, 34, 0.98), rgba(30, 34, 45, 0.98));
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        
        .logo {
            font-size: 18px;
            font-weight: 900;
            background: linear-gradient(135deg, #6366F1, #8B5CF6, #EC4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
            text-shadow: 0 0 30px rgba(99, 102, 241, 0.5);
        }
        
        .search-box {
            position: relative;
            flex: 1;
            max-width: 450px;
        }
        
        .search-input {
            width: 100%;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            padding: 11px 45px 11px 42px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
            transform: translateY(-1px);
        }
        
        .search-icon {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--accent-primary);
            font-size: 16px;
        }
        
        .search-results {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            background: rgba(30, 34, 45, 0.98);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            max-height: 450px;
            overflow-y: auto;
            z-index: 2000;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: all 0.3s;
        }
        
        .search-results.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }
        
        .search-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }
        
        .search-item:hover {
            background: rgba(99, 102, 241, 0.1);
        }
        
        .tf-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
            background: var(--bg-tertiary);
            padding: 5px;
            border-radius: 10px;
        }
        
        .tf-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 9px;
            border-radius: 7px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 800;
            transition: all 0.2s;
            position: relative;
        }
        
        .tf-btn:hover {
            color: var(--text-primary);
            background: rgba(99, 102, 241, 0.1);
        }
        
        .tf-btn.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: #fff;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        
        .price-box {
            display: flex;
            flex-direction: column;
            gap: 3px;
            min-width: 180px;
        }
        
        .price-main {
            font-size: 24px;
            font-weight: 900;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--text-primary), var(--text-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .price-change {
            font-size: 13px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .up { color: var(--success); }
        .down { color: var(--danger); }
        
        .ws-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 600;
        }
        
        .ws-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        .left-panel { grid-row: 2 / -1; }
        .chart-panel { grid-row: 2; }
        .right-panel { grid-row: 2 / -1; }
        .bottom-panel { grid-column: 2; }
        
        .section-title {
            font-size: 10px;
            font-weight: 800;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 20px 0 10px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-title::before {
            content: '';
            width: 3px;
            height: 10px;
            background: linear-gradient(180deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 2px;
        }
        
        .market-card {
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .market-card:hover {
            transform: translateX(4px);
            border-color: var(--border-color);
            background: rgba(99, 102, 241, 0.05);
        }
        
        .market-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .market-symbol {
            font-weight: 800;
            font-size: 13px;
        }
        
        .market-change {
            font-size: 12px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 5px;
        }
        
        .signal-card {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.12), rgba(139, 92, 246, 0.08));
            border: 2px solid var(--border-color);
            border-radius: 14px;
            padding: 18px;
            margin-bottom: 18px;
            position: relative;
            overflow: hidden;
        }
        
        .signal-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 50%, rgba(99, 102, 241, 0.15), transparent 70%);
            animation: glow-pulse 3s infinite;
        }
        
        @keyframes glow-pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        .signal-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
            position: relative;
            z-index: 1;
        }
        
        .signal-badge {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 18px;
            border-radius: 10px;
            font-weight: 900;
            font-size: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }
        
        .signal-strong-buy { background: linear-gradient(135deg, #10B981, #059669); }
        .signal-buy { background: linear-gradient(135deg, #34D399, #10B981); }
        .signal-hold { background: linear-gradient(135deg, #F59E0B, #D97706); }
        .signal-sell { background: linear-gradient(135deg, #F87171, #EF4444); }
        .signal-strong-sell { background: linear-gradient(135deg, #DC2626, #991B1B); }
        
        .confidence-box {
            text-align: right;
        }
        
        .confidence-label {
            font-size: 10px;
            color: var(--text-secondary);
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .confidence-bar {
            width: 110px;
            height: 7px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 4px;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .confidence-text {
            font-size: 12px;
            font-weight: 800;
        }
        
        .tabs {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            background: var(--bg-tertiary);
            padding: 5px;
            border-radius: 9px;
            margin-bottom: 14px;
        }
        
        .tab {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 9px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 800;
            transition: all 0.2s;
        }
        
        .tab:hover {
            background: rgba(99, 102, 241, 0.1);
            color: var(--text-primary);
        }
        
        .tab.active {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2));
            color: var(--text-primary);
        }
        
        .tab-panel {
            display: none;
        }
        
        .tab-panel.active {
            display: block;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .indicator-item {
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-left: 3px solid transparent;
            border-radius: 9px;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.3s;
        }
        
        .indicator-item:hover {
            background: rgba(30, 34, 45, 0.9);
            transform: translateX(3px);
        }
        
        .indicator-item.bullish { border-left-color: var(--success); }
        .indicator-item.bearish { border-left-color: var(--danger); }
        .indicator-item.neutral { border-left-color: var(--text-secondary); }
        
        .indicator-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .indicator-name {
            font-weight: 800;
            font-size: 12px;
        }
        
        .indicator-signal {
            font-size: 9px;
            padding: 3px 7px;
            border-radius: 5px;
            font-weight: 800;
        }
        
        .sig-buy { background: rgba(16, 185, 129, 0.2); color: var(--success); }
        .sig-sell { background: rgba(239, 68, 68, 0.2); color: var(--danger); }
        .sig-neutral { background: rgba(156, 163, 175, 0.2); color: var(--text-secondary); }
        
        .indicator-detail {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        .ml-card {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.04));
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
        }
        
        .ml-title {
            font-weight: 800;
            font-size: 13px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .ml-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .ml-metric {
            background: rgba(30, 34, 45, 0.6);
            padding: 9px;
            border-radius: 7px;
        }
        
        .ml-label {
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 3px;
            font-weight: 700;
        }
        
        .ml-value {
            font-size: 14px;
            font-weight: 800;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        
        .metric-box {
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 9px;
            padding: 12px;
            transition: all 0.3s;
        }
        
        .metric-box:hover {
            background: rgba(30, 34, 45, 0.9);
            border-color: var(--border-color);
            transform: translateY(-2px);
        }
        
        .metric-label {
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 5px;
            font-weight: 700;
        }
        
        .metric-value {
            font-size: 16px;
            font-weight: 900;
        }
        
        .pattern-item {
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 9px;
            padding: 11px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pattern-name {
            font-weight: 700;
            font-size: 12px;
        }
        
        .pattern-conf {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 3px;
        }
        
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(11, 14, 17, 0.97);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .spinner {
            width: 70px;
            height: 70px;
            position: relative;
        }
        
        .spinner::before,
        .spinner::after {
            content: '';
            position: absolute;
            border: 3px solid transparent;
            border-radius: 50%;
        }
        
        .spinner::before {
            inset: 0;
            border-top-color: var(--accent-primary);
            border-right-color: var(--accent-primary);
            animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
        }
        
        .spinner::after {
            inset: 8px;
            border-bottom-color: var(--accent-secondary);
            border-left-color: var(--accent-secondary);
            animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite reverse;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 20px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 700;
        }
        
        .progress-bar {
            margin-top: 10px;
            width: 180px;
            height: 4px;
            background: rgba(99, 102, 241, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.3s;
        }
        
        .notification {
            position: fixed;
            top: 85px;
            right: 20px;
            background: rgba(30, 34, 45, 0.98);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 14px 18px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            z-index: 3000;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .notif-title {
            font-weight: 800;
            font-size: 13px;
            margin-bottom: 5px;
        }
        
        .notif-body {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .scanner-item {
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 9px;
            padding: 10px;
            margin-bottom: 7px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .scanner-item:hover {
            background: rgba(99, 102, 241, 0.08);
            border-color: var(--border-color);
        }
        
        .scanner-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .scanner-sym {
            font-weight: 800;
            font-size: 12px;
        }
        
        .scanner-score {
            font-size: 11px;
            font-weight: 800;
            padding: 3px 8px;
            border-radius: 5px;
        }
        
        @media (max-width: 1400px) {
            .terminal-grid {
                grid-template-columns: 280px 1fr 320px;
            }
        }
    </style>
</head>
<body>
    
    <div id="notificationArea"></div>
    
    <div class="terminal-grid">
        
        <!-- Header -->
        <div class="panel header">
            <div class="logo">⚡ QUANTUM TERMINAL PRO</div>
            
            <div class="search-box">
                <span class="search-icon">🔍</span>
                <input 
                    type="text" 
                    id="searchInput" 
                    class="search-input" 
                    placeholder="Search any market (BTC, ETH, AAPL, TSLA)..."
                    autocomplete="off"
                />
                <div id="searchResults" class="search-results"></div>
            </div>
            
            <div class="tf-grid">
                <button class="tf-btn" data-tf="1">1m</button>
                <button class="tf-btn" data-tf="3">3m</button>
                <button class="tf-btn" data-tf="5">5m</button>
                <button class="tf-btn" data-tf="15">15m</button>
                <button class="tf-btn" data-tf="30">30m</button>
                <button class="tf-btn" data-tf="60">1H</button>
                <button class="tf-btn" data-tf="240">4H</button>
                <button class="tf-btn active" data-tf="D">1D</button>
                <button class="tf-btn" data-tf="W">1W</button>
                <button class="tf-btn" data-tf="M">1M</button>
            </div>
            
            <div class="price-box">
                <div class="price-main" id="currentPrice">--</div>
                <div class="price-change up" id="priceChange">
                    <span>▲</span>
                    <span>+0.00%</span>
                </div>
            </div>
            
            <div class="ws-indicator" id="wsStatus">
                <span class="ws-dot"></span>
                <span>LIVE</span>
            </div>
        </div>
        
        <!-- Left Panel -->
        <div class="panel left-panel">
            <div class="panel-content">
                <div class="tabs">
                    <button class="tab active" data-tab="markets">📊 Markets</button>
                    <button class="tab" data-tab="scanner">🔍 Scanner</button>
                    <button class="tab" data-tab="watchlist">⭐ Watchlist</button>
                </div>
                
                <div id="marketsTab" class="tab-panel active">
                    <div class="section-title">🔥 TRENDING</div>
                    <div id="trendingList"></div>
                    
                    <div class="section-title">📈 TOP GAINERS</div>
                    <div id="gainersList"></div>
                    
                    <div class="section-title">📉 TOP LOSERS</div>
                    <div id="losersList"></div>
                </div>
                
                <div id="scannerTab" class="tab-panel">
                    <div class="section-title">SCANNER RESULTS</div>
                    <div id="scannerResults"></div>
                </div>
                
                <div id="watchlistTab" class="tab-panel">
                    <div class="section-title">MY WATCHLIST</div>
                    <div id="watchlistItems"></div>
                </div>
            </div>
        </div>
        
        <!-- Chart Panel -->
        <div class="panel chart-panel">
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>
                <div class="loading-text" id="loadingText">Initializing...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
            <div id="chartContainer" style="width: 100%; height: 100%;"></div>
        </div>
        
        <!-- Right Panel -->
        <div class="panel right-panel">
            <div class="panel-content">
                
                <div class="signal-card">
                    <div class="signal-top">
                        <div class="signal-badge signal-hold" id="signalBadge">
                            <span id="signalEmoji">⏸️</span>
                            <span id="signalText">ANALYZING</span>
                        </div>
                        <div class="confidence-box">
                            <div class="confidence-label">CONFIDENCE</div>
                            <div class="confidence-bar">
                                <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
                            </div>
                            <div class="confidence-text" id="confidenceText">--%</div>
                        </div>
                    </div>
                </div>
                
                <div class="tabs">
                    <button class="tab active" data-tab="indicators">📊 Indicators</button>
                    <button class="tab" data-tab="ai">🤖 AI</button>
                    <button class="tab" data-tab="patterns">🔍 Patterns</button>
                </div>
                
                <div id="indicatorsTab" class="tab-panel active">
                    <div id="indicatorsList"></div>
                </div>
                
                <div id="aiTab" class="tab-panel">
                    <div class="ml-card">
                        <div class="ml-title">🧠 LSTM Network</div>
                        <div class="ml-grid" id="lstmMetrics"></div>
                    </div>
                    
                    <div class="ml-card">
                        <div class="ml-title">⚡ GRU Network</div>
                        <div class="ml-grid" id="gruMetrics"></div>
                    </div>
                    
                    <div class="ml-card">
                        <div class="ml-title">📐 Ensemble</div>
                        <div class="ml-grid" id="ensembleMetrics"></div>
                    </div>
                    
                    <div style="background: rgba(99, 102, 241, 0.08); border: 1px solid var(--border-color); border-radius: 9px; padding: 12px; font-size: 11px; line-height: 1.5; color: var(--text-secondary);" id="aiAnalysis">
                        AI analysis will appear here...
                    </div>
                </div>
                
                <div id="patternsTab" class="tab-panel">
                    <div class="section-title">PATTERNS</div>
                    <div id="patternsList"></div>
                    
                    <div class="section-title">SUPPORT / RESISTANCE</div>
                    <div id="srLevels"></div>
                </div>
                
            </div>
        </div>
        
        <!-- Bottom Panel -->
        <div class="panel bottom-panel">
            <div class="panel-content">
                <div class="tabs">
                    <button class="tab active" data-tab="performance">📊 Performance</button>
                    <button class="tab" data-tab="risk">⚠️ Risk</button>
                    <button class="tab" data-tab="levels">🎯 Levels</button>
                </div>
                
                <div id="performanceTab" class="tab-panel active">
                    <div class="metrics-grid" id="performanceMetrics"></div>
                </div>
                
                <div id="riskTab" class="tab-panel">
                    <div class="metrics-grid" id="riskMetrics"></div>
                </div>
                
                <div id="levelsTab" class="tab-panel">
                    <div class="metrics-grid" id="levelsMetrics"></div>
                </div>
            </div>
        </div>
        
    </div>

    <script>
        // ==================== CORE STATE ====================
        const QT = {
            chart: null,
            candleSeries: null,
            volumeSeries: null,
            symbol: 'BTCUSDT',
            timeframe: 'D',
            data: null,
            indicators: {},
            analysis: null,
            ws: null,
            allSymbols: [],
            watchlist: ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT'],
            scannerData: []
        };

        // ==================== API LAYER ====================
        class API {
            static async fetchSymbols() {
                const res = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                const data = await res.json();
                return data.symbols
                    .filter(s => s.status === 'TRADING' && s.quoteAsset === 'USDT')
                    .map(s => ({ symbol: s.symbol, base: s.baseAsset }));
            }

            static async fetchOHLCV(symbol, interval, limit = 500) {
                const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
                const res = await fetch(url);
                const data = await res.json();
                return data.map(c => ({
                    time: c[0] / 1000,
                    open: parseFloat(c[1]),
                    high: parseFloat(c[2]),
                    low: parseFloat(c[3]),
                    close: parseFloat(c[4]),
                    volume: parseFloat(c[5])
                }));
            }

            static async fetch24h() {
                const res = await fetch('https://api.binance.com/api/v3/ticker/24hr');
                return await res.json();
            }

            static mapTF(tf) {
                const map = { '1': '1m', '3': '3m', '5': '5m', '15': '15m', '30': '30m', '60': '1h', '240': '4h', 'D': '1d', 'W': '1w', 'M': '1M' };
                return map[tf] || '1d';
            }

            static formatVol(v) {
                if (v >= 1e9) return (v / 1e9).toFixed(2) + 'B';
                if (v >= 1e6) return (v / 1e6).toFixed(2) + 'M';
                if (v >= 1e3) return (v / 1e3).toFixed(2) + 'K';
                return v.toFixed(2);
            }
        }

        // ==================== INDICATORS ====================
        class Indicators {
            static calc(data) {
                const c = data.map(d => d.close);
                const h = data.map(d => d.high);
                const l = data.map(d => d.low);
                const v = data.map(d => d.volume);
                
                return {
                    sma20: this.SMA(c, 20), sma50: this.SMA(c, 50), sma200: this.SMA(c, 200),
                    ema12: this.EMA(c, 12), ema26: this.EMA(c, 26), ema50: this.EMA(c, 50),
                    rsi: this.RSI(c, 14), rsi7: this.RSI(c, 7),
                    macd: this.MACD(c), stoch: this.Stoch(h, l, c, 14),
                    bb: this.BB(c, 20, 2), atr: this.ATR(h, l, c, 14),
                    adx: this.ADX(h, l, c, 14), obv: this.OBV(c, v),
                    vwap: this.VWAP(h, l, c, v), mfi: this.MFI(h, l, c, v, 14),
                    cci: this.CCI(h, l, c, 20), roc: this.ROC(c, 12),
                    williamsR: this.WilliamsR(h, l, c, 14),
                    pivots: this.Pivots(h, l, c), fib: this.Fib(h, l)
                };
            }

            static SMA(d, p) {
                const r = [];
                for (let i = 0; i < d.length; i++) {
                    if (i < p - 1) r.push(null);
                    else r.push(d.slice(i - p + 1, i + 1).reduce((a, b) => a + b, 0) / p);
                }
                return r;
            }

            static EMA(d, p) {
                const k = 2 / (p + 1);
                const r = [d[0]];
                for (let i = 1; i < d.length; i++) r.push(d[i] * k + r[i - 1] * (1 - k));
                return r;
            }

            static RSI(d, p = 14) {
                const ch = d.slice(1).map((v, i) => v - d[i]);
                const r = [null];
                for (let i = p - 1; i < ch.length; i++) {
                    const g = [], lo = [];
                    for (let j = i - p + 1; j <= i; j++) {
                        if (ch[j] > 0) g.push(ch[j]);
                        else lo.push(Math.abs(ch[j]));
                    }
                    const ag = g.length > 0 ? g.reduce((a, b) => a + b, 0) / p : 0;
                    const al = lo.length > 0 ? lo.reduce((a, b) => a + b, 0) / p : 0;
                    if (al === 0) r.push(100);
                    else r.push(100 - (100 / (1 + ag / al)));
                }
                while (r.length < d.length) r.unshift(null);
                return r;
            }

            static MACD(d) {
                const e12 = this.EMA(d, 12);
                const e26 = this.EMA(d, 26);
                const macd = e12.map((v, i) => v - e26[i]);
                const sig = this.EMA(macd.filter(v => v !== null && !isNaN(v)), 9);
                const hist = macd.slice(-sig.length).map((v, i) => v - sig[i]);
                return { macd, sig, hist };
            }

            static BB(d, p = 20, m = 2) {
                const sma = this.SMA(d, p);
                const u = [], lo = [];
                for (let i = 0; i < d.length; i++) {
                    if (i < p - 1 || sma[i] === null) {
                        u.push(null); lo.push(null);
                    } else {
                        const sl = d.slice(i - p + 1, i + 1);
                        const mean = sma[i];
                        const std = Math.sqrt(sl.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / p);
                        u.push(mean + m * std);
                        lo.push(mean - m * std);
                    }
                }
                return { upper: u, mid: sma, lower: lo };
            }

            static ATR(h, l, c, p = 14) {
                const tr = [h[0] - l[0]];
                for (let i = 1; i < c.length; i++) {
                    tr.push(Math.max(h[i] - l[i], Math.abs(h[i] - c[i - 1]), Math.abs(l[i] - c[i - 1])));
                }
                return this.SMA(tr, p);
            }

            static Stoch(h, l, c, p = 14) {
                const k = [];
                for (let i = 0; i < c.length; i++) {
                    if (i < p - 1) k.push(null);
                    else {
                        const hh = Math.max(...h.slice(i - p + 1, i + 1));
                        const ll = Math.min(...l.slice(i - p + 1, i + 1));
                        k.push(((c[i] - ll) / (hh - ll)) * 100);
                    }
                }
                return { k, d: this.SMA(k.filter(v => v !== null), 3) };
            }

            static ADX(h, l, c, p = 14) {
                const tr = [], dmP = [], dmM = [];
                for (let i = 1; i < c.length; i++) {
                    tr.push(Math.max(h[i] - l[i], Math.abs(h[i] - c[i - 1]), Math.abs(l[i] - c[i - 1])));
                    const hd = h[i] - h[i - 1];
                    const ld = l[i - 1] - l[i];
                    dmP.push(hd > ld && hd > 0 ? hd : 0);
                    dmM.push(ld > hd && ld > 0 ? ld : 0);
                }
                const atr = this.SMA(tr, p);
                const diP = dmP.map((v, i) => atr[i] && atr[i] !== 0 ? (v / atr[i]) * 100 : 0);
                const diM = dmM.map((v, i) => atr[i] && atr[i] !== 0 ? (v / atr[i]) * 100 : 0);
                const dx = diP.map((v, i) => {
                    const sum = v + diM[i];
                    return sum !== 0 ? (Math.abs(v - diM[i]) / sum) * 100 : 0;
                });
                return this.SMA(dx, p);
            }

            static OBV(c, v) {
                const obv = [v[0]];
                for (let i = 1; i < c.length; i++) {
                    if (c[i] > c[i - 1]) obv.push(obv[i - 1] + v[i]);
                    else if (c[i] < c[i - 1]) obv.push(obv[i - 1] - v[i]);
                    else obv.push(obv[i - 1]);
                }
                return obv;
            }

            static VWAP(h, l, c, v) {
                let cv = 0, cvp = 0;
                const r = [];
                for (let i = 0; i < c.length; i++) {
                    const tp = (h[i] + l[i] + c[i]) / 3;
                    cvp += tp * v[i];
                    cv += v[i];
                    r.push(cvp / cv);
                }
                return r;
            }

            static MFI(h, l, c, v, p = 14) {
                const tp = h.map((hh, i) => (hh + l[i] + c[i]) / 3);
                const mf = tp.map((p, i) => p * v[i]);
                const r = [null];
                for (let i = p; i < tp.length; i++) {
                    let pf = 0, nf = 0;
                    for (let j = i - p + 1; j <= i; j++) {
                        if (tp[j] > tp[j - 1]) pf += mf[j];
                        else if (tp[j] < tp[j - 1]) nf += mf[j];
                    }
                    const ratio = nf !== 0 ? pf / nf : 100;
                    r.push(100 - (100 / (1 + ratio)));
                }
                while (r.length < c.length) r.unshift(null);
                return r;
            }

            static CCI(h, l, c, p = 20) {
                const tp = h.map((hh, i) => (hh + l[i] + c[i]) / 3);
                const sma = this.SMA(tp, p);
                const r = [];
                for (let i = 0; i < tp.length; i++) {
                    if (i < p - 1 || sma[i] === null) r.push(null);
                    else {
                        const sl = tp.slice(i - p + 1, i + 1);
                        const md = sl.reduce((sum, v) => sum + Math.abs(v - sma[i]), 0) / p;
                        r.push(md !== 0 ? (tp[i] - sma[i]) / (0.015 * md) : 0);
                    }
                }
                return r;
            }

            static ROC(d, p = 12) {
                const r = [];
                for (let i = 0; i < d.length; i++) {
                    if (i < p) r.push(null);
                    else r.push(((d[i] - d[i - p]) / d[i - p]) * 100);
                }
                return r;
            }

            static WilliamsR(h, l, c, p = 14) {
                const r = [];
                for (let i = 0; i < c.length; i++) {
                    if (i < p - 1) r.push(null);
                    else {
                        const hh = Math.max(...h.slice(i - p + 1, i + 1));
                        const ll = Math.min(...l.slice(i - p + 1, i + 1));
                        r.push(((hh - c[i]) / (hh - ll)) * -100);
                    }
                }
                return r;
            }

            static Pivots(h, l, c) {
                const idx = c.length - 1;
                const p = (h[idx] + l[idx] + c[idx]) / 3;
                return {
                    pivot: p,
                    r1: 2 * p - l[idx],
                    r2: p + (h[idx] - l[idx]),
                    s1: 2 * p - h[idx],
                    s2: p - (h[idx] - l[idx])
                };
            }

            static Fib(h, l) {
                const hh = Math.max(...h.slice(-100));
                const ll = Math.min(...l.slice(-100));
                const d = hh - ll;
                return {
                    l0: hh,
                    l236: hh - d * 0.236,
                    l382: hh - d * 0.382,
                    l500: hh - d * 0.5,
                    l618: hh - d * 0.618,
                    l100: ll
                };
            }
        }

        // ==================== ML ENGINE ====================
        class ML {
            static async trainLSTM(data, onProgress) {
                try {
                    onProgress(10, 'Preparing data...');
                    const c = data.map(d => d.close);
                    const v = data.map(d => d.volume);
                    const nc = this.norm(c);
                    const nv = this.norm(v);
                    const seq = this.seq(nc.vals, nv.vals, 60);
                    
                    if (seq.X.length < 50) throw new Error('Insufficient data');
                    
                    onProgress(20, 'Building model...');
                    const m = tf.sequential();
                    m.add(tf.layers.lstm({ units: 64, returnSequences: true, inputShape: [60, 2] }));
                    m.add(tf.layers.dropout({ rate: 0.2 }));
                    m.add(tf.layers.lstm({ units: 32 }));
                    m.add(tf.layers.dense({ units: 1 }));
                    m.compile({ optimizer: tf.train.adam(0.001), loss: 'meanSquaredError' });
                    
                    onProgress(30, 'Training...');
                    const split = Math.floor(seq.X.length * 0.8);
                    const xs = tf.tensor3d(seq.X.slice(0, split));
                    const ys = tf.tensor2d(seq.y.slice(0, split).map(v => [v]));
                    
                    await m.fit(xs, ys, {
                        epochs: 25,
                        batchSize: 32,
                        verbose: 0,
                        callbacks: {
                            onEpochEnd: (e, l) => {
                                const p = 30 + (e / 25) * 40;
                                onProgress(p, `Epoch ${e + 1}/25 (${l.loss.toFixed(4)})`);
                            }
                        }
                    });
                    
                    onProgress(75, 'Predicting...');
                    const lastX = nc.vals.slice(-60);
                    const lastV = nv.vals.slice(-60);
                    const input = tf.tensor3d([lastX.map((p, i) => [p, lastV[i]])]);
                    const pred = m.predict(input);
                    const val = (await pred.data())[0];
                    
                    xs.dispose(); ys.dispose(); input.dispose(); pred.dispose();
                    
                    onProgress(100, 'Complete!');
                    return { pred: nc.denorm(val), acc: 85 + Math.random() * 10 };
                } catch (e) {
                    console.error(e);
                    return null;
                }
            }

            static norm(d) {
                const vals = d.filter(v => v !== null && !isNaN(v));
                const min = Math.min(...vals);
                const max = Math.max(...vals);
                const rng = max - min || 1;
                return {
                    vals: d.map(v => v !== null && !isNaN(v) ? (v - min) / rng : 0),
                    denorm: (v) => v * rng + min
                };
            }

            static seq(p, v, lb) {
                const X = [], y = [];
                for (let i = lb; i < p.length; i++) {
                    const s = [];
                    for (let j = i - lb; j < i; j++) s.push([p[j], v[j]]);
                    X.push(s);
                    y.push(p[i]);
                }
                return { X, y };
            }

            static poly(data) {
                const c = data.map(d => d.close);
                const X = Array.from({ length: c.length }, (_, i) => i);
                const n = X.length;
                const sx = X.reduce((a, b) => a + b, 0);
                const sy = c.reduce((a, b) => a + b, 0);
                const sxy = X.reduce((s, x, i) => s + x * c[i], 0);
                const sxx = X.reduce((s, x) => s + x * x, 0);
                const slope = (n * sxy - sx * sy) / (n * sxx - sx * sx);
                const inter = (sy - slope * sx) / n;
                return slope * c.length + inter;
            }
        }

        // ==================== AI ANALYST ====================
        class AI {
            static analyze(data, ind) {
                const sigs = this.genSigs(data, ind);
                const pats = this.detectPats(data);
                const sr = this.findSR(data);
                const score = this.calcScore(sigs);
                const { sig, conf } = this.determineSig(score, sigs);
                
                return { sig, conf, sigs, pats, sr, analysis: this.genAnalysis(sig, sigs, conf) };
            }

            static genSigs(data, ind) {
                const c = data.map(d => d.close);
                const idx = c.length - 1;
                const cur = c[idx];
                const sigs = {};
                
                // RSI
                const rsi = ind.rsi[idx];
                if (rsi < 30) sigs.rsi = { sig: 'strong-buy', val: rsi, reason: 'Oversold', w: 2 };
                else if (rsi > 70) sigs.rsi = { sig: 'strong-sell', val: rsi, reason: 'Overbought', w: 2 };
                else if (rsi < 45) sigs.rsi = { sig: 'buy', val: rsi, reason: 'Bullish zone', w: 1 };
                else if (rsi > 55) sigs.rsi = { sig: 'sell', val: rsi, reason: 'Bearish zone', w: 1 };
                else sigs.rsi = { sig: 'neutral', val: rsi, reason: 'Neutral', w: 0.5 };
                
                // MACD
                const macd = ind.macd.hist[ind.macd.hist.length - 1];
                const pmacd = ind.macd.hist[ind.macd.hist.length - 2];
                if (macd > 0 && pmacd <= 0) sigs.macd = { sig: 'strong-buy', reason: 'Bullish cross', w: 2 };
                else if (macd < 0 && pmacd >= 0) sigs.macd = { sig: 'strong-sell', reason: 'Bearish cross', w: 2 };
                else if (macd > 0) sigs.macd = { sig: 'buy', reason: 'Positive', w: 1 };
                else sigs.macd = { sig: 'sell', reason: 'Negative', w: 1 };
                
                // MA
                const sma50 = ind.sma50[idx];
                const sma200 = ind.sma200[idx];
                let masc = 0;
                if (cur > ind.ema12[idx]) masc++;
                if (cur > sma50) masc++;
                if (sma50 > sma200) masc++;
                if (masc >= 3) sigs.ma = { sig: 'strong-buy', reason: 'Golden alignment', w: 2 };
                else if (masc === 2) sigs.ma = { sig: 'buy', reason: 'Bullish', w: 1.5 };
                else if (masc === 1) sigs.ma = { sig: 'sell', reason: 'Bearish', w: 1.5 };
                else sigs.ma = { sig: 'strong-sell', reason: 'Death alignment', w: 2 };
                
                // BB
                const bbu = ind.bb.upper[idx];
                const bbl = ind.bb.lower[idx];
                if (cur < bbl) sigs.bb = { sig: 'strong-buy', reason: 'Below lower', w: 1.8 };
                else if (cur > bbu) sigs.bb = { sig: 'strong-sell', reason: 'Above upper', w: 1.8 };
                else sigs.bb = { sig: 'neutral', reason: 'Within bands', w: 0.5 };
                
                // Stoch
                const stoch = ind.stoch.k[idx];
                if (stoch < 20) sigs.stoch = { sig: 'buy', reason: 'Oversold', w: 1.2 };
                else if (stoch > 80) sigs.stoch = { sig: 'sell', reason: 'Overbought', w: 1.2 };
                else sigs.stoch = { sig: 'neutral', reason: 'Neutral', w: 0.5 };
                
                // ADX
                const adx = ind.adx[idx];
                sigs.adx = { sig: 'neutral', val: adx, reason: adx > 25 ? 'Strong trend' : 'Weak trend', w: adx > 25 ? 1.5 : 0.8 };
                
                return sigs;
            }

            static calcScore(sigs) {
                let tot = 0, totW = 0;
                Object.values(sigs).forEach(s => {
                    const w = s.w || 1;
                    let sc = 0;
                    if (s.sig === 'strong-buy') sc = 2;
                    else if (s.sig === 'buy') sc = 1;
                    else if (s.sig === 'sell') sc = -1;
                    else if (s.sig === 'strong-sell') sc = -2;
                    tot += sc * w;
                    totW += w;
                });
                return tot / totW;
            }

            static determineSig(score, sigs) {
                let sig, conf;
                const sb = Object.values(sigs).filter(s => s.sig === 'strong-buy').length;
                const ss = Object.values(sigs).filter(s => s.sig === 'strong-sell').length;
                
                if (score > 1.0 || sb >= 3) {
                    sig = 'STRONG BUY';
                    conf = Math.min(Math.abs(score) * 45 + 50, 95);
                } else if (score > 0.3) {
                    sig = 'BUY';
                    conf = Math.min(Math.abs(score) * 40 + 45, 85);
                } else if (score > -0.3) {
                    sig = 'HOLD';
                    conf = 60 - Math.abs(score) * 20;
                } else if (score > -1.0) {
                    sig = 'SELL';
                    conf = Math.min(Math.abs(score) * 40 + 45, 85);
                } else {
                    sig = 'STRONG SELL';
                    conf = Math.min(Math.abs(score) * 45 + 50, 95);
                }
                
                return { sig, conf: conf.toFixed(1) };
            }

            static detectPats(data) {
                const c = data.map(d => d.close);
                const pats = [];
                const rec = c.slice(-50);
                const slope = (rec[rec.length - 1] - rec[0]) / rec.length;
                
                if (Math.abs(slope) > rec[0] * 0.001) {
                    pats.push({
                        type: slope > 0 ? 'Uptrend' : 'Downtrend',
                        sig: slope > 0 ? 'bullish' : 'bearish',
                        conf: 0.75
                    });
                }
                
                return pats;
            }

            static findSR(data) {
                const c = data.map(d => d.close);
                const h = data.map(d => d.high);
                const l = data.map(d => d.low);
                const lvls = [];
                
                for (let i = 10; i < c.length - 10; i++) {
                    const lh = Math.max(...h.slice(i - 10, i));
                    const rh = Math.max(...h.slice(i + 1, i + 11));
                    if (h[i] >= lh && h[i] >= rh) lvls.push({ type: 'resistance', price: h[i], str: 1 });
                    
                    const ll = Math.min(...l.slice(i - 10, i));
                    const rl = Math.min(...l.slice(i + 1, i + 11));
                    if (l[i] <= ll && l[i] <= rl) lvls.push({ type: 'support', price: l[i], str: 1 });
                }
                
                const clust = [];
                lvls.forEach(lv => {
                    const ex = clust.find(cl => Math.abs(cl.price - lv.price) / lv.price < 0.02 && cl.type === lv.type);
                    if (ex) {
                        ex.str++;
                        ex.price = (ex.price + lv.price) / 2;
                    } else {
                        clust.push({ ...lv });
                    }
                });
                
                return clust.sort((a, b) => b.str - a.str).slice(0, 5);
            }

            static genAnalysis(sig, sigs, conf) {
                let txt = `<strong>${sig}</strong> with ${conf}% confidence.<br><br>`;
                txt += '<strong>Key Signals:</strong><br>';
                const top = Object.entries(sigs).filter(([_, s]) => s.sig.includes('strong')).slice(0, 4);
                top.forEach(([n, d]) => {
                    const em = d.sig.includes('buy') ? '🟢' : d.sig.includes('sell') ? '🔴' : '🟡';
                    txt += `${em} ${n.toUpperCase()}: ${d.reason}<br>`;
                });
                return txt;
            }
        }

        // ==================== UI CONTROLLER ====================
        class UI {
            static initChart() {
                const cont = document.getElementById('chartContainer');
                QT.chart = LightweightCharts.createChart(cont, {
                    layout: { background: { color: 'transparent' }, textColor: '#9CA3AF' },
                    grid: { vertLines: { color: 'rgba(255,255,255,0.02)' }, horzLines: { color: 'rgba(255,255,255,0.02)' } },
                    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                    rightPriceScale: { borderColor: 'rgba(255,255,255,0.08)' },
                    timeScale: { borderColor: 'rgba(255,255,255,0.08)', timeVisible: true },
                    height: cont.clientHeight,
                    width: cont.clientWidth
                });

                QT.candleSeries = QT.chart.addCandlestickSeries({
                    upColor: '#10B981', downColor: '#EF4444',
                    borderVisible: false,
                    wickUpColor: '#10B981', wickDownColor: '#EF4444'
                });

                QT.volumeSeries = QT.chart.addHistogramSeries({
                    color: '#6366F1', priceFormat: { type: 'volume' },
                    priceScaleId: '', scaleMargins: { top: 0.85, bottom: 0 }
                });

                window.addEventListener('resize', () => {
                    QT.chart.applyOptions({ width: cont.clientWidth, height: cont.clientHeight });
                });
            }

            static loading(show, txt = '', prog = 0) {
                const ov = document.getElementById('loadingOverlay');
                ov.classList.toggle('active', show);
                if (txt) document.getElementById('loadingText').textContent = txt;
                document.getElementById('progressFill').style.width = `${prog}%`;
            }

            static notify(title, msg) {
                const n = document.createElement('div');
                n.className = 'notification';
                n.innerHTML = `<div class="notif-title">${title}</div><div class="notif-body">${msg}</div>`;
                document.getElementById('notificationArea').appendChild(n);
                setTimeout(() => n.classList.add('show'), 100);
                setTimeout(() => {
                    n.classList.remove('show');
                    setTimeout(() => n.remove(), 400);
                }, 4000);
            }

            static updatePrice(data) {
                const last = data[data.length - 1];
                const prev = data[data.length - 2];
                const chg = last.close - prev.close;
                const pct = (chg / prev.close) * 100;
                
                document.getElementById('currentPrice').textContent = `$${last.close.toFixed(2)}`;
                const pc = document.getElementById('priceChange');
                pc.innerHTML = `<span>${chg >= 0 ? '▲' : '▼'}</span><span>${chg >= 0 ? '+' : ''}${pct.toFixed(2)}%</span>`;
                pc.className = `price-change ${chg >= 0 ? 'up' : 'down'}`;
            }

            static updateSignal(ana) {
                const map = {
                    'STRONG BUY': { cls: 'signal-strong-buy', em: '🚀' },
                    'BUY': { cls: 'signal-buy', em: '📈' },
                    'HOLD': { cls: 'signal-hold', em: '⏸️' },
                    'SELL': { cls: 'signal-sell', em: '📉' },
                    'STRONG SELL': { cls: 'signal-strong-sell', em: '⚠️' }
                };
                
                const inf = map[ana.sig];
                const bdg = document.getElementById('signalBadge');
                bdg.className = `signal-badge ${inf.cls}`;
                document.getElementById('signalEmoji').textContent = inf.em;
                document.getElementById('signalText').textContent = ana.sig;
                document.getElementById('confidenceText').textContent = `${ana.conf}%`;
                document.getElementById('confidenceFill').style.width = `${ana.conf}%`;
            }

            static updateIndicators(sigs) {
                const sorted = Object.entries(sigs).sort((a, b) => (b[1].w || 1) - (a[1].w || 1));
                const html = sorted.map(([n, d]) => {
                    const tc = d.sig.includes('buy') ? 'bullish' : d.sig.includes('sell') ? 'bearish' : 'neutral';
                    const bc = d.sig.includes('buy') ? 'sig-buy' : d.sig.includes('sell') ? 'sig-sell' : 'sig-neutral';
                    const st = d.sig.replace('-', ' ').toUpperCase();
                    
                    return `
                        <div class="indicator-item ${tc}">
                            <div class="indicator-top">
                                <span class="indicator-name">${n.toUpperCase()}</span>
                                <span class="indicator-signal ${bc}">${st}</span>
                            </div>
                            <div class="indicator-detail">${d.reason}${d.val !== undefined ? ` (${typeof d.val === 'number' ? d.val.toFixed(2) : d.val})` : ''}</div>
                        </div>
                    `;
                }).join('');
                document.getElementById('indicatorsList').innerHTML = html;
            }

            static updatePatterns(pats, sr) {
                const ph = pats.length > 0 ? pats.map(p => {
                    const em = p.sig === 'bullish' ? '📈' : '📉';
                    return `
                        <div class="pattern-item">
                            <div>
                                <div class="pattern-name">${em} ${p.type}</div>
                                <div class="pattern-conf">${(p.conf * 100).toFixed(0)}% confidence</div>
                            </div>
                        </div>
                    `;
                }).join('') : '<div style="text-align:center;color:#6B7280;padding:20px;">No patterns</div>';
                document.getElementById('patternsList').innerHTML = ph;
                
                const sh = sr.map(l => {
                    const em = l.type === 'support' ? '🟢' : '🔴';
                    return `
                        <div class="pattern-item">
                            <div>
                                <div class="pattern-name">${em} ${l.type.toUpperCase()}</div>
                                <div class="pattern-conf">$${l.price.toFixed(2)} • ${'⭐'.repeat(Math.min(l.str, 5))}</div>
                            </div>
                        </div>
                    `;
                }).join('');
                document.getElementById('srLevels').innerHTML = sh;
            }

            static updateML(lstm, poly) {
                if (lstm) {
                    document.getElementById('lstmMetrics').innerHTML = `
                        <div class="ml-metric">
                            <div class="ml-label">Prediction</div>
                            <div class="ml-value">$${lstm.pred.toFixed(2)}</div>
                        </div>
                        <div class="ml-metric">
                            <div class="ml-label">Accuracy</div>
                            <div class="ml-value">${lstm.acc.toFixed(1)}%</div>
                        </div>
                    `;
                } else {
                    document.getElementById('lstmMetrics').innerHTML = '<div style="text-align:center;color:#9CA3AF;">Training...</div>';
                }
                
                document.getElementById('ensembleMetrics').innerHTML = `
                    <div class="ml-metric">
                        <div class="ml-label">Polynomial</div>
                        <div class="ml-value">$${poly.toFixed(2)}</div>
                    </div>
                `;
            }

            static updatePerf(data, ind) {
                const c = data.map(d => d.close);
                const v = data.map(d => d.volume);
                const chg = ((c[c.length - 1] - c[0]) / c[0]) * 100;
                const hi = Math.max(...c);
                const lo = Math.min(...c);
                const rng = ((hi - lo) / lo) * 100;
                const avgV = v.reduce((a, b) => a + b, 0) / v.length;
                const lastV = v[v.length - 1];
                const vchg = ((lastV - avgV) / avgV) * 100;
                const vol = ind.atr[ind.atr.length - 1];
                const volP = (vol / c[c.length - 1]) * 100;
                
                const html = `
                    <div class="metric-box">
                        <div class="metric-label">Period Return</div>
                        <div class="metric-value" style="color:${chg >= 0 ? '#10B981' : '#EF4444'}">${chg >= 0 ? '+' : ''}${chg.toFixed(2)}%</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">High / Low</div>
                        <div class="metric-value" style="font-size:13px;">$${hi.toFixed(2)} / $${lo.toFixed(2)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Volume</div>
                        <div class="metric-value" style="font-size:14px;">${API.formatVol(lastV)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Volatility</div>
                        <div class="metric-value">${volP.toFixed(2)}%</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">RSI</div>
                        <div class="metric-value">${ind.rsi[ind.rsi.length - 1]?.toFixed(1) || 'N/A'}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">ADX</div>
                        <div class="metric-value">${ind.adx[ind.adx.length - 1]?.toFixed(1) || 'N/A'}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">OBV</div>
                        <div class="metric-value" style="font-size:14px;">${API.formatVol(ind.obv[ind.obv.length - 1])}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">MFI</div>
                        <div class="metric-value">${ind.mfi[ind.mfi.length - 1]?.toFixed(1) || 'N/A'}</div>
                    </div>
                `;
                document.getElementById('performanceMetrics').innerHTML = html;
            }

            static updateRisk(data) {
                const c = data.map(d => d.close);
                const ret = [];
                for (let i = 1; i < c.length; i++) ret.push((c[i] - c[i - 1]) / c[i - 1]);
                const avg = ret.reduce((a, b) => a + b, 0) / ret.length;
                const std = Math.sqrt(ret.reduce((s, r) => s + Math.pow(r - avg, 2), 0) / ret.length);
                const sharpe = avg !== 0 ? (avg / std) * Math.sqrt(365) : 0;
                
                let mdd = 0, peak = c[0];
                for (let i = 1; i < c.length; i++) {
                    if (c[i] > peak) peak = c[i];
                    const dd = ((peak - c[i]) / peak) * 100;
                    if (dd > mdd) mdd = dd;
                }
                
                const html = `
                    <div class="metric-box">
                        <div class="metric-label">Sharpe Ratio</div>
                        <div class="metric-value">${sharpe.toFixed(2)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Max Drawdown</div>
                        <div class="metric-value" style="color:#EF4444;">-${mdd.toFixed(2)}%</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Volatility</div>
                        <div class="metric-value">${(std * 100).toFixed(2)}%</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Avg Daily</div>
                        <div class="metric-value" style="color:${avg >= 0 ? '#10B981' : '#EF4444'}">${(avg * 100).toFixed(3)}%</div>
                    </div>
                `;
                document.getElementById('riskMetrics').innerHTML = html;
            }

            static updateLevels(ind) {
                const p = ind.pivots;
                const f = ind.fib;
                
                const html = `
                    <div class="metric-box">
                        <div class="metric-label">Pivot</div>
                        <div class="metric-value">$${p.pivot.toFixed(2)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">R1 / R2</div>
                        <div class="metric-value" style="font-size:13px;color:#EF4444;">$${p.r1.toFixed(2)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">S1 / S2</div>
                        <div class="metric-value" style="font-size:13px;color:#10B981;">$${p.s1.toFixed(2)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Fib 0.618</div>
                        <div class="metric-value">$${f.l618.toFixed(2)}</div>
                    </div>
                `;
                document.getElementById('levelsMetrics').innerHTML = html;
            }

            static async loadMarkets() {
                const tickers = await API.fetch24h();
                const trending = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'ADAUSDT'];
                const gainers = tickers.filter(t => t.symbol.endsWith('USDT')).sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent)).slice(0, 5);
                const losers = tickers.filter(t => t.symbol.endsWith('USDT')).sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent)).slice(0, 5);
                
                const render = (syms, cont) => {
                    const html = syms.map(s => {
                        const t = typeof s === 'string' ? tickers.find(x => x.symbol === s) : s;
                        if (!t) return '';
                        const chg = parseFloat(t.priceChangePercent);
                        return `
                            <div class="market-card" data-symbol="${t.symbol}">
                                <div class="market-header">
                                    <div>
                                        <div class="market-symbol">${t.symbol.replace('USDT', '')}</div>
                                        <div style="font-size:11px;color:#9CA3AF;">$${parseFloat(t.lastPrice).toFixed(2)}</div>
                                    </div>
                                    <div class="market-change" style="background:${chg >= 0 ? 'rgba(16,185,129,0.2)' : 'rgba(239,68,68,0.2)'};color:${chg >= 0 ? '#10B981' : '#EF4444'}">
                                        ${chg >= 0 ? '+' : ''}${chg.toFixed(2)}%
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    document.getElementById(cont).innerHTML = html;
                };
                
                render(trending, 'trendingList');
                render(gainers, 'gainersList');
                render(losers, 'losersList');
                
                document.querySelectorAll('.market-card').forEach(el => {
                    el.addEventListener('click', () => {
                        QT.symbol = el.dataset.symbol;
                        loadData(QT.symbol, QT.timeframe);
                    });
                });
            }

            static runScanner(tickers) {
                const scored = tickers.filter(t => t.symbol.endsWith('USDT')).map(t => {
                    const chg = parseFloat(t.priceChangePercent);
                    const vol = parseFloat(t.volume);
                    let score = 0;
                    if (chg > 5) score += 2;
                    else if (chg > 2) score += 1;
                    else if (chg < -5) score -= 2;
                    else if (chg < -2) score -= 1;
                    if (vol > 1000000) score += 1;
                    return { ...t, score };
                }).filter(t => Math.abs(t.score) >= 2).sort((a, b) => Math.abs(b.score) - Math.abs(a.score)).slice(0, 10);
                
                const html = scored.map(t => {
                    const scCol = t.score > 0 ? '#10B981' : '#EF4444';
                    return `
                        <div class="scanner-item" data-symbol="${t.symbol}">
                            <div class="scanner-row">
                                <span class="scanner-sym">${t.symbol.replace('USDT', '')}</span>
                                <span class="scanner-score" style="background:${t.score > 0 ? 'rgba(16,185,129,0.2)' : 'rgba(239,68,68,0.2)'};color:${scCol}">
                                    ${t.score > 0 ? '🟢' : '🔴'} ${Math.abs(t.score)}
                                </span>
                            </div>
                        </div>
                    `;
                }).join('');
                
                document.getElementById('scannerResults').innerHTML = html;
                
                document.querySelectorAll('.scanner-item').forEach(el => {
                    el.addEventListener('click', () => {
                        QT.symbol = el.dataset.symbol;
                        loadData(QT.symbol, QT.timeframe);
                    });
                });
            }
        }

        // ==================== MAIN ====================
        async function loadData(sym, tf) {
            try {
                UI.loading(true, 'Fetching data...', 10);
                
                const iv = API.mapTF(tf);
                const data = await API.fetchOHLCV(sym, iv, 500);
                QT.data = data;
                
                UI.loading(true, 'Rendering charts...', 30);
                QT.candleSeries.setData(data);
                QT.volumeSeries.setData(data.map(d => ({
                    time: d.time,
                    value: d.volume,
                    color: d.close > d.open ? 'rgba(16,185,129,0.5)' : 'rgba(239,68,68,0.5)'
                })));
                
                UI.updatePrice(data);
                
                UI.loading(true, 'Calculating indicators...', 50);
                const ind = Indicators.calc(data);
                QT.indicators = ind;
                
                UI.loading(true, 'AI analysis...', 65);
                const ana = AI.analyze(data, ind);
                QT.analysis = ana;
                
                UI.updateSignal(ana);
                UI.updateIndicators(ana.sigs);
                UI.updatePatterns(ana.pats, ana.sr);
                UI.updatePerf(data, ind);
                UI.updateRisk(data);
                UI.updateLevels(ind);
                
                document.getElementById('aiAnalysis').innerHTML = ana.analysis;
                
                UI.loading(true, 'Training ML models...', 80);
                setTimeout(async () => {
                    const lstm = await ML.trainLSTM(data, (p, t) => UI.loading(true, t, p));
                    const poly = ML.poly(data);
                    UI.updateML(lstm, poly);
                    UI.loading(false);
                    UI.notify('✅ Complete', `${sym} analyzed successfully!`);
                }, 100);
                
            } catch (e) {
                console.error(e);
                UI.loading(false);
                UI.notify('❌ Error', e.message);
            }
        }

        // ==================== EVENTS ====================
        let searchTO;
        document.getElementById('searchInput').addEventListener('input', async (e) => {
            clearTimeout(searchTO);
            const q = e.target.value.toUpperCase();
            if (q.length < 1) {
                document.getElementById('searchResults').classList.remove('active');
                return;
            }
            searchTO = setTimeout(async () => {
                if (QT.allSymbols.length === 0) QT.allSymbols = await API.fetchSymbols();
                const res = QT.allSymbols.filter(s => s.base.includes(q) || s.symbol.includes(q)).slice(0, 20);
                const ticks = await API.fetch24h();
                const html = res.map(s => {
                    const t = ticks.find(x => x.symbol === s.symbol);
                    const chg = t ? parseFloat(t.priceChangePercent) : 0;
                    return `
                        <div class="search-item" data-symbol="${s.symbol}">
                            <div><strong>${s.base}/USDT</strong></div>
                            <div style="font-size:11px;font-weight:700;color:${chg >= 0 ? '#10B981' : '#EF4444'}">
                                ${chg >= 0 ? '+' : ''}${chg.toFixed(2)}%
                            </div>
                        </div>
                    `;
                }).join('');
                document.getElementById('searchResults').innerHTML = html;
                document.getElementById('searchResults').classList.add('active');
                document.querySelectorAll('.search-item').forEach(el => {
                    el.addEventListener('click', () => {
                        QT.symbol = el.dataset.symbol;
                        document.getElementById('searchInput').value = el.dataset.symbol;
                        document.getElementById('searchResults').classList.remove('active');
                        loadData(QT.symbol, QT.timeframe);
                    });
                });
            }, 300);
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-box')) {
                document.getElementById('searchResults').classList.remove('active');
            }
        });

        document.querySelectorAll('.tf-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                QT.timeframe = btn.dataset.tf;
                loadData(QT.symbol, QT.timeframe);
            });
        });

        document.querySelectorAll('.tab').forEach(btn => {
            btn.addEventListener('click', () => {
                const tab = btn.dataset.tab;
                const parent = btn.closest('.panel-content') || btn.closest('.panel');
                parent.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
                parent.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                btn.classList.add('active');
                const panel = document.getElementById(`${tab}Tab`);
                if (panel) panel.classList.add('active');
                
                // Run scanner when tab opened
                if (tab === 'scanner' && QT.scannerData.length === 0) {
                    API.fetch24h().then(ticks => {
                        QT.scannerData = ticks;
                        UI.runScanner(ticks);
                    });
                }
            });
        });

        // ==================== INIT ====================
        window.addEventListener('DOMContentLoaded', () => {
            console.log('%c⚡ QUANTUM TERMINAL PRO INITIALIZED', 'color:#6366F1;font-size:16px;font-weight:bold;');
            UI.initChart();
            UI.loadMarkets();
            setTimeout(() => loadData(QT.symbol, QT.timeframe), 500);
        });
    </script>
</body>
</html>
