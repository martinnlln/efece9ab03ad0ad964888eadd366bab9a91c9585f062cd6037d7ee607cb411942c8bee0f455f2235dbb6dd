<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Trading Platform</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0e1a;
            color: #fff;
            padding: 20px;
        }
        
        .container { max-width: 1400px; margin: 0 auto; }
        
        h1 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            font-size: 2.5rem;
        }
        
        .controls {
            background: #1a1f35;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        input, select, button {
            padding: 12px 20px;
            background: #0a0e1a;
            border: 1px solid #667eea;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            font-weight: 600;
            border: none;
        }
        
        button:hover { opacity: 0.8; }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .card {
            background: #1a1f35;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }
        
        .card h2 {
            margin-bottom: 15px;
            font-size: 1.2rem;
            color: #667eea;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .stat:last-child { border: none; }
        
        .positive { color: #10b981; }
        .negative { color: #ef4444; }
        
        .prediction {
            text-align: center;
            padding: 30px;
            font-size: 3rem;
        }
        
        .confidence {
            height: 30px;
            background: #0a0e1a;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #667eea);
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        th {
            color: #667eea;
            font-weight: 600;
        }
        
        tr:hover {
            background: rgba(102, 126, 234, 0.1);
            cursor: pointer;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
        }
        
        .signal {
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .signal.buy { 
            background: rgba(16, 185, 129, 0.1);
            border-color: #10b981;
        }
        
        .signal.sell { 
            background: rgba(239, 68, 68, 0.1);
            border-color: #ef4444;
        }
        
        .signal.neutral { 
            background: rgba(102, 126, 234, 0.1);
            border-color: #667eea;
        }
        
        .position {
            background: rgba(102, 126, 234, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr auto;
            gap: 15px;
            align-items: center;
        }
        
        .btn-close {
            background: #ef4444;
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            color: white;
        }
        
        #searchResults {
            max-height: 300px;
            overflow-y: auto;
        }
        
        @media (max-width: 768px) {
            .position { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ AI Trading Intelligence Platform</h1>
        
        <div class="controls">
            <input type="text" id="searchSymbol" placeholder="Search symbol (BTC, ETH, AAPL...)" />
            <button onclick="searchSymbol()">üîç Search</button>
            <select id="symbolSelect" onchange="loadSymbol()">
                <option value="">Loading symbols...</option>
            </select>
            <select id="timeframe" onchange="loadData()">
                <option value="1h">1 Hour</option>
                <option value="4h">4 Hours</option>
                <option value="1d">1 Day</option>
            </select>
            <button onclick="refreshAll()">üîÑ Refresh</button>
            <button onclick="showAddPosition()">‚ûï Add Position</button>
        </div>
        
        <div id="searchResults" style="display:none;" class="card"></div>
        
        <div class="grid">
            <div class="card">
                <h2>üìä Current Price</h2>
                <div class="prediction" id="currentPrice">Loading...</div>
                <div style="text-align: center; color: #9ca3af;" id="priceChange">‚Äï</div>
            </div>
            
            <div class="card">
                <h2>ü§ñ AI Prediction</h2>
                <div class="prediction" id="mlPrediction">‚è≥</div>
                <p style="text-align: center; margin: 10px 0; color: #9ca3af;" id="predictionText">Analyzing...</p>
                <div class="confidence">
                    <div class="confidence-fill" id="confidenceBar" style="width: 0%">0%</div>
                </div>
            </div>
            
            <div class="card">
                <h2>üíº Portfolio</h2>
                <div class="stat">
                    <span>Total Value:</span>
                    <strong id="portfolioValue">$0.00</strong>
                </div>
                <div class="stat">
                    <span>Total P&L:</span>
                    <strong id="totalPnL">$0.00</strong>
                </div>
                <div class="stat">
                    <span>Win Rate:</span>
                    <strong id="winRate">0%</strong>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>üìà Technical Indicators</h2>
            <div id="indicators">Loading indicators...</div>
        </div>
        
        <div class="card">
            <h2>üéØ Trading Signals</h2>
            <div id="signals">Analyzing market...</div>
        </div>
        
        <div class="card">
            <h2>üìä Price History (Last 10 Candles)</h2>
            <div id="priceHistory">Loading...</div>
        </div>
        
        <div class="card">
            <h2>üî• Top 20 Crypto by Volume</h2>
            <table id="topCoins">
                <thead>
                    <tr>
                        <th>Symbol</th>
                        <th>Price</th>
                        <th>24h Change</th>
                        <th>Volume</th>
                    </tr>
                </thead>
                <tbody><tr><td colspan="4" class="loading">Loading market data...</td></tr></tbody>
            </table>
        </div>
        
        <div class="card">
            <h2>üí∞ Active Positions</h2>
            <div id="positions">No positions yet. Click "Add Position" to start tracking.</div>
        </div>
    </div>
    
    <div id="addPositionModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:1000; padding:20px; overflow-y:auto;">
        <div style="max-width:500px; margin:50px auto; background:#1a1f35; padding:30px; border-radius:12px;">
            <h2 style="margin-bottom:20px;">Add New Position</h2>
            <input type="text" id="posSymbol" placeholder="Symbol (e.g., BTCUSDT)" style="width:100%; margin:10px 0;" />
            <input type="number" id="posEntry" placeholder="Entry Price" style="width:100%; margin:10px 0;" step="0.01" />
            <input type="number" id="posAmount" placeholder="Amount" style="width:100%; margin:10px 0;" step="0.0001" />
            <select id="posSide" style="width:100%; margin:10px 0;">
                <option value="long">Long (Buy)</option>
                <option value="short">Short (Sell)</option>
            </select>
            <input type="number" id="posLeverage" placeholder="Leverage (1-125)" style="width:100%; margin:10px 0;" value="1" />
            <div style="display:flex; gap:10px; margin-top:20px;">
                <button onclick="addPosition()" style="flex:1;">Add Position</button>
                <button onclick="hideAddPosition()" style="flex:1; background:#ef4444;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ============= STATE =============
        let state = {
            symbol: 'BTCUSDT',
            timeframe: '1h',
            priceData: [],
            currentPrice: 0,
            positions: JSON.parse(localStorage.getItem('positions') || '[]'),
            mlModel: null,
            allSymbols: []
        };

        // ============= DATA FETCHING =============
        async function fetchBinanceData(symbol, interval, limit = 500) {
            try {
                const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
                const res = await fetch(url);
                const data = await res.json();
                return data.map(d => ({
                    time: d[0],
                    open: parseFloat(d[1]),
                    high: parseFloat(d[2]),
                    low: parseFloat(d[3]),
                    close: parseFloat(d[4]),
                    volume: parseFloat(d[5])
                }));
            } catch (e) {
                console.error('Fetch error:', e);
                return [];
            }
        }

        async function fetchTicker(symbol) {
            try {
                const res = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`);
                return await res.json();
            } catch (e) {
                return null;
            }
        }

        async function fetchAllSymbols() {
            try {
                const res = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                const data = await res.json();
                state.allSymbols = data.symbols
                    .filter(s => s.status === 'TRADING' && s.symbol.endsWith('USDT'))
                    .map(s => s.symbol);
                
                const select = document.getElementById('symbolSelect');
                select.innerHTML = state.allSymbols.slice(0, 50).map(s => 
                    `<option value="${s}">${s.replace('USDT', '/USDT')}</option>`
                ).join('');
                select.value = state.symbol;
            } catch (e) {
                console.error('Error loading symbols:', e);
            }
        }

        async function fetchTopCoins() {
            try {
                const res = await fetch('https://api.binance.com/api/v3/ticker/24hr');
                const data = await res.json();
                const top = data
                    .filter(t => t.symbol.endsWith('USDT'))
                    .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
                    .slice(0, 20);
                
                const tbody = document.querySelector('#topCoins tbody');
                tbody.innerHTML = top.map(t => {
                    const change = parseFloat(t.priceChangePercent);
                    const changeClass = change >= 0 ? 'positive' : 'negative';
                    return `
                        <tr onclick="selectSymbol('${t.symbol}')">
                            <td>${t.symbol.replace('USDT', '/USDT')}</td>
                            <td>$${parseFloat(t.lastPrice).toFixed(2)}</td>
                            <td class="${changeClass}">${change >= 0 ? '+' : ''}${change.toFixed(2)}%</td>
                            <td>$${(parseFloat(t.quoteVolume) / 1000000).toFixed(2)}M</td>
                        </tr>
                    `;
                }).join('');
            } catch (e) {
                console.error('Error loading top coins:', e);
            }
        }

        // ============= TECHNICAL INDICATORS =============
        function calculateRSI(data, period = 14) {
            const changes = [];
            for (let i = 1; i < data.length; i++) {
                changes.push(data[i].close - data[i - 1].close);
            }
            
            let gains = 0, losses = 0;
            for (let i = 0; i < period; i++) {
                if (changes[i] > 0) gains += changes[i];
                else losses -= changes[i];
            }
            
            let avgGain = gains / period;
            let avgLoss = losses / period;
            
            for (let i = period; i < changes.length; i++) {
                if (changes[i] > 0) {
                    avgGain = (avgGain * (period - 1) + changes[i]) / period;
                    avgLoss = (avgLoss * (period - 1)) / period;
                } else {
                    avgGain = (avgGain * (period - 1)) / period;
                    avgLoss = (avgLoss * (period - 1) - changes[i]) / period;
                }
            }
            
            const rs = avgGain / (avgLoss || 1);
            return 100 - (100 / (1 + rs));
        }

        function calculateSMA(data, period) {
            if (data.length < period) return null;
            const sum = data.slice(-period).reduce((a, b) => a + b.close, 0);
            return sum / period;
        }

        function calculateEMA(data, period) {
            if (data.length < period) return null;
            const k = 2 / (period + 1);
            let ema = data.slice(0, period).reduce((a, b) => a + b.close, 0) / period;
            for (let i = period; i < data.length; i++) {
                ema = data[i].close * k + ema * (1 - k);
            }
            return ema;
        }

        function calculateMACD(data) {
            const ema12 = calculateEMA(data, 12);
            const ema26 = calculateEMA(data, 26);
            if (!ema12 || !ema26) return null;
            return ema12 - ema26;
        }

        function calculateBollingerBands(data, period = 20) {
            const sma = calculateSMA(data, period);
            if (!sma) return null;
            
            const slice = data.slice(-period);
            const variance = slice.reduce((sum, d) => sum + Math.pow(d.close - sma, 2), 0) / period;
            const std = Math.sqrt(variance);
            
            return {
                upper: sma + 2 * std,
                middle: sma,
                lower: sma - 2 * std
            };
        }

        function analyzeIndicators() {
            if (state.priceData.length < 50) return {};
            
            const rsi = calculateRSI(state.priceData);
            const sma20 = calculateSMA(state.priceData, 20);
            const sma50 = calculateSMA(state.priceData, 50);
            const ema12 = calculateEMA(state.priceData, 12);
            const ema26 = calculateEMA(state.priceData, 26);
            const macd = calculateMACD(state.priceData);
            const bb = calculateBollingerBands(state.priceData);
            
            return { rsi, sma20, sma50, ema12, ema26, macd, bb };
        }

        // ============= ML PREDICTION =============
        async function createMLModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [20], units: 64, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 32, activation: 'relu' }),
                    tf.layers.dense({ units: 1, activation: 'sigmoid' })
                ]
            });
            
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }

        async function trainAndPredict() {
            if (state.priceData.length < 100) {
                document.getElementById('mlPrediction').textContent = '‚ùå';
                document.getElementById('predictionText').textContent = 'Need more data (100+ candles)';
                return;
            }

            try {
                document.getElementById('mlPrediction').textContent = '‚è≥';
                document.getElementById('predictionText').textContent = 'Training model...';

                if (!state.mlModel) {
                    state.mlModel = await createMLModel();
                }

                // Prepare training data
                const features = [];
                const labels = [];
                
                for (let i = 20; i < state.priceData.length - 1; i++) {
                    const feature = [];
                    const basePrice = state.priceData[i - 20].close;
                    
                    for (let j = 0; j < 20; j++) {
                        feature.push((state.priceData[i - 20 + j].close - basePrice) / basePrice);
                    }
                    
                    features.push(feature);
                    labels.push(state.priceData[i + 1].close > state.priceData[i].close ? 1 : 0);
                }

                const xs = tf.tensor2d(features);
                const ys = tf.tensor2d(labels, [labels.length, 1]);

                // Train
                await state.mlModel.fit(xs, ys, {
                    epochs: 20,
                    batchSize: 32,
                    validationSplit: 0.2,
                    verbose: 0
                });

                // Predict
                const lastFeature = [];
                const basePrice = state.priceData[state.priceData.length - 20].close;
                
                for (let i = state.priceData.length - 20; i < state.priceData.length; i++) {
                    lastFeature.push((state.priceData[i].close - basePrice) / basePrice);
                }

                const input = tf.tensor2d([lastFeature]);
                const prediction = state.mlModel.predict(input);
                const value = (await prediction.data())[0];

                // Clean up
                xs.dispose();
                ys.dispose();
                input.dispose();
                prediction.dispose();

                // Display
                const confidence = Math.abs(value - 0.5) * 200;
                const direction = value > 0.5 ? 'BULLISH' : 'BEARISH';
                
                document.getElementById('mlPrediction').textContent = value > 0.5 ? 'üìà' : 'üìâ';
                document.getElementById('predictionText').textContent = direction;
                document.getElementById('confidenceBar').style.width = confidence + '%';
                document.getElementById('confidenceBar').textContent = confidence.toFixed(1) + '%';

            } catch (e) {
                console.error('ML Error:', e);
                document.getElementById('mlPrediction').textContent = '‚ùå';
                document.getElementById('predictionText').textContent = 'Prediction failed';
            }
        }

        // ============= SIGNALS =============
        function generateSignals() {
            const indicators = analyzeIndicators();
            if (!indicators.rsi) {
                document.getElementById('signals').innerHTML = '<p>Not enough data for signals</p>';
                return;
            }

            const signals = [];
            const price = state.currentPrice;

            // RSI signals
            if (indicators.rsi < 30) {
                signals.push({ type: 'buy', text: `RSI Oversold (${indicators.rsi.toFixed(2)}) - Strong Buy Signal` });
            } else if (indicators.rsi > 70) {
                signals.push({ type: 'sell', text: `RSI Overbought (${indicators.rsi.toFixed(2)}) - Consider Selling` });
            }

            // MACD signals
            if (indicators.macd > 0) {
                signals.push({ type: 'buy', text: 'MACD Positive - Bullish Momentum' });
            } else {
                signals.push({ type: 'sell', text: 'MACD Negative - Bearish Momentum' });
            }

            // Bollinger Bands
            if (indicators.bb) {
                if (price < indicators.bb.lower) {
                    signals.push({ type: 'buy', text: 'Price Below Lower BB - Oversold' });
                } else if (price > indicators.bb.upper) {
                    signals.push({ type: 'sell', text: 'Price Above Upper BB - Overbought' });
                }
            }

            // Moving averages
            if (indicators.sma20 && indicators.sma50) {
                if (price > indicators.sma20 && price > indicators.sma50) {
                    signals.push({ type: 'buy', text: 'Price Above MAs - Uptrend' });
                } else if (price < indicators.sma20 && price < indicators.sma50) {
                    signals.push({ type: 'sell', text: 'Price Below MAs - Downtrend' });
                }
            }

            if (signals.length === 0) {
                signals.push({ type: 'neutral', text: 'No strong signals - Market is neutral' });
            }

            document.getElementById('signals').innerHTML = signals.map(s => 
                `<div class="signal ${s.type}">${s.text}</div>`
            ).join('');
        }

        // ============= UI UPDATES =============
        function updateUI() {
            const indicators = analyzeIndicators();
            
            // Indicators
            let html = '<div class="stat"><span>RSI (14)</span><strong>' + 
                (indicators.rsi ? indicators.rsi.toFixed(2) : 'N/A') + '</strong></div>';
            html += '<div class="stat"><span>MACD</span><strong>' + 
                (indicators.macd ? indicators.macd.toFixed(4) : 'N/A') + '</strong></div>';
            html += '<div class="stat"><span>SMA (20)</span><strong>' + 
                (indicators.sma20 ? '$' + indicators.sma20.toFixed(2) : 'N/A') + '</strong></div>';
            html += '<div class="stat"><span>SMA (50)</span><strong>' + 
                (indicators.sma50 ? '$' + indicators.sma50.toFixed(2) : 'N/A') + '</strong></div>';
            html += '<div class="stat"><span>EMA (12)</span><strong>' + 
                (indicators.ema12 ? '$' + indicators.ema12.toFixed(2) : 'N/A') + '</strong></div>';
            html += '<div class="stat"><span>EMA (26)</span><strong>' + 
                (indicators.ema26 ? '$' + indicators.ema26.toFixed(2) : 'N/A') + '</strong></div>';
            
            if (indicators.bb) {
                html += '<div class="stat"><span>BB Upper</span><strong>$' + 
                    indicators.bb.upper.toFixed(2) + '</strong></div>';
                html += '<div class="stat"><span>BB Middle</span><strong>$' + 
                    indicators.bb.middle.toFixed(2) + '</strong></div>';
                html += '<div class="stat"><span>BB Lower</span><strong>$' + 
                    indicators.bb.lower.toFixed(2) + '</strong></div>';
            }
            
            document.getElementById('indicators').innerHTML = html;

            // Price history
            const last10 = state.priceData.slice(-10);
            const historyHtml = '<table style="width:100%;"><thead><tr><th>Time</th><th>Open</th><th>High</th><th>Low</th><th>Close</th><th>Volume</th></tr></thead><tbody>' +
                last10.reverse().map(d => {
                    const date = new Date(d.time);
                    return `<tr>
                        <td>${date.toLocaleString()}</td>
                        <td>$${d.open.toFixed(2)}</td>
                        <td class="positive">$${d.high.toFixed(2)}</td>
                        <td class="negative">$${d.low.toFixed(2)}</td>
                        <td>$${d.close.toFixed(2)}</td>
                        <td>${d.volume.toFixed(2)}</td>
                    </tr>`;
                }).join('') + '</tbody></table>';
            
            document.getElementById('priceHistory').innerHTML = historyHtml;

            // Generate signals
            generateSignals();

            // Update portfolio
            updatePortfolio();
        }

        function updatePortfolio() {
            let totalValue = 0;
            let totalPnL = 0;
            let wins = 0;
            let total = 0;

            if (state.positions.length === 0) {
                document.getElementById('positions').innerHTML = 'No positions yet. Click "Add Position" to start tracking.';
            } else {
                const html = state.positions.map((p, i) => {
                    const entryValue = p.entry * p.amount;
                    const currentValue = state.currentPrice * p.amount;
                    let pnl, pnlPercent;
                    
                    if (p.side === 'long') {
                        pnl = (currentValue - entryValue) * p.leverage;
                        pnlPercent = ((state.currentPrice - p.entry) / p.entry) * 100 * p.leverage;
                    } else {
                        pnl = (entryValue - currentValue) * p.leverage;
                        pnlPercent = ((p.entry - state.currentPrice) / p.entry) * 100 * p.leverage;
                    }

                    totalValue += entryValue;
                    totalPnL += pnl;
                    total++;
                    if (pnl > 0) wins++;

                    const pnlClass = pnl >= 0 ? 'positive' : 'negative';
                    return `<div class="position">
                        <div><strong>${p.symbol}</strong><br><small>${p.side} ${p.leverage}x | Entry: $${p.entry}</small></div>
                        <div>Amount: ${p.amount}</div>
                        <div>Current: $${state.currentPrice.toFixed(2)}</div>
                        <div class="${pnlClass}"><strong>${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%</strong><br>$${pnl.toFixed(2)}</div>
                        <button class="btn-close" onclick="removePosition(${i})">Close</button>
                    </div>`;
                }).join('');
                document.getElementById('positions').innerHTML = html;
            }

            document.getElementById('portfolioValue').textContent = '$' + totalValue.toFixed(2);
            document.getElementById('totalPnL').textContent = '$' + totalPnL.toFixed(2);
            document.getElementById('totalPnL').className = totalPnL >= 0 ? 'positive' : 'negative';
            document.getElementById('winRate').textContent = total > 0 ? ((wins / total) * 100).toFixed(1) + '%' : '0%';
        }

        // ============= DATA LOADING =============
        async function loadData() {
            document.getElementById('currentPrice').textContent = 'Loading...';
            
            const data = await fetchBinanceData(state.symbol, state.timeframe);
            if (data.length > 0) {
                state.priceData = data;
                state.currentPrice = data[data.length - 1].close;
                
                document.getElementById('currentPrice').textContent = '$' + state.currentPrice.toFixed(2);
                
                const ticker = await fetchTicker(state.symbol);
                if (ticker) {
                    const change = parseFloat(ticker.priceChangePercent);
                    const changeClass = change >= 0 ? 'positive' : 'negative';
                    document.getElementById('priceChange').innerHTML = 
                        `<span class="${changeClass}">${change >= 0 ? '‚ñ≤' : '‚ñº'} ${Math.abs(change).toFixed(2)}%</span> (24h)`;
                }

                updateUI();
                trainAndPredict();
            }
        }

        async function loadSymbol() {
            state.symbol = document.getElementById('symbolSelect').value;
            await loadData();
        }

        function selectSymbol(symbol) {
            state.symbol = symbol;
            document.getElementById('symbolSelect').value = symbol;
            loadData();
        }

        async function refreshAll() {
            await loadData();
            await fetchTopCoins();
        }

        // ============= SEARCH =============
        function searchSymbol() {
            const query = document.getElementById('searchSymbol').value.toUpperCase();
            const results = state.allSymbols.filter(s => s.includes(query)).slice(0, 20);
            
            if (results.length > 0) {
                const html = '<h3>Search Results:</h3>' + 
                    results.map(s => `<div class="signal neutral" onclick="selectSymbol('${s}')" style="cursor:pointer;">
                        ${s.replace('USDT', '/USDT')}
                    </div>`).join('');
                document.getElementById('searchResults').innerHTML = html;
                document.getElementById('searchResults').style.display = 'block';
            } else {
                document.getElementById('searchResults').innerHTML = '<p>No results found</p>';
                document.getElementById('searchResults').style.display = 'block';
            }
        }

        document.getElementById('searchSymbol').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') searchSymbol();
        });

        // ============= POSITIONS =============
        function showAddPosition() {
            document.getElementById('addPositionModal').style.display = 'block';
            document.getElementById('posSymbol').value = state.symbol;
        }

        function hideAddPosition() {
            document.getElementById('addPositionModal').style.display = 'none';
        }

        function addPosition() {
            const pos = {
                symbol: document.getElementById('posSymbol').value,
                entry: parseFloat(document.getElementById('posEntry').value),
                amount: parseFloat(document.getElementById('posAmount').value),
                side: document.getElementById('posSide').value,
                leverage: parseInt(document.getElementById('posLeverage').value)
            };

            if (pos.entry && pos.amount && pos.leverage) {
                state.positions.push(pos);
                localStorage.setItem('positions', JSON.stringify(state.positions));
                updatePortfolio();
                hideAddPosition();
            } else {
                alert('Please fill all required fields');
            }
        }

        function removePosition(index) {
            if (confirm('Close this position?')) {
                state.positions.splice(index, 1);
                localStorage.setItem('positions', JSON.stringify(state.positions));
                updatePortfolio();
            }
        }

        // ============= INIT =============
        async function init() {
            console.log('üöÄ Loading AI Trading Platform...');
            await fetchAllSymbols();
            await loadData();
            await fetchTopCoins();
            
            // Auto-refresh every 30 seconds
            setInterval(refreshAll, 30000);
            
            console.log('‚úÖ Platform ready!');
        }

        window.onload = init;
    </script>
</body>
</html>
