<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIF/USDT Personal Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%); color: #ffffff; overflow-x: hidden; }
        .header { background: linear-gradient(90deg, #1e3c72 0%, #2a5298 100%); padding: 15px 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); position: relative; overflow: hidden; }
        .header::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent); animation: shimmer 3s infinite; }
        @keyframes shimmer { 0% { left: -100%; } 100% { left: 100%; } }
        .header-content { display: flex; justify-content: space-between; align-items: center; position: relative; z-index: 1; flex-wrap: wrap; }
        .logo { font-size: 24px; font-weight: bold; color: #00ff88; text-shadow: 0 0 10px rgba(0,255,136,0.3); }
        .price-ticker { display: flex; gap: 30px; align-items: center; background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 25px; backdrop-filter: blur(10px); flex-wrap: wrap; }
        .price-info { text-align: center; }
        .price-value { font-size: 18px; font-weight: bold; color: #00ff88; }
        .price-change { font-size: 12px; margin-top: 2px; }
        .positive { color: #00ff88; }
        .negative { color: #ff4444; }
        .main-container { display: grid; grid-template-columns: 250px 1fr 300px; grid-template-rows: 1fr; height: calc(100vh - 80px); gap: 10px; padding: 10px; }
        .sidebar { background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border-radius: 15px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); }
        .sidebar h3 { color: #00ff88; margin-bottom: 15px; font-size: 16px; text-transform: uppercase; letter-spacing: 1px; }
        .indicator-group { margin-bottom: 25px; }
        .indicator-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; margin: 5px 0; background: rgba(255,255,255,0.05); border-radius: 8px; transition: all 0.3s ease; cursor: pointer; border: 1px solid transparent; }
        .indicator-item:hover { background: rgba(0,255,136,0.1); border-color: rgba(0,255,136,0.3); transform: translateX(5px); }
        .indicator-value { font-weight: bold; font-size: 12px; }
        .chart-container { background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border-radius: 15px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; }
        .chart-controls { display: flex; justify-content: space-between; margin-bottom: 20px; flex-wrap: wrap; gap: 10px; }
        .timeframe-buttons { display: flex; gap: 5px; }
        .timeframe-btn { padding: 8px 15px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 20px; color: white; cursor: pointer; transition: all 0.3s ease; font-size: 12px; }
        .timeframe-btn.active, .timeframe-btn:hover { background: linear-gradient(45deg, #00ff88, #00cc6a); border-color: #00ff88; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0,255,136,0.3); }
        .chart-wrapper { position: relative; flex: 1; min-height: 400px; }
        .right-panel { display: flex; flex-direction: column; gap: 10px; }
        .panel { background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); border-radius: 15px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); }
        .panel h3 { color: #00ff88; margin-bottom: 15px; font-size: 16px; text-align: center; }
        .prediction-card { background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3); border-radius: 10px; padding: 15px; margin: 10px 0; text-align: center; }
        .prediction-price { font-size: 20px; font-weight: bold; }
        .confidence-bar { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin: 10px 0; }
        .confidence-fill { height: 100%; background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff88); transition: width 0.5s ease; }
        .signal-item { display: flex; justify-content: space-between; padding: 10px; margin: 5px 0; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 4px solid transparent; }
        .signal-buy { border-left-color: #00ff88; }
        .signal-sell { border-left-color: #ff4444; }
        .signal-hold { border-left-color: #ffaa00; }
        .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; animation: pulse 2s infinite; }
        .status-connected { background: #00ff88; }
        .status-disconnected { background: #ff4444; }
        @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } 100% { opacity: 1; transform: scale(1); } }
        .loading-spinner { border: 3px solid rgba(255,255,255,0.1); border-radius: 50%; border-top: 3px solid #00ff88; width: 20px; height: 20px; animation: spin 1s linear infinite; margin: 0 auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .error-message { background: rgba(255, 68, 68, 0.1); border: 1px solid rgba(255, 68, 68, 0.3); border-radius: 8px; padding: 15px; margin: 10px 0; color: #ff4444; text-align: center; }
        @media (max-width: 1200px) { .main-container { grid-template-columns: 1fr; grid-template-rows: auto 1fr auto; } .sidebar, .right-panel { overflow-y: visible; } }
        @media (max-width: 768px) { .header-content { flex-direction: column; gap: 10px; } .price-ticker { justify-content: center; } }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">WIF/USDT Personal Dashboard</div>
            <div class="price-ticker">
                <div class="price-info">
                    <div class="price-value" id="currentPrice">...</div>
                    <div class="price-change" id="priceChange">--</div>
                </div>
                <div class="price-info">
                    <div class="price-value" id="volume24h">--</div>
                    <div style="font-size: 12px; color: #aaa;">24h Volume</div>
                </div>
                <div class="price-info">
                    <div class="price-value" id="marketCap">...</div>
                    <div style="font-size: 12px; color: #aaa;">Market Cap</div>
                </div>
                <div style="display: flex; align-items: center;">
                    <span class="status-indicator status-disconnected" id="connectionStatus"></span>
                    <span style="font-size: 12px;" id="connectionText">Connecting...</span>
                </div>
            </div>
        </div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <div class="indicator-group">
                <h3>Trend Indicators</h3>
                <div class="indicator-item"><span>SMA (20)</span><span class="indicator-value" id="sma20">...</span></div>
                <div class="indicator-item"><span>EMA (20)</span><span class="indicator-value" id="ema20">...</span></div>
                <div class="indicator-item"><span>MACD</span><span class="indicator-value" id="macd">...</span></div>
                <div class="indicator-item"><span>Bollinger Upper</span><span class="indicator-value" id="bbUpper">...</span></div>
                <div class="indicator-item"><span>Bollinger Lower</span><span class="indicator-value" id="bbLower">...</span></div>
            </div>
            <div class="indicator-group">
                <h3>Momentum</h3>
                <div class="indicator-item"><span>RSI (14)</span><span class="indicator-value" id="rsi">...</span></div>
                <div class="indicator-item"><span>Stochastic %K</span><span class="indicator-value" id="stoch">...</span></div>
            </div>
            <div class="indicator-group">
                <h3>Volume</h3>
                <div class="indicator-item"><span>VWAP</span><span class="indicator-value" id="vwap">...</span></div>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-controls">
                <div class="timeframe-buttons">
                    <button class="timeframe-btn" data-timeframe="5m">5m</button>
                    <button class="timeframe-btn" data-timeframe="15m">15m</button>
                    <button class="timeframe-btn" data-timeframe="1h">1h</button>
                    <button class="timeframe-btn active" data-timeframe="4h">4h</button>
                    <button class="timeframe-btn" data-timeframe="1d">1d</button>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="priceChart"></canvas>
            </div>
        </div>

        <div class="right-panel">
            <div class="panel">
                <h3>Heuristic Prediction</h3>
                <div class="prediction-card">
                    <div style="font-size: 14px; margin-bottom: 5px;">Next Period Outlook</div>
                    <div class="prediction-price" id="predictionPrice">...</div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
                    </div>
                    <div style="font-size: 12px;" id="confidenceText">Analyzing...</div>
                </div>
            </div>

            <div class="panel">
                <h3>Trading Signals</h3>
                <div id="signalsContainer"><div class="loading-spinner"></div></div>
            </div>
        </div>
    </div>

    <script>
        class WIFDashboard {
            constructor() {
                // --- CONFIGURATION ---
                this.config = {
                    symbol: 'WIFUSDT',
                    binanceApiBase: 'https://api.binance.com/api/v3',
                    // CoinGecko API is used for live circulating supply to calculate market cap.
                    // You can get a free API key from their site for better reliability.
                    coinGeckoApiBase: 'https://api.coingecko.com/api/v3',
                    coinGeckoCoinId: 'dogwifcoin',
                    // WARNING: For personal use ONLY. Do not use API keys in public-facing websites.
                    coinGeckoApiKey: '', // Optional: Add your CoinGecko API key here
                    historicalLimit: 500, // Number of candles to fetch for chart
                };

                this.ws = null;
                this.chart = null;
                this.priceData = [];
                this.indicators = {};
                this.currentTimeframe = '4h';
                this.currentPrice = 0;
                this.priceChange24h = 0;
            }

            async initialize() {
                this.initializeChart();
                this.initializeEventListeners();
                await this.fetchInitialData();
                this.connectWebSocket();

                // Set up periodic updates for data not from the WebSocket
                setInterval(() => this.updateHeuristicsAndSignals(), 5000); // Update predictions/signals every 5s
                setInterval(() => this.fetchMarketData(), 60000); // Refresh market cap every minute
            }
            
            initializeChart() {
                const ctx = document.getElementById('priceChart').getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'WIF/USDT Price', data: [], borderColor: '#00ff88', borderWidth: 2, fill: false, tension: 0.1, pointRadius: 0 }] },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: { legend: { labels: { color: '#ffffff' } } },
                        scales: {
                            x: { ticks: { color: '#aaa', maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            y: { position: 'right', ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                        }
                    }
                });
            }

            async fetchInitialData() {
                try {
                    await this.fetchMarketData();
                    await this.fetchHistoricalData();
                    this.processData();
                } catch (error) {
                    console.error("Initialization failed:", error);
                    this.showError("Failed to load initial data.");
                }
            }

            async fetchMarketData() {
                try {
                    // Fetch ticker data from Binance
                    const tickerUrl = `${this.config.binanceApiBase}/ticker/24hr?symbol=${this.config.symbol}`;
                    const tickerResponse = await fetch(tickerUrl);
                    if (!tickerResponse.ok) throw new Error('Failed to fetch Binance ticker');
                    const tickerData = await tickerResponse.json();
                    
                    this.currentPrice = parseFloat(tickerData.lastPrice);
                    this.priceChange24h = parseFloat(tickerData.priceChangePercent);
                    
                    // Fetch market cap data from CoinGecko
                    const coinUrl = `${this.config.coinGeckoApiBase}/coins/${this.config.coinGeckoCoinId}${this.config.coinGeckoApiKey ? '?x_cg_demo_api_key='+this.config.coinGeckoApiKey : ''}`;
                    const coinResponse = await fetch(coinUrl);
                    if (!coinResponse.ok) throw new Error('Failed to fetch CoinGecko data');
                    const coinData = await coinResponse.json();

                    const circulatingSupply = coinData.market_data.circulating_supply;
                    const marketCap = this.currentPrice * circulatingSupply;
                    
                    this.updateTickerUI(this.currentPrice, this.priceChange24h, marketCap, parseFloat(tickerData.volume));
                } catch (error) {
                    console.error("Error fetching market data:", error);
                }
            }
            
            async fetchHistoricalData() {
                try {
                    const url = `${this.config.binanceApiBase}/klines?symbol=${this.config.symbol}&interval=${this.currentTimeframe}&limit=${this.config.historicalLimit}`;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const klines = await response.json();
                    
                    this.priceData = klines.map(k => ({
                        timestamp: k[0],
                        open: parseFloat(k[1]),
                        high: parseFloat(k[2]),
                        low: parseFloat(k[3]),
                        close: parseFloat(k[4]),
                        volume: parseFloat(k[5])
                    }));
                } catch (error) {
                    console.error('Error fetching historical data:', error);
                    this.showError('Failed to fetch historical chart data.');
                }
            }

            connectWebSocket() {
                const url = `wss://stream.binance.com:9443/ws/${this.config.symbol.toLowerCase()}@ticker`;
                this.ws = new WebSocket(url);

                this.ws.onopen = () => {
                    console.log('WebSocket connected.');
                    this.updateConnectionStatus(true);
                };

                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data && data.c) {
                        this.currentPrice = parseFloat(data.c);
                        this.priceChange24h = parseFloat(data.P);
                        this.updateTickerUI(this.currentPrice, this.priceChange24h);
                        this.updateLiveChartPoint();
                    }
                };

                this.ws.onclose = () => {
                    console.log('WebSocket disconnected. Reconnecting in 5s...');
                    this.updateConnectionStatus(false);
                    setTimeout(() => this.connectWebSocket(), 5000);
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.ws.close();
                };
            }

            // --- DATA PROCESSING AND CALCULATIONS ---

            processData() {
                if (this.priceData.length < 20) return;
                this.calculateAllIndicators();
                this.updateIndicatorUI();
                this.updateChart();
                this.updateHeuristicsAndSignals();
            }

            calculateAllIndicators() {
                const closes = this.priceData.map(p => p.close);
                const highs = this.priceData.map(p => p.high);
                const lows = this.priceData.map(p => p.low);
                const volumes = this.priceData.map(p => p.volume);

                this.indicators.sma20 = this.calculateSMA(closes, 20);
                this.indicators.ema20 = this.calculateEMA(closes, 20);
                this.indicators.bb = this.calculateBollingerBands(closes, 20, 2);
                this.indicators.rsi = this.calculateRSI(closes, 14);
                const macdResult = this.calculateMACD(closes, 12, 26, 9);
                this.indicators.macd = macdResult ? macdResult.macd : null;
                this.indicators.stoch = this.calculateStochastic(closes, highs, lows, 14);
                this.indicators.vwap = this.calculateVWAP(this.priceData);
            }

            // --- HEURISTIC ENGINE ---
            updateHeuristicsAndSignals() {
                if (Object.keys(this.indicators).length === 0) return;
                
                let score = 0;
                const i = this.indicators;

                // RSI contribution
                if (i.rsi < 30) score += (30 - i.rsi) * 1.5; // Strong buy signal
                if (i.rsi > 70) score -= (i.rsi - 70) * 1.5; // Strong sell signal

                // MACD contribution
                if (i.macd > 0) score += 10;
                if (i.macd < 0) score -= 10;

                // Bollinger Bands contribution
                if (this.currentPrice < i.bb.lower) score += 25; // Very strong buy signal
                if (this.currentPrice > i.bb.upper) score -= 25; // Very strong sell signal

                // Stochastic contribution
                if (i.stoch < 20) score += 15;
                if (i.stoch > 80) score -= 15;
                
                // Normalize score to confidence
                const confidence = Math.max(0, Math.min(100, 50 + score));
                const strength = Math.abs(score) / 100;
                
                let predictionPrice = this.currentPrice * (1 + (score / 2000)); // Predict a small move
                let outlook = "Neutral";
                let color = "#ffaa00";

                if (score > 15) {
                    outlook = "Bullish";
                    color = "#00ff88";
                } else if (score < -15) {
                    outlook = "Bearish";
                    color = "#ff4444";
                }

                this.updatePredictionUI(predictionPrice, outlook, color, confidence);
                this.updateSignalsUI();
            }

            // --- UI UPDATES ---
            updateTickerUI(price, change, marketCap, volume) {
                document.getElementById('currentPrice').textContent = `$${price.toFixed(4)}`;
                const changeEl = document.getElementById('priceChange');
                changeEl.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                changeEl.className = `price-change ${change >= 0 ? 'positive' : 'negative'}`;

                if (marketCap) document.getElementById('marketCap').textContent = this.formatLargeNumber(marketCap);
                if (volume) document.getElementById('volume24h').textContent = this.formatLargeNumber(volume);
            }

            updateIndicatorUI() {
                const format = (val, dec) => (val !== null && val !== undefined) ? val.toFixed(dec) : '...';
                document.getElementById('sma20').textContent = format(this.indicators.sma20, 4);
                document.getElementById('ema20').textContent = format(this.indicators.ema20, 4);
                document.getElementById('macd').textContent = format(this.indicators.macd, 6);
                document.getElementById('bbUpper').textContent = format(this.indicators.bb?.upper, 4);
                document.getElementById('bbLower').textContent = format(this.indicators.bb?.lower, 4);
                document.getElementById('rsi').textContent = format(this.indicators.rsi, 1);
                document.getElementById('stoch').textContent = format(this.indicators.stoch, 1);
                document.getElementById('vwap').textContent = format(this.indicators.vwap, 4);
            }

            updateChart() {
                if (!this.chart || this.priceData.length === 0) return;
                this.chart.data.labels = this.priceData.map(p => new Date(p.timestamp).toLocaleTimeString());
                this.chart.data.datasets[0].data = this.priceData.map(p => p.close);
                this.chart.update('none');
            }

            updateLiveChartPoint() {
                if (!this.chart || this.chart.data.labels.length === 0) return;
                const lastDataPoint = this.chart.data.datasets[0].data[this.chart.data.datasets[0].data.length - 1];
                if (this.currentPrice !== lastDataPoint) {
                    this.chart.data.datasets[0].data[this.chart.data.datasets[0].data.length - 1] = this.currentPrice;
                    this.chart.update('none');
                }
            }
            
            updatePredictionUI(price, outlook, color, confidence) {
                const priceEl = document.getElementById('predictionPrice');
                priceEl.textContent = `$${price.toFixed(4)} (${outlook})`;
                priceEl.style.color = color;
                document.getElementById('confidenceFill').style.width = `${confidence}%`;
                document.getElementById('confidenceText').textContent = `Confidence: ${confidence.toFixed(1)}%`;
            }

            updateSignalsUI() {
                const container = document.getElementById('signalsContainer');
                const signals = [];
                const i = this.indicators;

                if (i.rsi > 70) signals.push({ type: 'sell', title: 'RSI Overbought', desc: `Value is ${i.rsi.toFixed(1)}` });
                if (i.rsi < 30) signals.push({ type: 'buy', title: 'RSI Oversold', desc: `Value is ${i.rsi.toFixed(1)}` });
                if (this.currentPrice < i.bb?.lower) signals.push({ type: 'buy', title: 'Price Below BB', desc: 'Potential reversal' });
                if (this.currentPrice > i.bb?.upper) signals.push({ type: 'sell', title: 'Price Above BB', desc: 'Potential reversal' });
                if (i.macd > 0 && this.priceData[this.priceData.length-1].close > i.ema20) signals.push({ type: 'buy', title: 'Bullish Trend', desc: 'MACD positive & price > EMA' });
                if (i.macd < 0 && this.priceData[this.priceData.length-1].close < i.ema20) signals.push({ type: 'sell', title: 'Bearish Trend', desc: 'MACD negative & price < EMA' });

                if (signals.length === 0) {
                    container.innerHTML = `<div class="signal-item signal-hold"><div><strong>Neutral</strong><div style="font-size:11px; color:#aaa;">No strong signals detected.</div></div></div>`;
                    return;
                }

                container.innerHTML = signals.slice(0, 4).map(s => `
                    <div class="signal-item signal-${s.type}">
                        <div>
                            <div style="font-weight: bold;">${s.title}</div>
                            <div style="font-size: 11px; color: #aaa;">${s.desc}</div>
                        </div>
                    </div>
                `).join('');
            }

            updateConnectionStatus(isConnected) {
                const statusEl = document.getElementById('connectionStatus');
                const textEl = document.getElementById('connectionText');
                if (isConnected) {
                    statusEl.className = 'status-indicator status-connected';
                    textEl.textContent = 'Live';
                } else {
                    statusEl.className = 'status-indicator status-disconnected';
                    textEl.textContent = 'Disconnected';
                }
            }

            initializeEventListeners() {
                document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        this.currentTimeframe = e.target.dataset.timeframe;
                        document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        await this.fetchHistoricalData();
                        this.processData();
                    });
                });
            }

            // --- HELPERS & UTILITIES ---
            formatLargeNumber(num) {
                if (!num) return '--';
                if (num >= 1e9) return `$${(num / 1e9).toFixed(2)}B`;
                if (num >= 1e6) return `$${(num / 1e6).toFixed(2)}M`;
                if (num >= 1e3) return `$${(num / 1e3).toFixed(1)}K`;
                return `$${num.toFixed(0)}`;
            }

            showError(message) {
                document.getElementById('signalsContainer').innerHTML = `<div class="error-message">${message}</div>`;
            }

            // --- INDICATOR CALCULATION LIBRARY ---
            calculateSMA = (data, period) => {
                if (data.length < period) return null;
                return data.slice(-period).reduce((a, b) => a + b, 0) / period;
            };

            calculateEMA = (data, period) => {
                if (data.length < period) return null;
                const k = 2 / (period + 1);
                let ema = this.calculateSMA(data.slice(0, period), period);
                for (let i = period; i < data.length; i++) {
                    ema = (data[i] * k) + (ema * (1 - k));
                }
                return ema;
            };
            
            calculateBollingerBands = (data, period, stdDev) => {
                if (data.length < period) return null;
                const slice = data.slice(-period);
                const sma = this.calculateSMA(slice, period);
                const variance = slice.reduce((sum, val) => sum + Math.pow(val - sma, 2), 0) / period;
                const sd = Math.sqrt(variance);
                return { upper: sma + (sd * stdDev), middle: sma, lower: sma - (sd * stdDev) };
            };
            
            calculateRSI = (data, period) => {
                if (data.length < period + 1) return null;
                let gains = 0, losses = 0;
                for (let i = data.length - period; i < data.length; i++) {
                    const diff = data[i] - data[i - 1];
                    if (diff >= 0) { gains += diff; } else { losses -= diff; }
                }
                if (losses === 0) return 100;
                const rs = (gains / period) / (losses / period);
                return 100 - (100 / (1 + rs));
            };

            calculateMACD = (data, fast, slow, signal) => {
                if (data.length < slow) return null;
                const emaFast = this.calculateEMA(data, fast);
                const emaSlow = this.calculateEMA(data, slow);
                const macdLine = emaFast - emaSlow;
                // Simplified: just returning the macd line for display
                return { macd: macdLine };
            };
            
            calculateStochastic = (closes, highs, lows, period) => {
                if (closes.length < period) return null;
                const relevantLows = lows.slice(-period);
                const relevantHighs = highs.slice(-period);
                const lowestLow = Math.min(...relevantLows);
                const highestHigh = Math.max(...relevantHighs);
                const currentClose = closes[closes.length - 1];
                return ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
            };
            
            calculateVWAP = (data) => {
                if (data.length < 1) return null;
                const recentData = data.slice(-20); // VWAP on last 20 periods
                const totalPV = recentData.reduce((sum, p) => sum + (((p.high + p.low + p.close) / 3) * p.volume), 0);
                const totalVolume = recentData.reduce((sum, p) => sum + p.volume, 0);
                return totalVolume === 0 ? null : totalPV / totalVolume;
            };
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.dashboard = new WIFDashboard();
            window.dashboard.initialize();
        });
    </script>
</body>
</html>
