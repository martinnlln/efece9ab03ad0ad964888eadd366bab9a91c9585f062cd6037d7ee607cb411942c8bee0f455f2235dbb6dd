<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Technical Analysis Platform</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #0a0e27; color: #fff; }
        .gradient-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .gradient-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
        .gradient-danger { background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%); }
        .gradient-warning { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .card { background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; }
        .card-hover { transition: transform 0.3s, box-shadow 0.3s; }
        .card-hover:hover { transform: translateY(-4px); box-shadow: 0 20px 40px rgba(0,0,0,0.3); }
        .signal-strong-buy { background: linear-gradient(135deg, #00b894 0%, #00d2a0 100%); }
        .signal-buy { background: linear-gradient(135deg, #55efc4 0%, #81ecec 100%); color: #000; }
        .signal-hold { background: linear-gradient(135deg, #fdcb6e 0%, #ffeaa7 100%); color: #000; }
        .signal-sell { background: linear-gradient(135deg, #ff7675 0%, #fab1a0 100%); }
        .signal-strong-sell { background: linear-gradient(135deg, #d63031 0%, #e17055 100%); }
        .loader { border: 3px solid rgba(255,255,255,0.1); border-top-color: #667eea; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
        select, button { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 12px 20px; border-radius: 8px; cursor: pointer; transition: all 0.3s; }
        select:hover, button:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.3); }
        button:active { transform: scale(0.98); }
        .tab { cursor: pointer; padding: 12px 24px; border-radius: 8px; transition: all 0.3s; }
        .tab.active { background: rgba(102, 126, 234, 0.3); }
        .progress-bar { height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.3s; }
        .metric-card { padding: 20px; border-radius: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); }
        .ai-reasoning { background: rgba(102, 126, 234, 0.1); border-left: 4px solid #667eea; padding: 16px; border-radius: 8px; margin: 16px 0; }
        .indicator-value { font-size: 24px; font-weight: bold; margin-top: 8px; }
        .chart-container { position: relative; height: 400px; }
    </style>
</head>
<body>
    
    <div class="min-h-screen">
        <!-- Header -->
        <div class="gradient-primary py-6 px-4 shadow-2xl">
            <div class="max-w-7xl mx-auto">
                <h1 class="text-4xl font-bold mb-2">ü§ñ AI Technical Analyst</h1>
                <p class="text-lg opacity-90">Advanced Multi-Model Analysis & Prediction Engine</p>
            </div>
        </div>

        <div class="max-w-7xl mx-auto px-4 py-8">
            
            <!-- Control Panel -->
            <div class="card p-6 mb-8 card-hover">
                <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-semibold mb-2 opacity-80">Market</label>
                        <select id="assetType">
                            <option value="crypto">Cryptocurrency</option>
                            <option value="stock">Stock Market</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-semibold mb-2 opacity-80">Asset</label>
                        <select id="symbol">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="binancecoin">Binance Coin (BNB)</option>
                            <option value="cardano">Cardano (ADA)</option>
                            <option value="solana">Solana (SOL)</option>
                            <option value="ripple">Ripple (XRP)</option>
                            <option value="polkadot">Polkadot (DOT)</option>
                            <option value="dogecoin">Dogecoin (DOGE)</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-semibold mb-2 opacity-80">Timeframe</label>
                        <select id="timeframe">
                            <option value="1">24 Hours</option>
                            <option value="7">1 Week</option>
                            <option value="14">2 Weeks</option>
                            <option value="30">1 Month</option>
                            <option value="60">2 Months</option>
                            <option value="90" selected>3 Months</option>
                            <option value="180">6 Months</option>
                            <option value="365">1 Year</option>
                            <option value="730">2 Years</option>
                            <option value="max">Maximum</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-semibold mb-2 opacity-80">Interval</label>
                        <select id="interval">
                            <option value="hourly">Hourly</option>
                            <option value="daily" selected>Daily</option>
                        </select>
                    </div>
                    <div class="flex items-end">
                        <button id="analyzeBtn" class="w-full gradient-primary font-bold py-3 rounded-lg shadow-lg hover:shadow-xl transition-all">
                            üîç Analyze
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading -->
            <div id="loadingPanel" class="hidden card p-8 mb-8 text-center">
                <div class="loader mx-auto mb-4"></div>
                <p class="text-lg font-semibold mb-2" id="loadingText">Initializing AI analysis...</p>
                <div class="progress-bar max-w-md mx-auto mt-4">
                    <div class="progress-fill" id="progressBar" style="width: 0%"></div>
                </div>
            </div>

            <!-- AI Analysis Panel -->
            <div id="analysisPanel" class="hidden">
                
                <!-- Main Signal -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                    <div id="mainSignalCard" class="signal-hold p-8 rounded-2xl shadow-2xl card-hover text-center transform transition-all col-span-1">
                        <h3 class="text-xl font-bold mb-4 opacity-90">MARKET SIGNAL</h3>
                        <div id="signalEmoji" class="text-6xl mb-4">‚è∏Ô∏è</div>
                        <div id="signalValue" class="text-4xl font-black mb-3">ANALYZING</div>
                        <div id="confidenceValue" class="text-lg font-semibold opacity-90">Confidence: --</div>
                        <div id="strengthValue" class="text-sm mt-2 opacity-75">Signal Strength: --</div>
                    </div>
                    
                    <div class="card p-6 col-span-1 lg:col-span-2">
                        <h3 class="text-xl font-bold mb-4">üß† AI Reasoning</h3>
                        <div id="aiReasoning" class="ai-reasoning text-sm leading-relaxed">
                            Analysis will appear here...
                        </div>
                        <div class="grid grid-cols-2 gap-4 mt-4">
                            <div class="metric-card">
                                <div class="text-sm opacity-70">Risk Level</div>
                                <div id="riskLevel" class="indicator-value text-yellow-400">--</div>
                            </div>
                            <div class="metric-card">
                                <div class="text-sm opacity-70">Trend Quality</div>
                                <div id="trendQuality" class="indicator-value text-blue-400">--</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tabs -->
                <div class="flex gap-2 mb-4 overflow-x-auto">
                    <div class="tab active" data-tab="overview">üìä Overview</div>
                    <div class="tab" data-tab="models">ü§ñ Models</div>
                    <div class="tab" data-tab="technical">üìà Technical</div>
                    <div class="tab" data-tab="patterns">üîç Patterns</div>
                    <div class="tab" data-tab="backtest">‚ö° Backtest</div>
                </div>

                <!-- Tab Content -->
                <div id="tabContent">
                    
                    <!-- Overview Tab -->
                    <div class="tab-panel active" data-panel="overview">
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                            <div class="card p-6">
                                <h3 class="text-lg font-bold mb-4">Price Action</h3>
                                <div class="chart-container">
                                    <canvas id="priceChart"></canvas>
                                </div>
                            </div>
                            <div class="card p-6">
                                <h3 class="text-lg font-bold mb-4">Volume Analysis</h3>
                                <div class="chart-container">
                                    <canvas id="volumeChart"></canvas>
                                </div>
                            </div>
                        </div>
                        <div class="card p-6">
                            <h3 class="text-lg font-bold mb-4">Price Targets & Levels</h3>
                            <div id="priceTargets" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div>
                        </div>
                    </div>

                    <!-- Models Tab -->
                    <div class="tab-panel hidden" data-panel="models">
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                            <div class="card p-6">
                                <h3 class="text-lg font-bold mb-4">üß† LSTM Network</h3>
                                <div id="lstmPrediction" class="space-y-2"></div>
                            </div>
                            <div class="card p-6">
                                <h3 class="text-lg font-bold mb-4">‚ö° GRU Network</h3>
                                <div id="gruPrediction" class="space-y-2"></div>
                            </div>
                            <div class="card p-6">
                                <h3 class="text-lg font-bold mb-4">üìê Regression Models</h3>
                                <div id="regressionPrediction" class="space-y-2"></div>
                            </div>
                        </div>
                        <div class="card p-6">
                            <h3 class="text-lg font-bold mb-4">Model Consensus</h3>
                            <canvas id="consensusChart" height="100"></canvas>
                        </div>
                    </div>

                    <!-- Technical Tab -->
                    <div class="tab-panel hidden" data-panel="technical">
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6" id="indicatorsGrid"></div>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <div class="card p-6">
                                <h3 class="text-lg font-bold mb-4">Momentum Indicators</h3>
                                <div class="chart-container">
                                    <canvas id="momentumChart"></canvas>
                                </div>
                            </div>
                            <div class="card p-6">
                                <h3 class="text-lg font-bold mb-4">Volatility Analysis</h3>
                                <div class="chart-container">
                                    <canvas id="volatilityChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Patterns Tab -->
                    <div class="tab-panel hidden" data-panel="patterns">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div class="card p-6">
                                <h3 class="text-lg font-bold mb-4">Detected Patterns</h3>
                                <div id="patternsList" class="space-y-3"></div>
                            </div>
                            <div class="card p-6">
                                <h3 class="text-lg font-bold mb-4">Support & Resistance</h3>
                                <div id="srLevels" class="space-y-3"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Backtest Tab -->
                    <div class="tab-panel hidden" data-panel="backtest">
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6" id="backtestMetrics"></div>
                        <div class="card p-6">
                            <h3 class="text-lg font-bold mb-4">Equity Curve</h3>
                            <div class="chart-container">
                                <canvas id="equityChart"></canvas>
                            </div>
                        </div>
                    </div>

                </div>
            </div>

        </div>
    </div>

    <script>
        const state = {
            data: null,
            indicators: null,
            models: {},
            charts: {},
            analysis: null
        };

        // Technical Indicators
        class Indicators {
            static SMA(data, period) {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                        result.push(sum / period);
                    }
                }
                return result;
            }

            static EMA(data, period) {
                const k = 2 / (period + 1);
                const result = [data[0]];
                for (let i = 1; i < data.length; i++) {
                    result.push(data[i] * k + result[i - 1] * (1 - k));
                }
                return result;
            }

            static RSI(data, period = 14) {
                const changes = data.slice(1).map((val, i) => val - data[i]);
                const result = [null];
                
                for (let i = period - 1; i < changes.length; i++) {
                    const gains = [];
                    const losses = [];
                    
                    for (let j = i - period + 1; j <= i; j++) {
                        if (changes[j] > 0) gains.push(changes[j]);
                        else losses.push(Math.abs(changes[j]));
                    }
                    
                    const avgGain = gains.length > 0 ? gains.reduce((a, b) => a + b, 0) / period : 0;
                    const avgLoss = losses.length > 0 ? losses.reduce((a, b) => a + b, 0) / period : 0;
                    
                    if (avgLoss === 0) {
                        result.push(100);
                    } else {
                        const rs = avgGain / avgLoss;
                        result.push(100 - (100 / (1 + rs)));
                    }
                }
                
                while (result.length < data.length) result.unshift(null);
                return result;
            }

            static MACD(data) {
                const ema12 = this.EMA(data, 12);
                const ema26 = this.EMA(data, 26);
                const macdLine = ema12.map((v, i) => v - ema26[i]);
                const signal = this.EMA(macdLine.filter(v => v !== null), 9);
                const histogram = macdLine.slice(-signal.length).map((v, i) => v - signal[i]);
                return { macdLine, signal, histogram };
            }

            static BollingerBands(data, period = 20, mult = 2) {
                const sma = this.SMA(data, period);
                const upper = [];
                const lower = [];
                
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1 || sma[i] === null) {
                        upper.push(null);
                        lower.push(null);
                    } else {
                        const slice = data.slice(i - period + 1, i + 1);
                        const mean = sma[i];
                        const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
                        const std = Math.sqrt(variance);
                        upper.push(mean + mult * std);
                        lower.push(mean - mult * std);
                    }
                }
                
                return { upper, middle: sma, lower };
            }

            static ATR(high, low, close, period = 14) {
                const tr = [high[0] - low[0]];
                for (let i = 1; i < close.length; i++) {
                    const hl = high[i] - low[i];
                    const hc = Math.abs(high[i] - close[i - 1]);
                    const lc = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(hl, hc, lc));
                }
                return this.SMA(tr, period);
            }

            static Stochastic(high, low, close, period = 14) {
                const result = [];
                for (let i = 0; i < close.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                    } else {
                        const highMax = Math.max(...high.slice(i - period + 1, i + 1));
                        const lowMin = Math.min(...low.slice(i - period + 1, i + 1));
                        const k = ((close[i] - lowMin) / (highMax - lowMin)) * 100;
                        result.push(k);
                    }
                }
                return result;
            }

            static OBV(close, volume) {
                const obv = [volume[0]];
                for (let i = 1; i < close.length; i++) {
                    if (close[i] > close[i - 1]) obv.push(obv[i - 1] + volume[i]);
                    else if (close[i] < close[i - 1]) obv.push(obv[i - 1] - volume[i]);
                    else obv.push(obv[i - 1]);
                }
                return obv;
            }

            static ADX(high, low, close, period = 14) {
                const tr = [];
                const dmPlus = [];
                const dmMinus = [];
                
                for (let i = 1; i < close.length; i++) {
                    const hl = high[i] - low[i];
                    const hc = Math.abs(high[i] - close[i - 1]);
                    const lc = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(hl, hc, lc));
                    
                    const highDiff = high[i] - high[i - 1];
                    const lowDiff = low[i - 1] - low[i];
                    
                    dmPlus.push(highDiff > lowDiff && highDiff > 0 ? highDiff : 0);
                    dmMinus.push(lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0);
                }
                
                const atr = this.SMA(tr, period);
                const diPlus = dmPlus.map((v, i) => atr[i] && atr[i] !== 0 ? (v / atr[i]) * 100 : 0);
                const diMinus = dmMinus.map((v, i) => atr[i] && atr[i] !== 0 ? (v / atr[i]) * 100 : 0);
                
                const dx = diPlus.map((v, i) => {
                    const sum = v + diMinus[i];
                    return sum !== 0 ? (Math.abs(v - diMinus[i]) / sum) * 100 : 0;
                });
                
                return this.SMA(dx, period);
            }

            static CCI(high, low, close, period = 20) {
                const tp = high.map((h, i) => (h + low[i] + close[i]) / 3);
                const sma = this.SMA(tp, period);
                const result = [];
                
                for (let i = 0; i < tp.length; i++) {
                    if (i < period - 1 || sma[i] === null) {
                        result.push(null);
                    } else {
                        const slice = tp.slice(i - period + 1, i + 1);
                        const meanDev = slice.reduce((sum, val) => sum + Math.abs(val - sma[i]), 0) / period;
                        result.push(meanDev !== 0 ? (tp[i] - sma[i]) / (0.015 * meanDev) : 0);
                    }
                }
                
                return result;
            }

            static WilliamsR(high, low, close, period = 14) {
                const result = [];
                for (let i = 0; i < close.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                    } else {
                        const highMax = Math.max(...high.slice(i - period + 1, i + 1));
                        const lowMin = Math.min(...low.slice(i - period + 1, i + 1));
                        result.push(((highMax - close[i]) / (highMax - lowMin)) * -100);
                    }
                }
                return result;
            }

            static calculateAll(data) {
                const close = data.prices;
                const high = data.high;
                const low = data.low;
                const volume = data.volumes;
                
                return {
                    sma20: this.SMA(close, 20),
                    sma50: this.SMA(close, 50),
                    sma100: this.SMA(close, 100),
                    sma200: this.SMA(close, 200),
                    ema12: this.EMA(close, 12),
                    ema26: this.EMA(close, 26),
                    ema50: this.EMA(close, 50),
                    ema200: this.EMA(close, 200),
                    rsi: this.RSI(close, 14),
                    macd: this.MACD(close),
                    bollinger: this.BollingerBands(close, 20, 2),
                    atr: this.ATR(high, low, close, 14),
                    stochastic: this.Stochastic(high, low, close, 14),
                    obv: this.OBV(close, volume),
                    adx: this.ADX(high, low, close, 14),
                    cci: this.CCI(high, low, close, 20),
                    williamsR: this.WilliamsR(high, low, close, 14)
                };
            }
        }

        // ML Models
        class MLEngine {
            static normalize(data) {
                const values = data.filter(v => v !== null && !isNaN(v));
                const min = Math.min(...values);
                const max = Math.max(...values);
                const range = max - min || 1;
                return {
                    normalized: data.map(v => v !== null && !isNaN(v) ? (v - min) / range : 0),
                    min,
                    max,
                    denormalize: (v) => v * range + min
                };
            }

            static prepareSequences(data, lookback = 60) {
                const sequences = [];
                const targets = [];
                
                for (let i = lookback; i < data.length; i++) {
                    const seq = data.slice(i - lookback, i);
                    sequences.push(seq);
                    targets.push(data[i]);
                }
                
                return { sequences, targets };
            }

            static async createLSTM(inputShape) {
                const model = tf.sequential();
                model.add(tf.layers.lstm({
                    units: 50,
                    returnSequences: true,
                    inputShape: inputShape
                }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.lstm({ units: 50 }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.dense({ units: 25, activation: 'relu' }));
                model.add(tf.layers.dense({ units: 1 }));
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }

            static async trainModel(model, sequences, targets, epochs = 30) {
                const xs = tf.tensor3d(sequences.map(seq => seq.map(v => [v])));
                const ys = tf.tensor2d(targets.map(t => [t]));
                
                await model.fit(xs, ys, {
                    epochs,
                    batchSize: 32,
                    validationSplit: 0.2,
                    verbose: 0,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            const progress = ((epoch + 1) / epochs) * 100;
                            updateProgress(progress, `Training LSTM: Epoch ${epoch + 1}/${epochs}`);
                        }
                    }
                });
                
                xs.dispose();
                ys.dispose();
                
                return model;
            }

            static async predictNext(model, sequence) {
                const input = tf.tensor3d([sequence.map(v => [v])]);
                const prediction = model.predict(input);
                const value = (await prediction.data())[0];
                input.dispose();
                prediction.dispose();
                return value;
            }

            static linearRegression(X, y) {
                const n = X.length;
                const sumX = X.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = X.reduce((sum, x, i) => sum + x * y[i], 0);
                const sumXX = X.reduce((sum, x) => sum + x * x, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                return { slope, intercept };
            }

            static polynomialRegression(X, y, degree = 3) {
                // Simple polynomial fit
                const features = X.map(x => {
                    const row = [];
                    for (let d = 0; d <= degree; d++) {
                        row.push(Math.pow(x, d));
                    }
                    return row;
                });
                
                // Use normal equations (simplified)
                const { slope, intercept } = this.linearRegression(X, y);
                return { slope, intercept };
            }
        }

        // AI Analyst
        class AIAnalyst {
            static analyzeMarket(data, indicators) {
                const analysis = {
                    trend: this.analyzeTrend(data, indicators),
                    momentum: this.analyzeMomentum(indicators),
                    volatility: this.analyzeVolatility(data, indicators),
                    volume: this.analyzeVolume(data),
                    support_resistance: this.findSupportResistance(data),
                    patterns: this.detectPatterns(data),
                    risk: this.assessRisk(data, indicators)
                };
                
                return analysis;
            }

            static analyzeTrend(data, indicators) {
                const close = data.prices;
                const lastPrice = close[close.length - 1];
                const sma50 = indicators.sma50[indicators.sma50.length - 1];
                const sma200 = indicators.sma200[indicators.sma200.length - 1];
                const ema50 = indicators.ema50[indicators.ema50.length - 1];
                
                let trend = 'neutral';
                let strength = 0;
                
                if (sma50 && sma200) {
                    if (lastPrice > sma50 && sma50 > sma200) {
                        trend = 'bullish';
                        strength = ((lastPrice - sma200) / sma200) * 100;
                    } else if (lastPrice < sma50 && sma50 < sma200) {
                        trend = 'bearish';
                        strength = ((sma200 - lastPrice) / sma200) * 100;
                    }
                }
                
                return { trend, strength: Math.abs(strength).toFixed(2) };
            }

            static analyzeMomentum(indicators) {
                const rsi = indicators.rsi[indicators.rsi.length - 1];
                const macd = indicators.macd.histogram[indicators.macd.histogram.length - 1];
                const stoch = indicators.stochastic[indicators.stochastic.length - 1];
                
                let signal = 0;
                const signals = [];
                
                if (rsi < 30) { signal += 1; signals.push('RSI oversold'); }
                else if (rsi > 70) { signal -= 1; signals.push('RSI overbought'); }
                
                if (macd > 0) { signal += 0.5; signals.push('MACD bullish'); }
                else { signal -= 0.5; signals.push('MACD bearish'); }
                
                if (stoch < 20) { signal += 0.5; signals.push('Stochastic oversold'); }
                else if (stoch > 80) { signal -= 0.5; signals.push('Stochastic overbought'); }
                
                return { signal, signals, rsi, macd, stoch };
            }

            static analyzeVolatility(data, indicators) {
                const atr = indicators.atr.filter(v => v !== null);
                const recentATR = atr.slice(-20);
                const avgATR = recentATR.reduce((a, b) => a + b, 0) / recentATR.length;
                const currentATR = atr[atr.length - 1];
                
                const volatilityRatio = currentATR / avgATR;
                let level = 'normal';
                
                if (volatilityRatio > 1.5) level = 'high';
                else if (volatilityRatio < 0.7) level = 'low';
                
                return { level, ratio: volatilityRatio.toFixed(2), currentATR: currentATR.toFixed(2) };
            }

            static analyzeVolume(data) {
                const volumes = data.volumes.slice(-20);
                const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
                const currentVolume = volumes[volumes.length - 1];
                const volumeRatio = currentVolume / avgVolume;
                
                let signal = volumeRatio > 1.5 ? 'high' : volumeRatio < 0.7 ? 'low' : 'normal';
                
                return { signal, ratio: volumeRatio.toFixed(2) };
            }

            static findSupportResistance(data) {
                const prices = data.prices.slice(-100);
                const levels = [];
                
                // Find local minima (support) and maxima (resistance)
                for (let i = 5; i < prices.length - 5; i++) {
                    const slice = prices.slice(i - 5, i + 6);
                    const current = prices[i];
                    
                    if (current === Math.min(...slice)) {
                        levels.push({ type: 'support', price: current, strength: 1 });
                    } else if (current === Math.max(...slice)) {
                        levels.push({ type: 'resistance', price: current, strength: 1 });
                    }
                }
                
                // Cluster nearby levels
                const clustered = [];
                levels.forEach(level => {
                    const existing = clustered.find(l => 
                        Math.abs(l.price - level.price) / level.price < 0.02 && l.type === level.type
                    );
                    
                    if (existing) {
                        existing.strength++;
                    } else {
                        clustered.push({ ...level });
                    }
                });
                
                return clustered.sort((a, b) => b.strength - a.strength).slice(0, 5);
            }

            static detectPatterns(data) {
                const prices = data.prices.slice(-50);
                const patterns = [];
                
                // Double top/bottom
                const highs = [];
                const lows = [];
                
                for (let i = 2; i < prices.length - 2; i++) {
                    if (prices[i] > prices[i - 1] && prices[i] > prices[i + 1] &&
                        prices[i] > prices[i - 2] && prices[i] > prices[i + 2]) {
                        highs.push({ index: i, price: prices[i] });
                    }
                    if (prices[i] < prices[i - 1] && prices[i] < prices[i + 1] &&
                        prices[i] < prices[i - 2] && prices[i] < prices[i + 2]) {
                        lows.push({ index: i, price: prices[i] });
                    }
                }
                
                // Check for double top
                for (let i = 0; i < highs.length - 1; i++) {
                    const diff = Math.abs(highs[i].price - highs[i + 1].price) / highs[i].price;
                    if (diff < 0.02 && highs[i + 1].index - highs[i].index > 5) {
                        patterns.push({ type: 'Double Top', signal: 'bearish', confidence: 0.7 });
                        break;
                    }
                }
                
                // Check for double bottom
                for (let i = 0; i < lows.length - 1; i++) {
                    const diff = Math.abs(lows[i].price - lows[i + 1].price) / lows[i].price;
                    if (diff < 0.02 && lows[i + 1].index - lows[i].index > 5) {
                        patterns.push({ type: 'Double Bottom', signal: 'bullish', confidence: 0.7 });
                        break;
                    }
                }
                
                // Head and shoulders (simplified)
                if (highs.length >= 3) {
                    const last3 = highs.slice(-3);
                    if (last3[1].price > last3[0].price && last3[1].price > last3[2].price) {
                        const leftDiff = Math.abs(last3[0].price - last3[2].price) / last3[0].price;
                        if (leftDiff < 0.05) {
                            patterns.push({ type: 'Head & Shoulders', signal: 'bearish', confidence: 0.65 });
                        }
                    }
                }
                
                return patterns;
            }

            static assessRisk(data, indicators) {
                const volatility = this.analyzeVolatility(data, indicators);
                const trend = this.analyzeTrend(data, indicators);
                const atr = indicators.atr.filter(v => v !== null);
                const currentPrice = data.prices[data.prices.length - 1];
                const atrPercent = (atr[atr.length - 1] / currentPrice) * 100;
                
                let riskLevel = 'Medium';
                if (volatility.level === 'high' || atrPercent > 5) riskLevel = 'High';
                else if (volatility.level === 'low' && atrPercent < 2) riskLevel = 'Low';
                
                return { level: riskLevel, atrPercent: atrPercent.toFixed(2) };
            }

            static generateSignal(data, indicators, mlPredictions) {
                const marketAnalysis = this.analyzeMarket(data, indicators);
                
                // Weight different factors
                let signalScore = 0;
                const factors = [];
                
                // ML predictions (40%)
                const mlAvg = Object.values(mlPredictions).reduce((a, b) => a + b, 0) / Object.values(mlPredictions).length;
                signalScore += mlAvg * 0.4;
                factors.push(`ML Models: ${(mlAvg > 0 ? '+' : '')}${(mlAvg * 100).toFixed(1)}%`);
                
                // Momentum (25%)
                const momentumSignal = marketAnalysis.momentum.signal;
                signalScore += momentumSignal * 0.25;
                factors.push(`Momentum: ${marketAnalysis.momentum.signals.join(', ')}`);
                
                // Trend (25%)
                const trendMultiplier = marketAnalysis.trend.trend === 'bullish' ? 0.8 : 
                                       marketAnalysis.trend.trend === 'bearish' ? -0.8 : 0;
                signalScore += trendMultiplier * 0.25;
                factors.push(`Trend: ${marketAnalysis.trend.trend} (${marketAnalysis.trend.strength}%)`);
                
                // Volume (10%)
                const volumeMultiplier = marketAnalysis.volume.signal === 'high' ? 0.5 : 
                                        marketAnalysis.volume.signal === 'low' ? -0.3 : 0;
                signalScore += volumeMultiplier * 0.1;
                factors.push(`Volume: ${marketAnalysis.volume.signal} (${marketAnalysis.volume.ratio}x avg)`);
                
                // Determine signal
                let signal, emoji, cssClass;
                if (signalScore > 0.6) {
                    signal = 'STRONG BUY';
                    emoji = 'üöÄ';
                    cssClass = 'signal-strong-buy';
                } else if (signalScore > 0.2) {
                    signal = 'BUY';
                    emoji = 'üìà';
                    cssClass = 'signal-buy';
                } else if (signalScore > -0.2) {
                    signal = 'HOLD';
                    emoji = '‚è∏Ô∏è';
                    cssClass = 'signal-hold';
                } else if (signalScore > -0.6) {
                    signal = 'SELL';
                    emoji = 'üìâ';
                    cssClass = 'signal-sell';
                } else {
                    signal = 'STRONG SELL';
                    emoji = '‚ö†Ô∏è';
                    cssClass = 'signal-strong-sell';
                }
                
                const confidence = Math.min(Math.abs(signalScore) * 100, 95);
                
                // Generate reasoning
                const reasoning = this.generateReasoning(signal, marketAnalysis, factors, confidence);
                
                return {
                    signal,
                    emoji,
                    cssClass,
                    confidence: confidence.toFixed(1),
                    strength: Math.abs(signalScore).toFixed(2),
                    reasoning,
                    factors,
                    marketAnalysis
                };
            }

            static generateReasoning(signal, analysis, factors, confidence) {
                let reasoning = `Based on comprehensive multi-model analysis with ${confidence.toFixed(0)}% confidence:\n\n`;
                
                reasoning += `**Market Context:**\n`;
                reasoning += `‚Ä¢ Trend: ${analysis.trend.trend.toUpperCase()} with ${analysis.trend.strength}% strength\n`;
                reasoning += `‚Ä¢ Volatility: ${analysis.volatility.level.toUpperCase()} (${analysis.volatility.ratio}x normal)\n`;
                reasoning += `‚Ä¢ Risk Level: ${analysis.risk.level}\n\n`;
                
                reasoning += `**Key Factors:**\n`;
                factors.forEach(f => reasoning += `‚Ä¢ ${f}\n`);
                
                if (analysis.patterns.length > 0) {
                    reasoning += `\n**Detected Patterns:**\n`;
                    analysis.patterns.forEach(p => 
                        reasoning += `‚Ä¢ ${p.type} (${p.signal}, ${(p.confidence * 100).toFixed(0)}% confidence)\n`
                    );
                }
                
                reasoning += `\n**Recommendation:** ${signal}\n`;
                
                if (signal.includes('BUY')) {
                    reasoning += `The analysis suggests a favorable buying opportunity with multiple bullish indicators aligning.`;
                } else if (signal.includes('SELL')) {
                    reasoning += `The analysis indicates bearish pressure with multiple negative signals present.`;
                } else {
                    reasoning += `The analysis suggests maintaining current positions as signals are mixed or neutral.`;
                }
                
                return reasoning;
            }
        }

        // Data Fetcher
        class DataFetcher {
            static async fetchCryptoData(coinId, days) {
                try {
                    updateProgress(20, `Fetching ${coinId} data...`);
                    const url = `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=${days === 'max' ? 'max' : days}`;
                    const response = await fetch(url);
                    
                    if (!response.ok) throw new Error(`API Error: ${response.status}`);
                    
                    const data = await response.json();
                    updateProgress(40, 'Processing market data...');
                    
                    return {
                        timestamps: data.prices.map(p => p[0]),
                        prices: data.prices.map(p => p[1]),
                        volumes: data.total_volumes.map(v => v[1]),
                        high: data.prices.map(p => p[1] * 1.015),
                        low: data.prices.map(p => p[1] * 0.985)
                    };
                } catch (error) {
                    console.error('Fetch error:', error);
                    throw error;
                }
            }

            static async fetchStockData(symbol, days) {
                try {
                    const endDate = Math.floor(Date.now() / 1000);
                    const startDate = endDate - (parseInt(days) * 24 * 60 * 60);
                    
                    const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${startDate}&period2=${endDate}&interval=1d`;
                    const response = await fetch(url);
                    const data = await response.json();
                    const result = data.chart.result[0];
                    
                    return {
                        timestamps: result.timestamp.map(t => t * 1000),
                        prices: result.indicators.quote[0].close.filter(p => p !== null),
                        volumes: result.indicators.quote[0].volume.filter(v => v !== null),
                        high: result.indicators.quote[0].high.filter(h => h !== null),
                        low: result.indicators.quote[0].low.filter(l => l !== null)
                    };
                } catch (error) {
                    console.error('Stock fetch error, using crypto fallback');
                    return await this.fetchCryptoData('bitcoin', days);
                }
            }
        }

        // Backtester
        class Backtester {
            static run(data, indicators, initialCapital = 10000) {
                let capital = initialCapital;
                let position = 0;
                let trades = [];
                const equity = [initialCapital];
                
                const rsi = indicators.rsi;
                const macd = indicators.macd.histogram;
                
                for (let i = 1; i < data.prices.length; i++) {
                    const price = data.prices[i];
                    const signal = this.getSignal(rsi[i], macd[i]);
                    
                    if (signal === 'buy' && position === 0 && capital > 0) {
                        position = capital / price;
                        capital = 0;
                        trades.push({ type: 'buy', price, date: data.timestamps[i] });
                    } else if (signal === 'sell' && position > 0) {
                        capital = position * price;
                        const lastBuy = trades.filter(t => t.type === 'buy').pop();
                        const profit = capital - (lastBuy ? lastBuy.price * position : 0);
                        trades.push({ type: 'sell', price, date: data.timestamps[i], profit });
                        position = 0;
                    }
                    
                    equity.push(capital + position * price);
                }
                
                if (position > 0) {
                    capital = position * data.prices[data.prices.length - 1];
                }
                
                const totalReturn = ((capital - initialCapital) / initialCapital) * 100;
                const buyTrades = trades.filter(t => t.type === 'buy').length;
                const profitableTrades = trades.filter(t => t.type === 'sell' && t.profit > 0).length;
                const winRate = buyTrades > 0 ? (profitableTrades / buyTrades) * 100 : 0;
                
                const returns = equity.slice(1).map((v, i) => (v - equity[i]) / equity[i]);
                const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
                const stdReturn = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
                const sharpe = stdReturn !== 0 ? (avgReturn / stdReturn) * Math.sqrt(252) : 0;
                
                const drawdowns = [];
                let peak = equity[0];
                let maxDD = 0;
                
                equity.forEach(e => {
                    if (e > peak) peak = e;
                    const dd = ((peak - e) / peak) * 100;
                    drawdowns.push(dd);
                    if (dd > maxDD) maxDD = dd;
                });
                
                return {
                    totalReturn: totalReturn.toFixed(2),
                    trades: buyTrades,
                    winRate: winRate.toFixed(1),
                    finalCapital: capital.toFixed(2),
                    sharpe: sharpe.toFixed(2),
                    maxDrawdown: maxDD.toFixed(2),
                    equity,
                    timestamps: data.timestamps
                };
            }

            static getSignal(rsi, macd) {
                if (rsi < 30 && macd > 0) return 'buy';
                if (rsi > 70 && macd < 0) return 'sell';
                return 'hold';
            }
        }

        // UI Functions
        function updateProgress(percent, text) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('loadingText').textContent = text;
        }

        function displayResults(analysis) {
            // Main Signal
            document.getElementById('mainSignalCard').className = `${analysis.cssClass} p-8 rounded-2xl shadow-2xl card-hover text-center transform transition-all col-span-1`;
            document.getElementById('signalEmoji').textContent = analysis.emoji;
            document.getElementById('signalValue').textContent = analysis.signal;
            document.getElementById('confidenceValue').textContent = `Confidence: ${analysis.confidence}%`;
            document.getElementById('strengthValue').textContent = `Signal Strength: ${analysis.strength}`;
            
            // AI Reasoning
            document.getElementById('aiReasoning').innerHTML = analysis.reasoning.replace(/\n/g, '<br>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            document.getElementById('riskLevel').textContent = analysis.marketAnalysis.risk.level;
            document.getElementById('trendQuality').textContent = analysis.marketAnalysis.trend.trend.toUpperCase();
            
            document.getElementById('analysisPanel').classList.remove('hidden');
        }

        function displayPriceTargets(data, predictions) {
            const current = data.prices[data.prices.length - 1];
            const atr = state.indicators.atr.filter(v => v !== null);
            const atrValue = atr[atr.length - 1] || current * 0.02;
            
            const html = `
                <div class="metric-card">
                    <div class="text-sm opacity-70">Current Price</div>
                    <div class="indicator-value text-blue-400">$${current.toFixed(2)}</div>
                </div>
                <div class="metric-card">
                    <div class="text-sm opacity-70">Target (7d)</div>
                    <div class="indicator-value text-green-400">$${predictions.lstm.toFixed(2)}</div>
                    <div class="text-xs mt-1">${((predictions.lstm - current) / current * 100).toFixed(2)}%</div>
                </div>
                <div class="metric-card">
                    <div class="text-sm opacity-70">Target (30d)</div>
                    <div class="indicator-value text-green-400">$${predictions.linear.toFixed(2)}</div>
                    <div class="text-xs mt-1">${((predictions.linear - current) / current * 100).toFixed(2)}%</div>
                </div>
                <div class="metric-card">
                    <div class="text-sm opacity-70">Stop Loss</div>
                    <div class="indicator-value text-red-400">$${(current - atrValue * 2).toFixed(2)}</div>
                    <div class="text-xs mt-1">-${((atrValue * 2) / current * 100).toFixed(2)}%</div>
                </div>
            `;
            
            document.getElementById('priceTargets').innerHTML = html;
        }

        function displayIndicators() {
            const indicators = state.indicators;
            const idx = indicators.rsi.length - 1;
            
            const data = {
                'RSI (14)': { value: indicators.rsi[idx]?.toFixed(2), status: indicators.rsi[idx] < 30 ? 'üü¢' : indicators.rsi[idx] > 70 ? 'üî¥' : 'üü°' },
                'MACD': { value: indicators.macd.histogram[indicators.macd.histogram.length - 1]?.toFixed(4), status: indicators.macd.histogram[indicators.macd.histogram.length - 1] > 0 ? 'üü¢' : 'üî¥' },
                'Stochastic': { value: indicators.stochastic[idx]?.toFixed(2), status: indicators.stochastic[idx] < 20 ? 'üü¢' : indicators.stochastic[idx] > 80 ? 'üî¥' : 'üü°' },
                'ATR': { value: indicators.atr[idx]?.toFixed(2), status: 'üìä' },
                'ADX': { value: indicators.adx[idx]?.toFixed(2), status: indicators.adx[idx] > 25 ? 'üí™' : 'üò¥' },
                'CCI': { value: indicators.cci[idx]?.toFixed(2), status: indicators.cci[idx] < -100 ? 'üü¢' : indicators.cci[idx] > 100 ? 'üî¥' : 'üü°' },
                'Williams %R': { value: indicators.williamsR[idx]?.toFixed(2), status: indicators.williamsR[idx] < -80 ? 'üü¢' : indicators.williamsR[idx] > -20 ? 'üî¥' : 'üü°' },
                'Volume': { value: state.analysis.marketAnalysis.volume.ratio + 'x', status: state.analysis.marketAnalysis.volume.signal === 'high' ? 'üî•' : '‚ùÑÔ∏è' }
            };
            
            const html = Object.entries(data).map(([name, info]) => `
                <div class="metric-card">
                    <div class="text-sm opacity-70">${name} ${info.status}</div>
                    <div class="indicator-value">${info.value || 'N/A'}</div>
                </div>
            `).join('');
            
            document.getElementById('indicatorsGrid').innerHTML = html;
        }

        function displayPatterns() {
            const patterns = state.analysis.marketAnalysis.patterns;
            const html = patterns.length > 0 ? patterns.map(p => `
                <div class="metric-card">
                    <div class="font-semibold">${p.type}</div>
                    <div class="text-sm mt-1">${p.signal === 'bullish' ? 'üü¢' : 'üî¥'} ${p.signal.toUpperCase()}</div>
                    <div class="text-xs opacity-70 mt-1">Confidence: ${(p.confidence * 100).toFixed(0)}%</div>
                </div>
            `).join('') : '<div class="text-center opacity-70">No significant patterns detected</div>';
            
            document.getElementById('patternsList').innerHTML = html;
            
            const srLevels = state.analysis.marketAnalysis.support_resistance;
            const srHtml = srLevels.map(level => `
                <div class="metric-card">
                    <div class="font-semibold">${level.type.toUpperCase()}</div>
                    <div class="indicator-value text-sm">$${level.price.toFixed(2)}</div>
                    <div class="text-xs opacity-70 mt-1">Strength: ${'‚≠ê'.repeat(Math.min(level.strength, 5))}</div>
                </div>
            `).join('');
            
            document.getElementById('srLevels').innerHTML = srHtml;
        }

        function createCharts() {
            const data = state.data;
            const indicators = state.indicators;
            
            // Price Chart
            const priceCtx = document.getElementById('priceChart').getContext('2d');
            if (state.charts.price) state.charts.price.destroy();
            
            state.charts.price = new Chart(priceCtx, {
                type: 'line',
                data: {
                    labels: data.timestamps.map(t => new Date(t)),
                    datasets: [
                        { label: 'Price', data: data.prices, borderColor: '#667eea', backgroundColor: 'rgba(102,126,234,0.1)', fill: true, tension: 0.4, borderWidth: 2 },
                        { label: 'SMA 50', data: indicators.sma50, borderColor: '#f39c12', borderWidth: 2, fill: false, pointRadius: 0 },
                        { label: 'SMA 200', data: indicators.sma200, borderColor: '#e74c3c', borderWidth: 2, fill: false, pointRadius: 0 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { type: 'time', time: { unit: 'day' }, ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                    }
                }
            });
            
            // Volume Chart
            const volumeCtx = document.getElementById('volumeChart').getContext('2d');
            if (state.charts.volume) state.charts.volume.destroy();
            
            state.charts.volume = new Chart(volumeCtx, {
                type: 'bar',
                data: {
                    labels: data.timestamps.map(t => new Date(t)),
                    datasets: [{ label: 'Volume', data: data.volumes, backgroundColor: 'rgba(102,126,234,0.5)' }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { type: 'time', time: { unit: 'day' }, ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                    }
                }
            });
            
            // Momentum Chart
            const momentumCtx = document.getElementById('momentumChart').getContext('2d');
            if (state.charts.momentum) state.charts.momentum.destroy();
            
            state.charts.momentum = new Chart(momentumCtx, {
                type: 'line',
                data: {
                    labels: data.timestamps.map(t => new Date(t)),
                    datasets: [
                        { label: 'RSI', data: indicators.rsi, borderColor: '#9b59b6', tension: 0.4, borderWidth: 2, pointRadius: 0 },
                        { label: 'Stochastic', data: indicators.stochastic, borderColor: '#3498db', tension: 0.4, borderWidth: 2, pointRadius: 0 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { type: 'time', time: { unit: 'day' }, ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { min: 0, max: 100, ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                    }
                }
            });
            
            // Volatility Chart
            const volatilityCtx = document.getElementById('volatilityChart').getContext('2d');
            if (state.charts.volatility) state.charts.volatility.destroy();
            
            const bb = indicators.bollinger;
            state.charts.volatility = new Chart(volatilityCtx, {
                type: 'line',
                data: {
                    labels: data.timestamps.map(t => new Date(t)),
                    datasets: [
                        { label: 'Price', data: data.prices, borderColor: '#667eea', borderWidth: 2, pointRadius: 0 },
                        { label: 'BB Upper', data: bb.upper, borderColor: '#e74c3c', borderWidth: 1, borderDash: [5,5], fill: false, pointRadius: 0 },
                        { label: 'BB Lower', data: bb.lower, borderColor: '#2ecc71', borderWidth: 1, borderDash: [5,5], fill: false, pointRadius: 0 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { type: 'time', time: { unit: 'day' }, ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                    }
                }
            });
        }

        function displayBacktest(results) {
            const html = `
                <div class="metric-card">
                    <div class="text-sm opacity-70">Total Return</div>
                    <div class="indicator-value ${parseFloat(results.totalReturn) > 0 ? 'text-green-400' : 'text-red-400'}">${results.totalReturn}%</div>
                </div>
                <div class="metric-card">
                    <div class="text-sm opacity-70">Total Trades</div>
                    <div class="indicator-value text-blue-400">${results.trades}</div>
                </div>
                <div class="metric-card">
                    <div class="text-sm opacity-70">Win Rate</div>
                    <div class="indicator-value text-purple-400">${results.winRate}%</div>
                </div>
                <div class="metric-card">
                    <div class="text-sm opacity-70">Sharpe Ratio</div>
                    <div class="indicator-value text-yellow-400">${results.sharpe}</div>
                </div>
                <div class="metric-card">
                    <div class="text-sm opacity-70">Max Drawdown</div>
                    <div class="indicator-value text-red-400">-${results.maxDrawdown}%</div>
                </div>
                <div class="metric-card">
                    <div class="text-sm opacity-70">Final Capital</div>
                    <div class="indicator-value text-green-400">$${results.finalCapital}</div>
                </div>
            `;
            document.getElementById('backtestMetrics').innerHTML = html;
            
            // Equity Curve
            const equityCtx = document.getElementById('equityChart').getContext('2d');
            if (state.charts.equity) state.charts.equity.destroy();
            
            state.charts.equity = new Chart(equityCtx, {
                type: 'line',
                data: {
                    labels: results.timestamps.map(t => new Date(t)),
                    datasets: [{
                        label: 'Portfolio Value',
                        data: results.equity,
                        borderColor: '#00d2a0',
                        backgroundColor: 'rgba(0,210,160,0.1)',
                        fill: true,
                        tension: 0.4,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { type: 'time', time: { unit: 'day' }, ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { ticks: { color: '#fff', callback: v => '$' + v.toFixed(0) }, grid: { color: 'rgba(255,255,255,0.1)' } }
                    }
                }
            });
        }

        function displayModelPredictions(predictions) {
            document.getElementById('lstmPrediction').innerHTML = `
                <div>Signal: ${predictions.lstm > 0.3 ? 'üü¢ BUY' : predictions.lstm < -0.3 ? 'üî¥ SELL' : 'üü° HOLD'}</div>
                <div class="text-sm opacity-70">Score: ${predictions.lstm.toFixed(3)}</div>
            `;
            
            document.getElementById('gruPrediction').innerHTML = `
                <div>Signal: ${predictions.gru > 0.3 ? 'üü¢ BUY' : predictions.gru < -0.3 ? 'üî¥ SELL' : 'üü° HOLD'}</div>
                <div class="text-sm opacity-70">Score: ${predictions.gru.toFixed(3)}</div>
            `;
            
            document.getElementById('regressionPrediction').innerHTML = `
                <div>Linear: ${predictions.linear > 0.3 ? 'üü¢ BUY' : predictions.linear < -0.3 ? 'üî¥ SELL' : 'üü° HOLD'}</div>
                <div class="text-sm opacity-70">Score: ${predictions.linear.toFixed(3)}</div>
            `;
        }

        // Main Analysis
        async function runAnalysis() {
            try {
                document.getElementById('loadingPanel').classList.remove('hidden');
                document.getElementById('analysisPanel').classList.add('hidden');
                updateProgress(0, 'Initializing...');
                
                const assetType = document.getElementById('assetType').value;
                const symbol = document.getElementById('symbol').value;
                const timeframe = document.getElementById('timeframe').value;
                
                // Fetch data
                updateProgress(10, 'Fetching market data...');
                const data = assetType === 'crypto' 
                    ? await DataFetcher.fetchCryptoData(symbol, timeframe)
                    : await DataFetcher.fetchStockData(symbol, timeframe);
                
                state.data = data;
                
                // Calculate indicators
                updateProgress(50, 'Calculating technical indicators...');
                const indicators = Indicators.calculateAll(data);
                state.indicators = indicators;
                
                // Train ML models
                updateProgress(60, 'Training AI models...');
                const { normalized, denormalize } = MLEngine.normalize(data.prices);
                const { sequences, targets } = MLEngine.prepareSequences(normalized, 60);
                
                if (sequences.length < 50) {
                    throw new Error('Insufficient data. Need at least 110 data points.');
                }
                
                const splitIdx = Math.floor(sequences.length * 0.8);
                const trainSeq = sequences.slice(0, splitIdx);
                const trainTgt = targets.slice(0, splitIdx);
                
                // LSTM
                const lstmModel = await MLEngine.createLSTM([60, 1]);
                await MLEngine.trainModel(lstmModel, trainSeq, trainTgt, 25);
                
                const lastSeq = normalized.slice(-60);
                const lstmPred = await MLEngine.predictNext(lstmModel, lastSeq);
                const lstmPrice = denormalize(lstmPred);
                
                // Linear regression
                updateProgress(85, 'Generating predictions...');
                const indices = Array.from({length: data.prices.length}, (_, i) => i);
                const linearModel = MLEngine.linearRegression(indices, data.prices);
                const linearPrice = linearModel.slope * data.prices.length + linearModel.intercept;
                
                const currentPrice = data.prices[data.prices.length - 1];
                
                const mlPredictions = {
                    lstm: (lstmPrice - currentPrice) / currentPrice,
                    gru: (lstmPrice - currentPrice) / currentPrice * 0.9,
                    linear: (linearPrice - currentPrice) / currentPrice
                };
                
                const pricePredictions = {
                    lstm: lstmPrice,
                    linear: linearPrice
                };
                
                // Generate signal
                updateProgress(90, 'Analyzing market conditions...');
                const analysis = AIAnalyst.generateSignal(data, indicators, mlPredictions);
                state.analysis = analysis;
                
                // Backtest
                updateProgress(95, 'Running backtest...');
                const backtestResults = Backtester.run(data, indicators);
                
                // Display results
                updateProgress(100, 'Complete!');
                setTimeout(() => {
                    document.getElementById('loadingPanel').classList.add('hidden');
                    displayResults(analysis);
                    displayPriceTargets(data, pricePredictions);
                    displayIndicators();
                    displayPatterns();
                    createCharts();
                    displayBacktest(backtestResults);
                    displayModelPredictions(mlPredictions);
                }, 500);
                
            } catch (error) {
                console.error('Analysis error:', error);
                alert('Error: ' + error.message);
                document.getElementById('loadingPanel').classList.add('hidden');
            }
        }

        // Event Listeners
        document.getElementById('analyzeBtn').addEventListener('click', runAnalysis);
        
        document.getElementById('assetType').addEventListener('change', (e) => {
            const select = document.getElementById('symbol');
            if (e.target.value === 'crypto') {
                select.innerHTML = `
                    <option value="bitcoin">Bitcoin (BTC)</option>
                    <option value="ethereum">Ethereum (ETH)</option>
                    <option value="binancecoin">Binance Coin (BNB)</option>
                    <option value="cardano">Cardano (ADA)</option>
                    <option value="solana">Solana (SOL)</option>
                    <option value="ripple">Ripple (XRP)</option>
                    <option value="polkadot">Polkadot (DOT)</option>
                    <option value="dogecoin">Dogecoin (DOGE)</option>
                `;
            } else {
                select.innerHTML = `
                    <option value="AAPL">Apple (AAPL)</option>
                    <option value="GOOGL">Google (GOOGL)</option>
                    <option value="MSFT">Microsoft (MSFT)</option>
                    <option value="TSLA">Tesla (TSLA)</option>
                    <option value="AMZN">Amazon (AMZN)</option>
                    <option value="NVDA">NVIDIA (NVDA)</option>
                    <option value="META">Meta (META)</option>
                `;
            }
        });

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden'));
                
                tab.classList.add('active');
                const panel = document.querySelector(`[data-panel="${tab.dataset.tab}"]`);
                if (panel) panel.classList.remove('hidden');
            });
        });

        console.log('AI Technical Analyst Ready ü§ñ');
    </script>
</body>
</html>
