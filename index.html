<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Analysis & Prediction System</title>
    
    <!-- CDN Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: 'Inter', system-ui, -apple-system, sans-serif; }
        .gradient-bg { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .signal-strong-buy { background: linear-gradient(135deg, #0f9960 0%, #15b371 100%); }
        .signal-buy { background: linear-gradient(135deg, #3ddc84 0%, #2ecc71 100%); }
        .signal-hold { background: linear-gradient(135deg, #f39c12 0%, #f1c40f 100%); }
        .signal-sell { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); }
        .signal-strong-sell { background: linear-gradient(135deg, #c0392b 0%, #8b0000 100%); }
        .loader { border-top-color: #667eea; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-50">
    
    <!-- Disclaimer Banner -->
    <div class="bg-red-600 text-white py-3 px-4 text-center text-sm">
        <strong>‚ö†Ô∏è DISCLAIMER:</strong> This is an educational tool for learning purposes only. Past performance does not guarantee future results. 
        Never invest money you cannot afford to lose. Consult a licensed financial advisor before trading.
    </div>

    <!-- Main Container -->
    <div class="container mx-auto px-4 py-8">
        
        <!-- Header -->
        <div class="gradient-bg rounded-xl shadow-2xl p-8 mb-8 text-white">
            <h1 class="text-4xl font-bold mb-2">ü§ñ AI Trading Analysis System</h1>
            <p class="text-lg opacity-90">Multi-Model ML Predictions with Technical Analysis</p>
        </div>

        <!-- Control Panel -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-semibold mb-2">Asset Type</label>
                    <select id="assetType" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500">
                        <option value="crypto">Cryptocurrency</option>
                        <option value="stock">Stock</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-semibold mb-2">Symbol</label>
                    <select id="symbol" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500">
                        <option value="bitcoin">Bitcoin (BTC)</option>
                        <option value="ethereum">Ethereum (ETH)</option>
                        <option value="cardano">Cardano (ADA)</option>
                        <option value="solana">Solana (SOL)</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-semibold mb-2">Timeframe</label>
                    <select id="timeframe" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500">
                        <option value="30">30 Days</option>
                        <option value="90">90 Days</option>
                        <option value="180">180 Days</option>
                        <option value="365">1 Year</option>
                    </select>
                </div>
                <div class="flex items-end">
                    <button id="analyzeBtn" class="w-full gradient-bg text-white px-6 py-2 rounded-lg font-semibold hover:opacity-90 transition">
                        Analyze
                    </button>
                </div>
            </div>
        </div>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="hidden bg-white rounded-xl shadow-lg p-8 mb-8 text-center">
            <div class="loader border-4 border-gray-200 rounded-full w-16 h-16 mx-auto mb-4"></div>
            <p class="text-lg font-semibold" id="loadingText">Fetching data...</p>
        </div>

        <!-- Signal Display -->
        <div id="signalDisplay" class="hidden mb-8">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div id="mainSignalCard" class="signal-hold rounded-xl shadow-2xl p-8 text-white text-center transform transition hover:scale-105">
                    <h3 class="text-2xl font-bold mb-2">TRADING SIGNAL</h3>
                    <div id="signalValue" class="text-5xl font-bold mb-4">HOLD</div>
                    <div id="confidenceValue" class="text-xl">Confidence: 0%</div>
                </div>
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h3 class="text-lg font-bold mb-4">üìä Model Predictions</h3>
                    <div id="modelPredictions" class="space-y-2 text-sm"></div>
                </div>
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h3 class="text-lg font-bold mb-4">üìà Price Targets</h3>
                    <div id="priceTargets" class="space-y-3"></div>
                </div>
            </div>
        </div>

        <!-- Charts -->
        <div id="chartsSection" class="hidden grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h3 class="text-lg font-bold mb-4">Price Chart</h3>
                <canvas id="priceChart"></canvas>
            </div>
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h3 class="text-lg font-bold mb-4">Technical Indicators</h3>
                <canvas id="indicatorsChart"></canvas>
            </div>
        </div>

        <!-- Technical Indicators -->
        <div id="indicatorsSection" class="hidden bg-white rounded-xl shadow-lg p-6 mb-8">
            <h3 class="text-xl font-bold mb-4">üîç Technical Indicators</h3>
            <div id="indicatorsGrid" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div>
        </div>

        <!-- Backtesting Results -->
        <div id="backtestSection" class="hidden bg-white rounded-xl shadow-lg p-6 mb-8">
            <h3 class="text-xl font-bold mb-4">üìä Backtesting Results</h3>
            <div id="backtestResults" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div>
        </div>

    </div>

    <script>
        // Global state
        const state = {
            currentData: null,
            models: {},
            cache: {},
            charts: {}
        };

        // Technical Indicators Implementation
        class TechnicalIndicators {
            static SMA(data, period) {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                        continue;
                    }
                    const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                    result.push(sum / period);
                }
                return result;
            }

            static EMA(data, period) {
                const k = 2 / (period + 1);
                const result = [data[0]];
                for (let i = 1; i < data.length; i++) {
                    result.push(data[i] * k + result[i - 1] * (1 - k));
                }
                return result;
            }

            static RSI(data, period = 14) {
                const changes = [];
                for (let i = 1; i < data.length; i++) {
                    changes.push(data[i] - data[i - 1]);
                }
                
                const result = [];
                for (let i = 0; i < changes.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                        continue;
                    }
                    
                    const slice = changes.slice(i - period + 1, i + 1);
                    const gains = slice.filter(x => x > 0).reduce((a, b) => a + b, 0) / period;
                    const losses = Math.abs(slice.filter(x => x < 0).reduce((a, b) => a + b, 0)) / period;
                    
                    if (losses === 0) {
                        result.push(100);
                    } else {
                        const rs = gains / losses;
                        result.push(100 - (100 / (1 + rs)));
                    }
                }
                return [null, ...result];
            }

            static MACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                const emaFast = this.EMA(data, fastPeriod);
                const emaSlow = this.EMA(data, slowPeriod);
                const macdLine = emaFast.map((val, i) => val - emaSlow[i]);
                const signalLine = this.EMA(macdLine, signalPeriod);
                const histogram = macdLine.map((val, i) => val - signalLine[i]);
                return { macdLine, signalLine, histogram };
            }

            static BollingerBands(data, period = 20, stdDev = 2) {
                const sma = this.SMA(data, period);
                const upper = [];
                const lower = [];
                
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        upper.push(null);
                        lower.push(null);
                        continue;
                    }
                    
                    const slice = data.slice(i - period + 1, i + 1);
                    const mean = sma[i];
                    const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
                    const std = Math.sqrt(variance);
                    
                    upper.push(mean + stdDev * std);
                    lower.push(mean - stdDev * std);
                }
                
                return { upper, middle: sma, lower };
            }

            static ATR(high, low, close, period = 14) {
                const tr = [];
                for (let i = 1; i < close.length; i++) {
                    const hl = high[i] - low[i];
                    const hc = Math.abs(high[i] - close[i - 1]);
                    const lc = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(hl, hc, lc));
                }
                return [null, ...this.SMA(tr, period)];
            }

            static Stochastic(high, low, close, period = 14) {
                const result = [];
                for (let i = 0; i < close.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                        continue;
                    }
                    
                    const highSlice = high.slice(i - period + 1, i + 1);
                    const lowSlice = low.slice(i - period + 1, i + 1);
                    const highestHigh = Math.max(...highSlice);
                    const lowestLow = Math.min(...lowSlice);
                    
                    const k = ((close[i] - lowestLow) / (highestHigh - lowestLow)) * 100;
                    result.push(k);
                }
                return result;
            }

            static OBV(close, volume) {
                const obv = [volume[0]];
                for (let i = 1; i < close.length; i++) {
                    if (close[i] > close[i - 1]) {
                        obv.push(obv[i - 1] + volume[i]);
                    } else if (close[i] < close[i - 1]) {
                        obv.push(obv[i - 1] - volume[i]);
                    } else {
                        obv.push(obv[i - 1]);
                    }
                }
                return obv;
            }
        }

        // ML Models
        class MLModels {
            static async createLSTM(inputShape) {
                const model = tf.sequential();
                model.add(tf.layers.lstm({ units: 50, returnSequences: true, inputShape }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.lstm({ units: 50, returnSequences: false }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.dense({ units: 25, activation: 'relu' }));
                model.add(tf.layers.dense({ units: 1 }));
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError'
                });
                
                return model;
            }

            static async createGRU(inputShape) {
                const model = tf.sequential();
                model.add(tf.layers.gru({ units: 64, returnSequences: true, inputShape }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.gru({ units: 32, returnSequences: false }));
                model.add(tf.layers.dense({ units: 1 }));
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError'
                });
                
                return model;
            }

            static prepareSequenceData(data, lookback = 60) {
                const X = [];
                const y = [];
                
                for (let i = lookback; i < data.length; i++) {
                    X.push(data.slice(i - lookback, i));
                    y.push(data[i]);
                }
                
                return { X, y };
            }

            static normalizeData(data) {
                const min = Math.min(...data);
                const max = Math.max(...data);
                return {
                    normalized: data.map(x => (x - min) / (max - min)),
                    min,
                    max
                };
            }

            static denormalize(normalized, min, max) {
                return normalized * (max - min) + min;
            }

            static async trainModel(model, X, y, epochs = 50) {
                const xs = tf.tensor3d(X);
                const ys = tf.tensor2d(y, [y.length, 1]);
                
                await model.fit(xs, ys, {
                    epochs,
                    batchSize: 32,
                    verbose: 0,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            if (epoch % 10 === 0) {
                                updateLoadingText(`Training model... Epoch ${epoch}/${epochs}`);
                            }
                        }
                    }
                });
                
                xs.dispose();
                ys.dispose();
                
                return model;
            }

            static linearRegression(X, y) {
                const n = X.length;
                const sumX = X.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = X.reduce((sum, x, i) => sum + x * y[i], 0);
                const sumXX = X.reduce((sum, x) => sum + x * x, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                return { slope, intercept, predict: (x) => slope * x + intercept };
            }
        }

        // API Functions
        class DataFetcher {
            static async fetchCryptoData(coinId, days) {
                const cacheKey = `${coinId}_${days}`;
                if (state.cache[cacheKey] && Date.now() - state.cache[cacheKey].timestamp < 300000) {
                    return state.cache[cacheKey].data;
                }

                try {
                    const response = await fetch(
                        `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=${days}`
                    );
                    const data = await response.json();
                    
                    const formatted = {
                        timestamps: data.prices.map(p => p[0]),
                        prices: data.prices.map(p => p[1]),
                        volumes: data.total_volumes.map(v => v[1]),
                        high: data.prices.map(p => p[1] * 1.02), // Approximation
                        low: data.prices.map(p => p[1] * 0.98)
                    };
                    
                    state.cache[cacheKey] = { data: formatted, timestamp: Date.now() };
                    return formatted;
                } catch (error) {
                    console.error('Error fetching data:', error);
                    throw error;
                }
            }

            static async fetchStockData(symbol, days) {
                // Using Yahoo Finance unofficial API
                const endDate = Math.floor(Date.now() / 1000);
                const startDate = endDate - (days * 24 * 60 * 60);
                
                try {
                    const response = await fetch(
                        `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${startDate}&period2=${endDate}&interval=1d`
                    );
                    const data = await response.json();
                    const result = data.chart.result[0];
                    
                    return {
                        timestamps: result.timestamp.map(t => t * 1000),
                        prices: result.indicators.quote[0].close,
                        volumes: result.indicators.quote[0].volume,
                        high: result.indicators.quote[0].high,
                        low: result.indicators.quote[0].low
                    };
                } catch (error) {
                    console.error('Error fetching stock data:', error);
                    // Fallback to crypto if stock fails
                    return await this.fetchCryptoData('bitcoin', days);
                }
            }
        }

        // Signal Generation
        class SignalGenerator {
            static generateTechnicalSignals(indicators) {
                const signals = {};
                
                // RSI Signal
                const lastRSI = indicators.rsi[indicators.rsi.length - 1];
                if (lastRSI < 30) signals.rsi = 1; // Buy
                else if (lastRSI > 70) signals.rsi = -1; // Sell
                else signals.rsi = 0; // Hold
                
                // MACD Signal
                const lastMACD = indicators.macd.histogram[indicators.macd.histogram.length - 1];
                const prevMACD = indicators.macd.histogram[indicators.macd.histogram.length - 2];
                if (lastMACD > 0 && prevMACD < 0) signals.macd = 1;
                else if (lastMACD < 0 && prevMACD > 0) signals.macd = -1;
                else signals.macd = 0;
                
                // Bollinger Bands Signal
                const lastPrice = indicators.prices[indicators.prices.length - 1];
                const lastUpper = indicators.bollinger.upper[indicators.bollinger.upper.length - 1];
                const lastLower = indicators.bollinger.lower[indicators.bollinger.lower.length - 1];
                if (lastPrice < lastLower) signals.bollinger = 1;
                else if (lastPrice > lastUpper) signals.bollinger = -1;
                else signals.bollinger = 0;
                
                // Stochastic Signal
                const lastStoch = indicators.stochastic[indicators.stochastic.length - 1];
                if (lastStoch < 20) signals.stochastic = 1;
                else if (lastStoch > 80) signals.stochastic = -1;
                else signals.stochastic = 0;
                
                // Moving Average Crossover
                const lastSMA50 = indicators.sma50[indicators.sma50.length - 1];
                const lastSMA200 = indicators.sma200[indicators.sma200.length - 1];
                if (lastSMA50 > lastSMA200) signals.ma = 1;
                else if (lastSMA50 < lastSMA200) signals.ma = -1;
                else signals.ma = 0;
                
                return signals;
            }

            static combineSignals(mlPredictions, technicalSignals) {
                const mlWeight = 0.6;
                const techWeight = 0.4;
                
                const mlAvg = Object.values(mlPredictions).reduce((a, b) => a + b, 0) / Object.keys(mlPredictions).length;
                const techAvg = Object.values(technicalSignals).reduce((a, b) => a + b, 0) / Object.keys(technicalSignals).length;
                
                const finalSignal = mlWeight * mlAvg + techWeight * techAvg;
                
                let signalText, signalClass;
                if (finalSignal > 0.5) {
                    signalText = 'STRONG BUY';
                    signalClass = 'signal-strong-buy';
                } else if (finalSignal > 0.15) {
                    signalText = 'BUY';
                    signalClass = 'signal-buy';
                } else if (finalSignal > -0.15) {
                    signalText = 'HOLD';
                    signalClass = 'signal-hold';
                } else if (finalSignal > -0.5) {
                    signalText = 'SELL';
                    signalClass = 'signal-sell';
                } else {
                    signalText = 'STRONG SELL';
                    signalClass = 'signal-strong-sell';
                }
                
                const confidence = Math.min(Math.abs(finalSignal) * 100, 100);
                
                return { signal: signalText, class: signalClass, confidence: confidence.toFixed(1), rawScore: finalSignal };
            }
        }

        // Backtesting
        class Backtester {
            static runBacktest(data, signals, initialCapital = 10000) {
                let capital = initialCapital;
                let position = 0;
                let trades = 0;
                let wins = 0;
                let losses = 0;
                const returns = [];
                
                for (let i = 1; i < data.prices.length; i++) {
                    const signal = signals[i];
                    const price = data.prices[i];
                    const prevPrice = data.prices[i - 1];
                    
                    // Simple strategy: buy on positive signal, sell on negative
                    if (signal > 0.3 && position === 0) {
                        // Buy
                        position = capital / price;
                        capital = 0;
                        trades++;
                    } else if (signal < -0.3 && position > 0) {
                        // Sell
                        capital = position * price;
                        const returnPct = (price - prevPrice) / prevPrice;
                        returns.push(returnPct);
                        if (returnPct > 0) wins++;
                        else losses++;
                        position = 0;
                        trades++;
                    }
                }
                
                // Close position at end
                if (position > 0) {
                    capital = position * data.prices[data.prices.length - 1];
                }
                
                const totalReturn = ((capital - initialCapital) / initialCapital) * 100;
                const winRate = trades > 0 ? (wins / trades) * 100 : 0;
                const avgReturn = returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0;
                
                return {
                    totalReturn: totalReturn.toFixed(2),
                    trades,
                    winRate: winRate.toFixed(1),
                    finalCapital: capital.toFixed(2)
                };
            }
        }

        // UI Functions
        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }

        function showLoading(show) {
            document.getElementById('loadingIndicator').classList.toggle('hidden', !show);
        }

        function displaySignal(signalData, modelPredictions, priceTargets) {
            const signalDisplay = document.getElementById('signalDisplay');
            const mainSignalCard = document.getElementById('mainSignalCard');
            
            mainSignalCard.className = `${signalData.class} rounded-xl shadow-2xl p-8 text-white text-center transform transition hover:scale-105`;
            document.getElementById('signalValue').textContent = signalData.signal;
            document.getElementById('confidenceValue').textContent = `Confidence: ${signalData.confidence}%`;
            
            // Model predictions
            const modelPredDiv = document.getElementById('modelPredictions');
            modelPredDiv.innerHTML = Object.entries(modelPredictions).map(([model, signal]) => {
                const signalEmoji = signal > 0.3 ? 'üü¢' : signal < -0.3 ? 'üî¥' : 'üü°';
                const signalText = signal > 0.3 ? 'Buy' : signal < -0.3 ? 'Sell' : 'Hold';
                return `<div class="flex justify-between items-center"><span>${model}:</span><span>${signalEmoji} ${signalText}</span></div>`;
            }).join('');
            
            // Price targets
            const priceTargetsDiv = document.getElementById('priceTargets');
            priceTargetsDiv.innerHTML = `
                <div class="flex justify-between"><span class="font-semibold">Current:</span><span>$${priceTargets.current.toFixed(2)}</span></div>
                <div class="flex justify-between text-green-600"><span class="font-semibold">Target (7d):</span><span>$${priceTargets.target7d.toFixed(2)}</span></div>
                <div class="flex justify-between text-blue-600"><span class="font-semibold">Target (30d):</span><span>$${priceTargets.target30d.toFixed(2)}</span></div>
                <div class="flex justify-between text-red-600"><span class="font-semibold">Stop Loss:</span><span>$${priceTargets.stopLoss.toFixed(2)}</span></div>
            `;
            
            signalDisplay.classList.remove('hidden');
        }

        function displayIndicators(indicators) {
            const grid = document.getElementById('indicatorsGrid');
            const lastIdx = indicators.prices.length - 1;
            
            const indicatorValues = {
                'RSI (14)': indicators.rsi[lastIdx]?.toFixed(2) || 'N/A',
                'MACD': indicators.macd.macdLine[lastIdx]?.toFixed(2) || 'N/A',
                'SMA (50)': indicators.sma50[lastIdx]?.toFixed(2) || 'N/A',
                'SMA (200)': indicators.sma200[lastIdx]?.toFixed(2) || 'N/A',
                'BB Upper': indicators.bollinger.upper[lastIdx]?.toFixed(2) || 'N/A',
                'BB Lower': indicators.bollinger.lower[lastIdx]?.toFixed(2) || 'N/A',
                'Stochastic': indicators.stochastic[lastIdx]?.toFixed(2) || 'N/A',
                'ATR': indicators.atr[lastIdx]?.toFixed(2) || 'N/A'
            };
            
            grid.innerHTML = Object.entries(indicatorValues).map(([name, value]) => `
                <div class="p-4 bg-gray-50 rounded-lg">
                    <div class="text-sm text-gray-600">${name}</div>
                    <div class="text-xl font-bold">${value}</div>
                </div>
            `).join('');
            
            document.getElementById('indicatorsSection').classList.remove('hidden');
        }

        function createCharts(data, indicators) {
            // Price Chart
            const priceCtx = document.getElementById('priceChart').getContext('2d');
            if (state.charts.price) state.charts.price.destroy();
            
            state.charts.price = new Chart(priceCtx, {
                type: 'line',
                data: {
                    labels: data.timestamps.map(t => new Date(t)),
                    datasets: [{
                        label: 'Price',
                        data: data.prices,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        fill: true,
                        tension: 0.4
                    }, {
                        label: 'SMA 50',
                        data: indicators.sma50,
                        borderColor: '#f39c12',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4
                    }, {
                        label: 'SMA 200',
                        data: indicators.sma200,
                        borderColor: '#e74c3c',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { display: true } },
                    scales: {
                        x: { type: 'time', time: { unit: 'day' } },
                        y: { beginAtZero: false }
                    }
                }
            });
            
            // Indicators Chart
            const indCtx = document.getElementById('indicatorsChart').getContext('2d');
            if (state.charts.indicators) state.charts.indicators.destroy();
            
            state.charts.indicators = new Chart(indCtx, {
                type: 'line',
                data: {
                    labels: data.timestamps.map(t => new Date(t)),
                    datasets: [{
                        label: 'RSI',
                        data: indicators.rsi,
                        borderColor: '#9b59b6',
                        yAxisID: 'y',
                        tension: 0.4
                    }, {
                        label: 'Stochastic',
                        data: indicators.stochastic,
                        borderColor: '#3498db',
                        yAxisID: 'y',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: { legend: { display: true } },
                    scales: {
                        x: { type: 'time', time: { unit: 'day' } },
                        y: { min: 0, max: 100 }
                    }
                }
            });
            
            document.getElementById('chartsSection').classList.remove('hidden');
        }

        function displayBacktest(backtestResults) {
            const resultsDiv = document.getElementById('backtestResults');
            resultsDiv.innerHTML = `
                <div class="p-4 bg-green-50 rounded-lg">
                    <div class="text-sm text-gray-600">Total Return</div>
                    <div class="text-2xl font-bold text-green-600">${backtestResults.totalReturn}%</div>
                </div>
                <div class="p-4 bg-blue-50 rounded-lg">
                    <div class="text-sm text-gray-600">Total Trades</div>
                    <div class="text-2xl font-bold text-blue-600">${backtestResults.trades}</div>
                </div>
                <div class="p-4 bg-purple-50 rounded-lg">
                    <div class="text-sm text-gray-600">Win Rate</div>
                    <div class="text-2xl font-bold text-purple-600">${backtestResults.winRate}%</div>
                </div>
                <div class="p-4 bg-yellow-50 rounded-lg">
                    <div class="text-sm text-gray-600">Final Capital</div>
                    <div class="text-2xl font-bold text-yellow-600">$${backtestResults.finalCapital}</div>
                </div>
            `;
            document.getElementById('backtestSection').classList.remove('hidden');
        }

        // Main Analysis Function
        async function runAnalysis() {
            try {
                showLoading(true);
                updateLoadingText('Fetching market data...');
                
                const assetType = document.getElementById('assetType').value;
                const symbol = document.getElementById('symbol').value;
                const timeframe = parseInt(document.getElementById('timeframe').value);
                
                // Fetch data
                let data;
                if (assetType === 'crypto') {
                    data = await DataFetcher.fetchCryptoData(symbol, timeframe);
                } else {
                    data = await DataFetcher.fetchStockData(symbol, timeframe);
                }
                
                state.currentData = data;
                
                // Calculate indicators
                updateLoadingText('Calculating technical indicators...');
                const indicators = {
                    prices: data.prices,
                    sma20: TechnicalIndicators.SMA(data.prices, 20),
                    sma50: TechnicalIndicators.SMA(data.prices, 50),
                    sma200: TechnicalIndicators.SMA(data.prices, 200),
                    ema12: TechnicalIndicators.EMA(data.prices, 12),
                    ema26: TechnicalIndicators.EMA(data.prices, 26),
                    rsi: TechnicalIndicators.RSI(data.prices, 14),
                    macd: TechnicalIndicators.MACD(data.prices),
                    bollinger: TechnicalIndicators.BollingerBands(data.prices, 20, 2),
                    atr: TechnicalIndicators.ATR(data.high, data.low, data.prices, 14),
                    stochastic: TechnicalIndicators.Stochastic(data.high, data.low, data.prices, 14),
                    obv: TechnicalIndicators.OBV(data.prices, data.volumes)
                };
                
                // Train ML models
                updateLoadingText('Training LSTM model...');
                const { normalized, min, max } = MLModels.normalizeData(data.prices);
                const { X, y } = MLModels.prepareSequenceData(normalized, 60);
                
                if (X.length < 50) {
                    throw new Error('Insufficient data for training. Need at least 110 data points.');
                }
                
                // Split data
                const splitIdx = Math.floor(X.length * 0.8);
                const XTrain = X.slice(0, splitIdx);
                const yTrain = y.slice(0, splitIdx);
                const XTest = X.slice(splitIdx);
                
                // Train LSTM
                const lstmModel = await MLModels.createLSTM([60, 1]);
                await MLModels.trainModel(lstmModel, XTrain, yTrain, 30);
                
                // Make predictions
                updateLoadingText('Generating predictions...');
                const lastSequence = normalized.slice(-60);
                const lstmPrediction = lstmModel.predict(tf.tensor3d([lastSequence]));
                const lstmValue = lstmPrediction.dataSync()[0];
                const predictedPrice = MLModels.denormalize(lstmValue, min, max);
                
                lstmPrediction.dispose();
                
                // Linear regression
                const indices = Array.from({length: data.prices.length}, (_, i) => i);
                const linearModel = MLModels.linearRegression(indices, data.prices);
                const linearPrediction = linearModel.predict(data.prices.length);
                
                // Calculate ML signals
                const currentPrice = data.prices[data.prices.length - 1];
                const mlPredictions = {
                    'LSTM': (predictedPrice - currentPrice) / currentPrice > 0.02 ? 1 : (predictedPrice - currentPrice) / currentPrice < -0.02 ? -1 : 0,
                    'Linear Reg': (linearPrediction - currentPrice) / currentPrice > 0.02 ? 1 : (linearPrediction - currentPrice) / currentPrice < -0.02 ? -1 : 0,
                    'Momentum': data.prices[data.prices.length - 1] > data.prices[data.prices.length - 5] ? 1 : -1
                };
                
                // Technical signals
                const technicalSignals = SignalGenerator.generateTechnicalSignals(indicators);
                
                // Combine signals
                const finalSignal = SignalGenerator.combineSignals(mlPredictions, technicalSignals);
                
                // Price targets
                const atr = indicators.atr[indicators.atr.length - 1] || currentPrice * 0.02;
                const priceTargets = {
                    current: currentPrice,
                    target7d: predictedPrice,
                    target30d: linearPrediction,
                    stopLoss: currentPrice - (atr * 2)
                };
                
                // Backtest
                updateLoadingText('Running backtest...');
                const signals = data.prices.map((_, i) => {
                    const rsi = indicators.rsi[i];
                    if (rsi < 30) return 1;
                    if (rsi > 70) return -1;
                    return 0;
                });
                const backtestResults = Backtester.runBacktest(data, signals);
                
                // Display results
                showLoading(false);
                displaySignal(finalSignal, mlPredictions, priceTargets);
                displayIndicators(indicators);
                createCharts(data, indicators);
                displayBacktest(backtestResults);
                
            } catch (error) {
                console.error('Analysis error:', error);
                showLoading(false);
                alert('Error during analysis: ' + error.message);
            }
        }

        // Event Listeners
        document.getElementById('analyzeBtn').addEventListener('click', runAnalysis);
        
        document.getElementById('assetType').addEventListener('change', (e) => {
            const symbolSelect = document.getElementById('symbol');
            if (e.target.value === 'crypto') {
                symbolSelect.innerHTML = `
                    <option value="bitcoin">Bitcoin (BTC)</option>
                    <option value="ethereum">Ethereum (ETH)</option>
                    <option value="cardano">Cardano (ADA)</option>
                    <option value="solana">Solana (SOL)</option>
                `;
            } else {
                symbolSelect.innerHTML = `
                    <option value="AAPL">Apple (AAPL)</option>
                    <option value="GOOGL">Google (GOOGL)</option>
                    <option value="MSFT">Microsoft (MSFT)</option>
                    <option value="TSLA">Tesla (TSLA)</option>
                `;
            }
        });

        // Initialize
        console.log('Trading Analysis System Loaded');
    </script>
</body>
</html>
