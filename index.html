<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Personal Crypto Trading Assistant</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://unpkg.com/technicalindicators/dist/browser.js"></script>

    <style>
        /* --- Basic Setup & Theming --- */
        :root {
            --bg-color: #121212;
            --pane-color: #1a1a1a;
            --border-color: #333;
            --text-color: #e0e0e0;
            --text-secondary: #aaa;
            --accent-color: #007bff;
            --green: #26a69a;
            --red: #ef5350;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        h1, h2, h3 {
            margin: 0 0 10px 0;
            color: var(--text-color);
            font-weight: 500;
        }

        /* --- App Layout --- */
        .app-container {
            display: flex;
            flex-grow: 1;
            padding: 10px;
            gap: 10px;
        }

        .panel {
            background-color: var(--pane-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
        }
        
        #main-panel {
            flex: 3;
            padding: 0;
            border: none;
            display: flex;
            flex-direction: column;
        }

        #controls-panel {
            flex: 1;
            min-width: 250px;
        }

        #analysis-panel {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }
        
        #chart-container {
            width: 100%;
            height: 100%;
            flex-grow: 1;
        }

        /* --- Controls Styling --- */
        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        select, button {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background-color: #2a2a2a;
            color: var(--text-color);
            font-size: 1em;
            cursor: pointer;
        }
        
        button {
             background-color: var(--accent-color);
             font-weight: bold;
             border: none;
        }

        button:hover {
            opacity: 0.9;
        }

        .timeframe-buttons button {
            background-color: #2a2a2a;
            border: 1px solid var(--border-color);
            font-weight: normal;
        }

        .timeframe-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .timeframe-buttons button.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        /* --- Indicator Controls --- */
        #indicator-controls h3 {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        
        .indicator-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 0.95em;
        }
        
        .indicator-item > div {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .indicator-params {
            display: flex;
            gap: 5px;
        }

        .indicator-params input {
            width: 40px;
            padding: 4px;
            background-color: #2a2a2a;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 4px;
            text-align: center;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        /* --- Analysis Summary --- */
        #analysis-summary {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            margin-top: 15px;
        }
        
        #analysis-summary h3 {
             border-bottom: 1px solid var(--border-color);
             padding-bottom: 10px;
        }
        
        #summary-text {
            flex-grow: 1;
            width: 100%;
            box-sizing: border-box;
            background-color: #1f1f1f;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            padding: 10px;
            border-radius: 5px;
            resize: none;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>

    <div class="app-container">
        <div id="controls-panel" class="panel">
            <h2>Controls</h2>
            <div class="control-group">
                <label for="crypto-select">Cryptocurrency</label>
                <select id="crypto-select">
                    </select>
            </div>
            <div class="control-group">
                <label>Time Frame</label>
                <div class="timeframe-buttons">
                    <button data-days="1">24H</button>
                    <button data-days="90" class="active">90D</button>
                    <button data-days="365">1Y</button>
                    <button data-days="max">Max</button>
                </div>
            </div>
            <div class="control-group">
                <button id="refresh-btn">Refresh Data</button>
            </div>
            <div id="indicator-controls">
                <h3>Indicators</h3>
                </div>
        </div>

        <div id="main-panel">
            <div id="chart-container"></div>
        </div>

        <div id="analysis-panel" class="panel">
            <div id="analysis-summary">
                <h3>Analysis Summary</h3>
                <textarea id="summary-text" readonly>Select a crypto and time frame to begin analysis...</textarea>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Namespace for technical indicators library
        const ti = technicalindicators;

        // --- 1. CONFIGURATION & STATE MANAGEMENT ---

        // Map user-friendly names to CoinGecko API IDs
        const CRYPTO_MAP = {
            'BTC': 'bitcoin',
            'ETH': 'ethereum',
            'SOL': 'solana',
            'WIF': 'dogwifcoin',
            'AVAX': 'avalanche-2',
            'BRETT': 'brett-2',
            'ADA': 'cardano', // Replaced FARCOIN with a more common asset
            'PYTH': 'pyth-network',
            'LINK': 'chainlink',
            'RNDR': 'render-token'
        };

        // Initial state for indicators, parameters, and chart series objects
        const indicatorSettings = {
            sma:        { active: true,  period: 20, series: null, inputs: ['period'], color: '#ffa500' },
            ema50:      { active: true,  period: 50, series: null, inputs: ['period'], color: '#4caf50' },
            ema200:     { active: true,  period: 200, series: null, inputs: ['period'], color: '#f44336' },
            bb:         { active: true,  period: 20, stdDev: 2, series: [null, null, null], inputs: ['period', 'stdDev'], color: '#2962FF' }, // upper, middle, lower
            rsi:        { active: true,  period: 14, overbought: 70, oversold: 30, series: null, pane: 1, inputs: ['period', 'overbought', 'oversold'], color: '#9c27b0' },
            macd:       { active: true,  fastPeriod: 12, slowPeriod: 26, signalPeriod: 9, series: [null, null, null], pane: 2, inputs: ['fastPeriod', 'slowPeriod', 'signalPeriod'] }, // macd, signal, histogram
            psar:       { active: false, step: 0.02, max: 0.2, series: null, inputs: ['step', 'max'], color: '#ffffff' },
            stoch:      { active: false, period: 14, signalPeriod: 3, series: [null, null], pane: 1, inputs: ['period', 'signalPeriod'] }, // k, d
            atr:        { active: false, period: 14, series: null, pane: 2, inputs: ['period'], color: '#ffeb3b' },
            obv:        { active: false, series: null, pane: 2, inputs: [], color: '#00bcd4' }
        };

        let currentOhlcvData = [];
        let chart, candlestickSeries;
        const indicatorPanes = {}; // To store chart pane objects

        // --- 2. DOM ELEMENT REFERENCES ---

        const cryptoSelect = document.getElementById('crypto-select');
        const timeframeButtons = document.querySelectorAll('.timeframe-buttons button');
        const refreshBtn = document.getElementById('refresh-btn');
        const chartContainer = document.getElementById('chart-container');
        const summaryText = document.getElementById('summary-text');
        const indicatorControlsContainer = document.getElementById('indicator-controls');
        
        // --- 3. INITIALIZATION ---

        function initialize() {
            populateCryptoDropdown();
            populateIndicatorControls();
            initializeChart();
            addEventListeners();
            loadInitialData();
        }

        function populateCryptoDropdown() {
            for (const symbol in CRYPTO_MAP) {
                const option = document.createElement('option');
                option.value = CRYPTO_MAP[symbol];
                option.textContent = symbol;
                cryptoSelect.appendChild(option);
            }
        }
        
        function populateIndicatorControls() {
            const createInput = (key, value, settingKey) => {
                const input = document.createElement('input');
                input.type = 'number';
                input.value = value;
                if (key === 'step' || key === 'max') {
                    input.step = '0.01';
                }
                input.addEventListener('change', (e) => {
                    indicatorSettings[settingKey][key] = parseFloat(e.target.value);
                    updateIndicatorsAndAnalysis();
                });
                return input;
            };

            for (const key in indicatorSettings) {
                const setting = indicatorSettings[key];
                const item = document.createElement('div');
                item.className = 'indicator-item';

                const leftDiv = document.createElement('div');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = setting.active;
                checkbox.addEventListener('change', (e) => {
                    setting.active = e.target.checked;
                    updateIndicatorsAndAnalysis();
                });
                const label = document.createElement('label');
                label.textContent = key.toUpperCase();
                leftDiv.appendChild(checkbox);
                leftDiv.appendChild(label);

                const paramsDiv = document.createElement('div');
                paramsDiv.className = 'indicator-params';
                setting.inputs.forEach(paramKey => {
                    paramsDiv.appendChild(createInput(paramKey, setting[paramKey], key));
                });
                
                item.appendChild(leftDiv);
                item.appendChild(paramsDiv);
                indicatorControlsContainer.appendChild(item);
            }
        }

        function initializeChart() {
            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: chartContainer.clientHeight,
                layout: {
                    backgroundColor: '#1a1a1a',
                    textColor: 'rgba(255, 255, 255, 0.9)',
                },
                grid: {
                    vertLines: { color: '#2a2a2a' },
                    horzLines: { color: '#2a2a2a' },
                },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                rightPriceScale: { borderColor: '#485158' },
                timeScale: { borderColor: '#485158', timeVisible: true, secondsVisible: false },
            });

            candlestickSeries = chart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderDownColor: '#ef5350',
                borderUpColor: '#26a69a',
                wickDownColor: '#ef5350',
                wickUpColor: '#26a69a',
            });

            // Create dedicated panes for some indicators
            indicatorPanes[1] = chart.addPriceScale({
                scaleMargins: { top: 0.8, bottom: 0 },
            });
            indicatorPanes[2] = chart.addPriceScale({
                scaleMargins: { top: 0.8, bottom: 0 },
            });

            // Make chart responsive
            new ResizeObserver(entries => {
                if (entries.length > 0 && entries[0].contentRect.width > 0) {
                    const { width, height } = entries[0].contentRect;
                    chart.applyOptions({ width, height });
                }
            }).observe(chartContainer);
        }
        
        function addEventListeners() {
            cryptoSelect.addEventListener('change', loadInitialData);
            refreshBtn.addEventListener('click', loadInitialData);
            timeframeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    timeframeButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    loadInitialData();
                });
            });
        }
        
        function loadInitialData() {
            const cryptoId = cryptoSelect.value;
            const days = document.querySelector('.timeframe-buttons button.active').dataset.days;
            fetchData(cryptoId, days);
        }

        // --- 4. DATA FETCHING & PROCESSING ---

        async function fetchData(cryptoId, days) {
            summaryText.value = `Fetching ${cryptoId.toUpperCase()} data for ${days} days...`;
            const url = `https://api.coingecko.com/api/v3/coins/${cryptoId}/ohlc?vs_currency=usd&days=${days}`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                const data = await response.json();
                
                if (data.length === 0) {
                    summaryText.value = `No data found for ${cryptoId.toUpperCase()}.`;
                    return;
                }
                
                currentOhlcvData = data.map(d => ({
                    time: d[0] / 1000,
                    open: d[1],
                    high: d[2],
                    low: d[3],
                    close: d[4]
                }));

                // Fetch volume data separately as it's not in the OHLC endpoint
                const volumeUrl = `https://api.coingecko.com/api/v3/coins/${cryptoId}/market_chart?vs_currency=usd&days=${days}&interval=daily`;
                const volumeResponse = await fetch(volumeUrl);
                const volumeData = await volumeResponse.json();
                const volumeMap = new Map(volumeData.total_volumes.map(d => [d[0], d[1]]));

                // Add volume to our OHLC data
                currentOhlcvData.forEach(d => {
                    // Find the closest timestamp in volume data
                    const closestTimestamp = Array.from(volumeMap.keys()).reduce((a, b) => {
                        return Math.abs(b - d.time * 1000) < Math.abs(a - d.time * 1000) ? b : a;
                    });
                    d.volume = volumeMap.get(closestTimestamp) || 0;
                });
                
                candlestickSeries.setData(currentOhlcvData);
                chart.timeScale().fitContent();
                updateIndicatorsAndAnalysis();

            } catch (error) {
                console.error('Failed to fetch data:', error);
                summaryText.value = `Error: ${error.message}`;
            }
        }
        
        function updateIndicatorsAndAnalysis() {
            if (currentOhlcvData.length === 0) return;
            calculateAndDrawIndicators();
            runAnalysis();
        }

        // --- 5. TECHNICAL INDICATORS CALCULATION & DRAWING ---

        function calculateAndDrawIndicators() {
            const closes = currentOhlcvData.map(d => d.close);
            const highs = currentOhlcvData.map(d => d.high);
            const lows = currentOhlcvData.map(d => d.low);
            const opens = currentOhlcvData.map(d => d.open);
            const volumes = currentOhlcvData.map(d => d.volume);

            const alignData = (indicatorData) => {
                const offset = currentOhlcvData.length - indicatorData.length;
                const aligned = Array(offset).fill(null).concat(indicatorData);
                return currentOhlcvData.map((d, i) => ({ time: d.time, value: aligned[i] })).filter(d => d.value !== null);
            };

            // SMA
            const smaSetting = indicatorSettings.sma;
            if (!smaSetting.series) smaSetting.series = chart.addLineSeries({ color: smaSetting.color, lineWidth: 2, priceLineVisible: false });
            smaSetting.series.applyOptions({ visible: smaSetting.active });
            if (smaSetting.active) {
                const smaData = ti.sma({ period: smaSetting.period, values: closes });
                smaSetting.series.setData(alignData(smaData));
            }

            // EMA 50
            const ema50Setting = indicatorSettings.ema50;
            if (!ema50Setting.series) ema50Setting.series = chart.addLineSeries({ color: ema50Setting.color, lineWidth: 2, priceLineVisible: false });
            ema50Setting.series.applyOptions({ visible: ema50Setting.active });
            if (ema50Setting.active) {
                const ema50Data = ti.ema({ period: ema50Setting.period, values: closes });
                ema50Setting.series.setData(alignData(ema50Data));
            }

            // EMA 200
            const ema200Setting = indicatorSettings.ema200;
            if (!ema200Setting.series) ema200Setting.series = chart.addLineSeries({ color: ema200Setting.color, lineWidth: 2, priceLineVisible: false });
            ema200Setting.series.applyOptions({ visible: ema200Setting.active });
            if (ema200Setting.active) {
                const ema200Data = ti.ema({ period: ema200Setting.period, values: closes });
                ema200Setting.series.setData(alignData(ema200Data));
            }

            // Bollinger Bands
            const bbSetting = indicatorSettings.bb;
            if (!bbSetting.series[0]) {
                const commonOptions = { priceLineVisible: false, lineWidth: 1, color: bbSetting.color, lastValueVisible: false };
                bbSetting.series[0] = chart.addLineSeries({ ...commonOptions, lineStyle: LightweightCharts.LineStyle.Dotted });
                bbSetting.series[1] = chart.addLineSeries({ ...commonOptions }); // Middle
                bbSetting.series[2] = chart.addLineSeries({ ...commonOptions, lineStyle: LightweightCharts.LineStyle.Dotted });
            }
            bbSetting.series.forEach(s => s.applyOptions({ visible: bbSetting.active }));
            if (bbSetting.active) {
                const bbData = ti.bollingerbands({ period: bbSetting.period, values: closes, stdDev: bbSetting.stdDev });
                const offset = currentOhlcvData.length - bbData.length;
                const formattedData = currentOhlcvData.map((d, i) => i < offset ? null : { time: d.time, ...bbData[i - offset] }).filter(Boolean);
                bbSetting.series[0].setData(formattedData.map(d => ({ time: d.time, value: d.upper })));
                bbSetting.series[1].setData(formattedData.map(d => ({ time: d.time, value: d.middle })));
                bbSetting.series[2].setData(formattedData.map(d => ({ time: d.time, value: d.lower })));
            }

            // RSI
            const rsiSetting = indicatorSettings.rsi;
            if (!rsiSetting.series) {
                 rsiSetting.series = chart.addLineSeries({ color: rsiSetting.color, lineWidth: 2, priceScaleId: indicatorPanes[1] });
                 // Overbought/oversold lines
                 rsiSetting.series.createPriceLine({ price: rsiSetting.overbought, color: '#787B86', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'Overbought'});
                 rsiSetting.series.createPriceLine({ price: rsiSetting.oversold, color: '#787B86', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'Oversold'});
            }
            rsiSetting.series.applyOptions({ visible: rsiSetting.active, priceScaleId: rsiSetting.active ? indicatorPanes[1] : '' });
            if (rsiSetting.active) {
                const rsiData = ti.rsi({ period: rsiSetting.period, values: closes });
                rsiSetting.series.setData(alignData(rsiData));
            }

            // MACD
            const macdSetting = indicatorSettings.macd;
            if (!macdSetting.series[0]) {
                macdSetting.series[0] = chart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceScaleId: indicatorPanes[2], priceLineVisible: false }); // MACD line
                macdSetting.series[1] = chart.addLineSeries({ color: '#FF6D00', lineWidth: 2, priceScaleId: indicatorPanes[2], priceLineVisible: false }); // Signal line
                macdSetting.series[2] = chart.addHistogramSeries({ priceScaleId: indicatorPanes[2], priceLineVisible: false }); // Histogram
            }
             macdSetting.series.forEach(s => s.applyOptions({ visible: macdSetting.active, priceScaleId: macdSetting.active ? indicatorPanes[2] : '' }));
             if (macdSetting.active) {
                const macdInput = {
                    values: closes,
                    fastPeriod: macdSetting.fastPeriod,
                    slowPeriod: macdSetting.slowPeriod,
                    signalPeriod: macdSetting.signalPeriod,
                    SimpleMAOscillator: false,
                    SimpleMASignal: false
                };
                const macdData = ti.macd(macdInput);
                const offset = currentOhlcvData.length - macdData.length;
                const formattedMacd = currentOhlcvData.map((d, i) => i < offset ? null : { time: d.time, ...macdData[i - offset] }).filter(Boolean);
                
                macdSetting.series[0].setData(formattedMacd.map(d => ({ time: d.time, value: d.MACD })));
                macdSetting.series[1].setData(formattedMacd.map(d => ({ time: d.time, value: d.signal })));
                macdSetting.series[2].setData(formattedMacd.map(d => ({ time: d.time, value: d.histogram, color: d.histogram >= 0 ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)' })));
             }
        }
        
        // --- 6. ANALYSIS & SIGNAL GENERATION ENGINE ---

        function runAnalysis() {
            const signals = [];
            const dataLength = currentOhlcvData.length;
            if (dataLength < 2) {
                summaryText.value = "Not enough data for analysis.";
                return;
            }
            
            // Get latest values
            const lastCandle = currentOhlcvData[dataLength - 1];
            const prevCandle = currentOhlcvData[dataLength - 2];

            const closes = currentOhlcvData.map(d => d.close);
            const highs = currentOhlcvData.map(d => d.high);
            const lows = currentOhlcvData.map(d => d.low);

            // --- Indicator Calculations for Analysis ---
            const rsiSetting = indicatorSettings.rsi;
            const rsi = ti.rsi({ period: rsiSetting.period, values: closes });
            const lastRsi = rsi[rsi.length - 1];

            const macdSetting = indicatorSettings.macd;
            const macdInput = { values: closes, fastPeriod: macdSetting.fastPeriod, slowPeriod: macdSetting.slowPeriod, signalPeriod: macdSetting.signalPeriod, SimpleMAOscillator: false, SimpleMASignal: false };
            const macd = ti.macd(macdInput);
            const lastMacd = macd[macd.length - 1];
            
            const bbSetting = indicatorSettings.bb;
            const bb = ti.bollingerbands({ period: bbSetting.period, values: closes, stdDev: bbSetting.stdDev });
            const lastBb = bb[bb.length - 1];
            
            const ema50Setting = indicatorSettings.ema50;
            const ema50 = ti.ema({ period: ema50Setting.period, values: closes });
            const lastEma50 = ema50[ema50.length - 1];
            
            const ema200Setting = indicatorSettings.ema200;
            const ema200 = ti.ema({ period: ema200Setting.period, values: closes });
            const lastEma200 = ema200[ema200.length - 1];
            const prevEma50 = ema50[ema50.length - 2];
            const prevEma200 = ema200[ema200.length - 2];


            // --- Signal Logic ---
            
            // 1. Strong Bullish Momentum
            if (lastRsi > 60 && lastMacd.MACD > lastMacd.signal && lastCandle.close > lastEma50) {
                signals.push("üìà Strong Bullish Momentum: RSI > 60, MACD cross up, and Price > 50-EMA.");
            }

            // 2. Strong Bearish Momentum
            if (lastRsi < 40 && lastMacd.MACD < lastMacd.signal && lastCandle.close < lastEma50) {
                signals.push("üìâ Strong Bearish Momentum: RSI < 40, MACD cross down, and Price < 50-EMA.");
            }
            
            // 3. Potential Reversal (Oversold)
            if (lastRsi < rsiSetting.oversold && (lastCandle.low <= lastBb.lower)) {
                signals.push("‚¨ÜÔ∏è Potential Reversal (Oversold): RSI is below " + rsiSetting.oversold + " and price touched the lower Bollinger Band.");
            }
            
            // 4. Potential Reversal (Overbought)
            if (lastRsi > rsiSetting.overbought && (lastCandle.high >= lastBb.upper)) {
                signals.push("‚¨áÔ∏è Potential Reversal (Overbought): RSI is above " + rsiSetting.overbought + " and price touched the upper Bollinger Band.");
            }
            
            // 5. Major Trend Signal (Golden/Death Cross)
            if (prevEma50 <= prevEma200 && lastEma50 > lastEma200) {
                signals.push("‚ú® Major Trend Signal (Golden Cross): 50-EMA crossed ABOVE 200-EMA.");
            }
            if (prevEma50 >= prevEma200 && lastEma50 < lastEma200) {
                signals.push("üíÄ Major Trend Signal (Death Cross): 50-EMA crossed BELOW 200-EMA.");
            }
            
            // 6. Bearish Divergence (Simplified)
            const lookbackPeriod = 20;
            if (dataLength > lookbackPeriod) {
                const recentHighs = highs.slice(-lookbackPeriod);
                const recentRsi = rsi.slice(-lookbackPeriod);
                const maxPrice = Math.max(...recentHighs);
                if (lastCandle.high >= maxPrice) { // Price is making a new high
                    const maxRsi = Math.max(...recentRsi);
                    if(lastRsi < maxRsi * 0.95) { // But RSI is not
                         signals.push("üìâ Possible Trend Exhaustion (Bearish Divergence): Price made a new high, but RSI did not.");
                    }
                }
            }

            // --- Display Final Analysis ---
            if (signals.length > 0) {
                summaryText.value = "Generated Signals:\n\n- " + signals.join("\n- ");
            } else {
                summaryText.value = "No strong signals detected based on the current indicator settings. Market appears to be neutral or consolidating.";
            }
        }
        
        // --- START THE APPLICATION ---
        initialize();
    });
    </script>
</body>
</html>
