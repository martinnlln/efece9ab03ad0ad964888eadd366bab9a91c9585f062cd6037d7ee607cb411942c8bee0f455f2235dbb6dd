<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⚡ QUANTUM TERMINAL PRO - Neural Trading AI</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #0f172a;
            --bg-tertiary: #1e293b;
            --bg-card: rgba(30, 41, 59, 0.8);
            --border: rgba(148, 163, 184, 0.1);
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent: #3b82f6;
            --accent-light: #60a5fa;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
        }
        
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }
        
        .app-container { display: flex; flex-direction: column; min-height: 100vh; }
        
        .header {
            position: sticky; top: 0; z-index: 1000;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            padding: 12px 16px;
        }
        
        .header-content {
            display: flex; align-items: center; gap: 12px;
            max-width: 1920px; margin: 0 auto;
        }
        
        .logo {
            font-size: 18px; font-weight: 900;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            white-space: nowrap;
        }
        
        .search-wrapper { position: relative; flex: 1; max-width: 400px; }
        
        .search-input {
            width: 100%; background: var(--bg-tertiary);
            border: 2px solid transparent; color: var(--text-primary);
            padding: 10px 16px 10px 40px; border-radius: 12px;
            font-size: 14px; font-weight: 500; transition: all 0.3s;
        }
        
        .search-input:focus {
            outline: none; border-color: var(--accent);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.1);
        }
        
        .search-icon {
            position: absolute; left: 14px; top: 50%;
            transform: translateY(-50%); color: var(--text-secondary);
            pointer-events: none;
        }
        
        .search-results {
            position: absolute; top: calc(100% + 8px);
            left: 0; right: 0; background: var(--bg-secondary);
            border: 1px solid var(--border); border-radius: 12px;
            max-height: 400px; overflow-y: auto; z-index: 9999;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            opacity: 0; transform: translateY(-10px);
            pointer-events: none; transition: all 0.3s;
        }
        
        .search-results.active { opacity: 1; transform: translateY(0); pointer-events: all; }
        
        .search-item {
            padding: 14px 16px; cursor: pointer;
            border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between;
            align-items: center; transition: background 0.2s;
        }
        
        .search-item:hover { background: rgba(59, 130, 246, 0.1); }
        
        .price-display {
            display: flex; flex-direction: column;
            align-items: flex-end; gap: 2px;
        }
        
        .price-main { font-size: 18px; font-weight: 800; white-space: nowrap; }
        .price-change { font-size: 12px; font-weight: 700; }
        
        .up { color: var(--success); }
        .down { color: var(--danger); }
        
        .main-content {
            display: grid; grid-template-columns: 1fr;
            gap: 16px; padding: 16px;
            max-width: 1920px; margin: 0 auto; width: 100%;
        }
        
        .tf-selector {
            display: flex; gap: 6px; overflow-x: auto;
            padding: 4px; background: var(--bg-secondary);
            border-radius: 12px; margin-bottom: 16px;
            -webkit-overflow-scrolling: touch;
        }
        
        .tf-btn {
            background: transparent; border: none;
            color: var(--text-secondary);
            padding: 8px 16px; border-radius: 8px;
            cursor: pointer; font-size: 13px;
            font-weight: 700; white-space: nowrap;
            transition: all 0.2s;
        }
        
        .tf-btn:hover, .tf-btn.active {
            background: var(--accent); color: white;
        }
        
        .signal-card {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.05));
            border: 2px solid rgba(59, 130, 246, 0.2);
            border-radius: 16px; padding: 20px;
            position: relative; overflow: hidden;
        }
        
        .signal-badge {
            display: inline-flex; align-items: center;
            gap: 10px; padding: 12px 20px;
            border-radius: 12px; font-weight: 900;
            font-size: 18px; margin-bottom: 16px;
        }
        
        .signal-strong-buy { background: linear-gradient(135deg, #10b981, #059669); }
        .signal-buy { background: linear-gradient(135deg, #34d399, #10b981); }
        .signal-hold { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .signal-sell { background: linear-gradient(135deg, #f87171, #ef4444); }
        .signal-strong-sell { background: linear-gradient(135deg, #ef4444, #dc2626); }
        
        .confidence-bar {
            height: 8px; background: rgba(255, 255, 255, 0.1);
            border-radius: 4px; overflow: hidden; margin-top: 8px;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-light));
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .chart-container {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 16px; padding: 16px;
            height: 500px; position: relative;
        }
        
        #chartElement { width: 100%; height: 100%; }
        
        .tabs {
            display: flex; gap: 8px; overflow-x: auto;
            padding: 4px; background: var(--bg-secondary);
            border-radius: 12px; margin-bottom: 16px;
            -webkit-overflow-scrolling: touch;
        }
        
        .tab {
            background: transparent; border: none;
            color: var(--text-secondary);
            padding: 10px 16px; border-radius: 8px;
            cursor: pointer; font-size: 13px;
            font-weight: 700; white-space: nowrap;
            transition: all 0.2s;
        }
        
        .tab:hover, .tab.active {
            background: rgba(59, 130, 246, 0.2);
            color: var(--text-primary);
        }
        
        .tab-panel { display: none; }
        .tab-panel.active {
            display: block;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .card {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 16px; padding: 16px;
        }
        
        .card-title {
            font-size: 16px; font-weight: 700;
            margin-bottom: 16px; color: var(--text-primary);
        }
        
        .indicator-item {
            background: var(--bg-tertiary);
            border-left: 3px solid transparent;
            border-radius: 10px; padding: 12px;
            margin-bottom: 10px;
        }
        
        .indicator-item.bullish { border-left-color: var(--success); }
        .indicator-item.bearish { border-left-color: var(--danger); }
        .indicator-item.neutral { border-left-color: var(--text-secondary); }
        
        .indicator-header {
            display: flex; justify-content: space-between;
            align-items: center; margin-bottom: 6px;
        }
        
        .indicator-name { font-weight: 700; font-size: 13px; }
        
        .indicator-badge {
            font-size: 10px; padding: 4px 8px;
            border-radius: 6px; font-weight: 700;
        }
        
        .badge-buy { background: rgba(16, 185, 129, 0.2); color: var(--success); }
        .badge-sell { background: rgba(239, 68, 68, 0.2); color: var(--danger); }
        .badge-neutral { background: rgba(148, 163, 184, 0.2); color: var(--text-secondary); }
        
        .indicator-value { font-size: 12px; color: var(--text-secondary); }
        
        .explanation-box {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 10px; padding: 14px;
            margin-top: 12px; font-size: 13px;
            line-height: 1.6;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }
        
        .metric-box {
            background: var(--bg-tertiary);
            padding: 14px; border-radius: 12px;
            transition: transform 0.2s;
        }
        
        .metric-box:hover { transform: translateY(-2px); }
        
        .metric-label {
            font-size: 11px; color: var(--text-secondary);
            margin-bottom: 6px; font-weight: 600;
        }
        
        .metric-value { font-size: 18px; font-weight: 800; }
        
        .market-item {
            background: var(--bg-tertiary);
            border-radius: 12px; padding: 12px;
            margin-bottom: 8px; cursor: pointer;
            transition: all 0.2s;
        }
        
        .market-item:hover {
            background: rgba(59, 130, 246, 0.1);
            transform: translateX(4px);
        }
        
        .market-header {
            display: flex; justify-content: space-between;
            align-items: center;
        }
        
        .market-symbol { font-weight: 800; font-size: 14px; }
        .market-price { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
        .market-change { font-size: 13px; font-weight: 700; padding: 4px 10px; border-radius: 6px; }
        
        .loading-overlay {
            position: fixed; inset: 0;
            background: rgba(10, 14, 26, 0.95);
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 10000; opacity: 0;
            pointer-events: none; transition: opacity 0.3s;
        }
        
        .loading-overlay.active { opacity: 1; pointer-events: all; }
        
        .spinner {
            width: 60px; height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .loading-text {
            margin-top: 20px; color: var(--text-secondary);
            font-size: 14px; font-weight: 600;
        }
        
        .notification {
            position: fixed; top: 80px; right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px; padding: 16px 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            z-index: 10001; opacity: 0;
            transform: translateX(400px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 90vw;
        }
        
        .notification.show { opacity: 1; transform: translateX(0); }
        
        .notif-title { font-weight: 800; font-size: 14px; margin-bottom: 4px; }
        .notif-body { font-size: 12px; color: var(--text-secondary); }
        
        .prediction-box {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(59, 130, 246, 0.05));
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px; padding: 16px; margin-top: 12px;
        }
        
        .prediction-row {
            display: flex; justify-content: space-between;
            align-items: center; padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .prediction-row:last-child { border-bottom: none; }
        
        .prediction-label { font-size: 12px; color: var(--text-secondary); font-weight: 600; }
        .prediction-value { font-size: 14px; font-weight: 800; }
        
        .pattern-badge {
            display: inline-block; padding: 6px 12px;
            border-radius: 8px; font-size: 11px;
            font-weight: 700; margin: 4px;
            background: rgba(59, 130, 246, 0.2);
            color: var(--accent-light);
        }
        
        .pattern-bullish { background: rgba(16, 185, 129, 0.2); color: var(--success); }
        .pattern-bearish { background: rgba(239, 68, 68, 0.2); color: var(--danger); }
        
        .breakdown-section {
            background: var(--bg-tertiary);
            border-radius: 10px; padding: 14px;
            margin-bottom: 12px;
        }
        
        .breakdown-title {
            font-weight: 700; font-size: 13px;
            color: var(--accent-light);
            margin-bottom: 10px;
        }
        
        .breakdown-item {
            display: flex; justify-content: space-between;
            align-items: center; padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 12px;
        }
        
        .breakdown-item:last-child { border-bottom: none; }
        
        .breakdown-weight {
            font-weight: 800;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
        }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.02); }
        ::-webkit-scrollbar-thumb { background: rgba(59, 130, 246, 0.3); border-radius: 3px; }
        
        @media (min-width: 1024px) {
            .main-content {
                grid-template-columns: 300px 1fr 360px;
                grid-template-rows: auto 1fr;
            }
            .tf-selector { grid-column: 2; }
            .left-panel { grid-column: 1; grid-row: 1 / -1; }
            .center-panel { grid-column: 2; grid-row: 2; }
            .right-panel { grid-column: 3; grid-row: 1 / -1; }
            .chart-container { height: calc(100vh - 220px); }
        }
        
        @media (max-width: 767px) {
            .logo { font-size: 14px; }
            .price-display { display: none; }
            .chart-container { height: 350px; }
        }
    </style>
</head>
<body>
    
    <div id="notificationArea"></div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Initializing Neural Networks...</div>
    </div>
    
    <div class="app-container">
        <div class="header">
            <div class="header-content">
                <div class="logo">⚡ QUANTUM PRO</div>
                <div class="search-wrapper">
                    <span class="search-icon">🔍</span>
                    <input type="text" id="searchInput" class="search-input" 
                           placeholder="Search markets..." autocomplete="off"/>
                    <div id="searchResults" class="search-results"></div>
                </div>
                <div class="price-display">
                    <div class="price-main" id="currentPrice">--</div>
                    <div class="price-change up" id="priceChange">+0.00%</div>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="tf-selector">
                <button class="tf-btn" data-tf="1">1m</button>
                <button class="tf-btn" data-tf="3">3m</button>
                <button class="tf-btn" data-tf="5">5m</button>
                <button class="tf-btn" data-tf="15">15m</button>
                <button class="tf-btn" data-tf="30">30m</button>
                <button class="tf-btn" data-tf="60">1H</button>
                <button class="tf-btn" data-tf="240">4H</button>
                <button class="tf-btn active" data-tf="D">1D</button>
            </div>
            
            <div class="left-panel">
                <div class="card">
                    <div class="card-title">📊 Markets</div>
                    <div id="marketsList"></div>
                </div>
            </div>
            
            <div class="center-panel">
                <div class="signal-card">
                    <div class="signal-badge signal-hold" id="signalBadge">
                        <span id="signalEmoji">⏸️</span>
                        <span id="signalText">ANALYZING</span>
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">
                        AI Confidence: <span id="confidenceText" style="font-weight: 700;">--%</span>
                    </div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
                    </div>
                    
                    <div class="explanation-box" id="signalExplanation">
                        Analyzing market conditions...
                    </div>
                    
                    <div class="prediction-box" id="predictionBox" style="display:none;">
                        <div style="font-size: 13px; font-weight: 800; margin-bottom: 12px; color: var(--accent-light);">
                            🤖 LSTM Neural Network Prediction
                        </div>
                        <div class="prediction-row">
                            <span class="prediction-label">Next Period Target:</span>
                            <span class="prediction-value" id="mlTarget">--</span>
                        </div>
                        <div class="prediction-row">
                            <span class="prediction-label">Expected Move:</span>
                            <span class="prediction-value" id="mlMove">--</span>
                        </div>
                        <div class="prediction-row">
                            <span class="prediction-label">Model Confidence:</span>
                            <span class="prediction-value" id="mlAccuracy">--</span>
                        </div>
                        <div class="prediction-row">
                            <span class="prediction-label">Training Loss:</span>
                            <span class="prediction-value" id="mlLoss">--</span>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div id="chartElement"></div>
                </div>
                
                <div class="card" style="margin-top: 16px;">
                    <div class="card-title">📈 Advanced Metrics</div>
                    <div class="metrics-grid" id="metricsGrid"></div>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="card">
                    <div class="tabs">
                        <button class="tab active" data-tab="breakdown">Breakdown</button>
                        <button class="tab" data-tab="indicators">Indicators</button>
                        <button class="tab" data-tab="ai">AI Models</button>
                        <button class="tab" data-tab="patterns">Patterns</button>
                    </div>
                    
                    <div id="breakdownTab" class="tab-panel active">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                            Signal breakdown with weighting
                        </div>
                        <div id="breakdownContent"></div>
                    </div>
                    
                    <div id="indicatorsTab" class="tab-panel">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                            12 technical indicators analyzed
                        </div>
                        <div id="indicatorsList"></div>
                    </div>
                    
                    <div id="aiTab" class="tab-panel">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                            5 specialized AI models
                        </div>
                        <div id="aiModelsList"></div>
                    </div>
                    
                    <div id="patternsTab" class="tab-panel">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                            Chart pattern detection
                        </div>
                        <div id="patternsList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('%c⚡ QUANTUM TERMINAL PRO v2.0', 'color:#3b82f6;font-size:24px;font-weight:bold;');
        console.log('%cNeural Networks | 12 Indicators | 5 AI Models | Pattern Recognition', 'color:#8b5cf6;font-size:12px;');
        
        const APP = {
            chart: null,
            candleSeries: null,
            volumeSeries: null,
            symbol: 'BTCUSDT',
            timeframe: 'D',
            data: null,
            indicators: {},
            allSymbols: [],
            mlModel: null,
            mlReady: false
        };
        
        const POPULAR_SYMBOLS = [
            { symbol: 'BTCUSDT', base: 'BTC' }, { symbol: 'ETHUSDT', base: 'ETH' },
            { symbol: 'BNBUSDT', base: 'BNB' }, { symbol: 'SOLUSDT', base: 'SOL' },
            { symbol: 'XRPUSDT', base: 'XRP' }, { symbol: 'ADAUSDT', base: 'ADA' },
            { symbol: 'DOGEUSDT', base: 'DOGE' }, { symbol: 'MATICUSDT', base: 'MATIC' },
            { symbol: 'DOTUSDT', base: 'DOT' }, { symbol: 'AVAXUSDT', base: 'AVAX' }
        ];
        
        class API {
            static async fetchSymbols() {
                const res = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                const data = await res.json();
                return data.symbols
                    .filter(s => s.status === 'TRADING' && s.quoteAsset === 'USDT')
                    .map(s => ({ symbol: s.symbol, base: s.baseAsset }));
            }
            
            static async fetchOHLCV(symbol, interval, limit = 500) {
                const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
                const res = await fetch(url);
                const data = await res.json();
                return data.map(c => ({
                    time: c[0] / 1000,
                    open: parseFloat(c[1]),
                    high: parseFloat(c[2]),
                    low: parseFloat(c[3]),
                    close: parseFloat(c[4]),
                    volume: parseFloat(c[5])
                }));
            }
            
            static async fetch24h() {
                const res = await fetch('https://api.binance.com/api/v3/ticker/24hr');
                return await res.json();
            }
            
            static mapTF(tf) {
                const map = { '1': '1m', '3': '3m', '5': '5m', '15': '15m', '30': '30m', '60': '1h', '240': '4h', 'D': '1d', 'W': '1w' };
                return map[tf] || '1d';
            }
        }
        
     class Indicators {
            static SMA(d, p) {
                const r = [];
                for (let i = 0; i < d.length; i++) {
                    if (i < p - 1) r.push(null);
                    else r.push(d.slice(i - p + 1, i + 1).reduce((a, b) => a + b, 0) / p);
                }
                return r;
            }
            
            static EMA(d, p) {
                const k = 2 / (p + 1);
                const r = [d[0]];
                for (let i = 1; i < d.length; i++) r.push(d[i] * k + r[i - 1] * (1 - k));
                return r;
            }
            
            static RSI(d, p = 14) {
                const ch = d.slice(1).map((v, i) => v - d[i]);
                const r = [null];
                for (let i = p - 1; i < ch.length; i++) {
                    const g = [], lo = [];
                    for (let j = i - p + 1; j <= i; j++) {
                        if (ch[j] > 0) g.push(ch[j]);
                        else lo.push(Math.abs(ch[j]));
                    }
                    const ag = g.length > 0 ? g.reduce((a, b) => a + b, 0) / p : 0;
                    const al = lo.length > 0 ? lo.reduce((a, b) => a + b, 0) / p : 0;
                    r.push(al === 0 ? 100 : 100 - (100 / (1 + ag / al)));
                }
                while (r.length < d.length) r.unshift(null);
                return r;
            }
            
            static MACD(d) {
                const e12 = this.EMA(d, 12);
                const e26 = this.EMA(d, 26);
                const macd = e12.map((v, i) => v - e26[i]);
                const sig = this.EMA(macd.filter(v => v !== null), 9);
                const hist = macd.slice(-sig.length).map((v, i) => v - sig[i]);
                return { macd, sig, hist };
            }
            
            static BB(d, p = 20, m = 2) {
                const sma = this.SMA(d, p);
                const u = [], lo = [];
                for (let i = 0; i < d.length; i++) {
                    if (i < p - 1) { u.push(null); lo.push(null); }
                    else {
                        const sl = d.slice(i - p + 1, i + 1);
                        const mean = sma[i];
                        const std = Math.sqrt(sl.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / p);
                        u.push(mean + m * std);
                        lo.push(mean - m * std);
                    }
                }
                return { upper: u, mid: sma, lower: lo };
            }
            
            static Stochastic(data, p = 14) {
                const r = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < p - 1) r.push(null);
                    else {
                        const slice = data.slice(i - p + 1, i + 1);
                        const h = Math.max(...slice.map(d => d.high));
                        const l = Math.min(...slice.map(d => d.low));
                        const c = data[i].close;
                        r.push(h === l ? 50 : ((c - l) / (h - l)) * 100);
                    }
                }
                return r;
            }
            
            static ATR(data, p = 14) {
                const tr = [];
                for (let i = 1; i < data.length; i++) {
                    const h = data[i].high;
                    const l = data[i].low;
                    const pc = data[i - 1].close;
                    tr.push(Math.max(h - l, Math.abs(h - pc), Math.abs(l - pc)));
                }
                return this.EMA(tr, p);
            }
            
            static ADX(data, p = 14) {
                const tr = [], pdm = [], ndm = [];
                for (let i = 1; i < data.length; i++) {
                    const h = data[i].high, l = data[i].low;
                    const ph = data[i - 1].high, pl = data[i - 1].low, pc = data[i - 1].close;
                    tr.push(Math.max(h - l, Math.abs(h - pc), Math.abs(l - pc)));
                    const hd = h - ph, ld = pl - l;
                    pdm.push(hd > ld && hd > 0 ? hd : 0);
                    ndm.push(ld > hd && ld > 0 ? ld : 0);
                }
                const atr = this.EMA(tr, p);
                const pdi = this.EMA(pdm, p).map((v, i) => (v / atr[i]) * 100);
                const ndi = this.EMA(ndm, p).map((v, i) => (v / atr[i]) * 100);
                const dx = pdi.map((v, i) => Math.abs(v - ndi[i]) / (v + ndi[i]) * 100);
                return this.EMA(dx, p);
            }
            
            static OBV(data) {
                let obv = 0;
                const r = [0];
                for (let i = 1; i < data.length; i++) {
                    if (data[i].close > data[i - 1].close) obv += data[i].volume;
                    else if (data[i].close < data[i - 1].close) obv -= data[i].volume;
                    r.push(obv);
                }
                return r;
            }
            
            static CCI(data, p = 20) {
                const tp = data.map(d => (d.high + d.low + d.close) / 3);
                const sma = this.SMA(tp, p);
                const r = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < p - 1) r.push(null);
                    else {
                        const slice = tp.slice(i - p + 1, i + 1);
                        const md = slice.reduce((sum, v) => sum + Math.abs(v - sma[i]), 0) / p;
                        r.push((tp[i] - sma[i]) / (0.015 * md));
                    }
                }
                return r;
            }
            
            static WilliamsR(data, p = 14) {
                const r = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < p - 1) r.push(null);
                    else {
                        const slice = data.slice(i - p + 1, i + 1);
                        const h = Math.max(...slice.map(d => d.high));
                        const l = Math.min(...slice.map(d => d.low));
                        const c = data[i].close;
                        r.push(h === l ? -50 : ((h - c) / (h - l)) * -100);
                    }
                }
                return r;
            }
            
            static MFI(data, p = 14) {
                const tp = data.map(d => (d.high + d.low + d.close) / 3);
                const mf = data.map((d, i) => tp[i] * d.volume);
                const r = [null];
                for (let i = p; i < data.length; i++) {
                    let posFlow = 0, negFlow = 0;
                    for (let j = i - p + 1; j <= i; j++) {
                        if (tp[j] > tp[j - 1]) posFlow += mf[j];
                        else if (tp[j] < tp[j - 1]) negFlow += mf[j];
                    }
                    const ratio = negFlow === 0 ? 100 : posFlow / negFlow;
                    r.push(100 - (100 / (1 + ratio)));
                }
                while (r.length < data.length) r.unshift(null);
                return r;
            }
            
            static VWAP(data) {
                let cumVol = 0, cumTPV = 0;
                return data.map(d => {
                    const tp = (d.high + d.low + d.close) / 3;
                    cumTPV += tp * d.volume;
                    cumVol += d.volume;
                    return cumTPV / cumVol;
                });
            }
            
            static ParabolicSAR(data, accel = 0.02, maxAccel = 0.2) {
                const r = [data[0].low];
                let trend = 1, sar = data[0].low, ep = data[0].high, af = accel;
                
                for (let i = 1; i < data.length; i++) {
                    const d = data[i];
                    sar = sar + af * (ep - sar);
                    
                    if (trend === 1) {
                        if (d.low < sar) {
                            trend = -1;
                            sar = ep;
                            ep = d.low;
                            af = accel;
                        } else {
                            if (d.high > ep) {
                                ep = d.high;
                                af = Math.min(af + accel, maxAccel);
                            }
                        }
                    } else {
                        if (d.high > sar) {
                            trend = 1;
                            sar = ep;
                            ep = d.high;
                            af = accel;
                        } else {
                            if (d.low < ep) {
                                ep = d.low;
                                af = Math.min(af + accel, maxAccel);
                            }
                        }
                    }
                    r.push(sar);
                }
                return r;
            }
            
            static ROC(d, p = 12) {
                const r = [];
                for (let i = 0; i < d.length; i++) {
                    if (i < p) r.push(null);
                    else r.push(((d[i] - d[i - p]) / d[i - p]) * 100);
                }
                return r;
            }
            
            static Aroon(data, p = 25) {
                const up = [], down = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < p) { up.push(null); down.push(null); }
                    else {
                        const slice = data.slice(i - p + 1, i + 1);
                        const highIdx = slice.reduce((max, d, idx) => d.high > slice[max].high ? idx : max, 0);
                        const lowIdx = slice.reduce((min, d, idx) => d.low < slice[min].low ? idx : min, 0);
                        up.push(((p - (p - 1 - highIdx)) / p) * 100);
                        down.push(((p - (p - 1 - lowIdx)) / p) * 100);
                    }
                }
                return { up, down };
            }
            
            static Ichimoku(data) {
                const tenkan = [], kijun = [], senkouA = [], senkouB = [];
                const p1 = 9, p2 = 26, p3 = 52;
                
                for (let i = 0; i < data.length; i++) {
                    if (i < p1 - 1) tenkan.push(null);
                    else {
                        const slice = data.slice(i - p1 + 1, i + 1);
                        tenkan.push((Math.max(...slice.map(d => d.high)) + Math.min(...slice.map(d => d.low))) / 2);
                    }
                    
                    if (i < p2 - 1) kijun.push(null);
                    else {
                        const slice = data.slice(i - p2 + 1, i + 1);
                        kijun.push((Math.max(...slice.map(d => d.high)) + Math.min(...slice.map(d => d.low))) / 2);
                    }
                    
                    if (i < p2 - 1) senkouA.push(null);
                    else senkouA.push((tenkan[i] + kijun[i]) / 2);
                    
                    if (i < p3 - 1) senkouB.push(null);
                    else {
                        const slice = data.slice(i - p3 + 1, i + 1);
                        senkouB.push((Math.max(...slice.map(d => d.high)) + Math.min(...slice.map(d => d.low))) / 2);
                    }
                }
                
                return { tenkan, kijun, senkouA, senkouB };
            }
            
            static calc(data) {
                const c = data.map(d => d.close);
                const h = data.map(d => d.high);
                const l = data.map(d => d.low);
                
                return {
                    sma20: this.SMA(c, 20),
                    sma50: this.SMA(c, 50),
                    sma200: this.SMA(c, 200),
                    ema9: this.EMA(c, 9),
                    ema12: this.EMA(c, 12),
                    ema21: this.EMA(c, 21),
                    ema26: this.EMA(c, 26),
                    ema50: this.EMA(c, 50),
                    rsi: this.RSI(c, 14),
                    macd: this.MACD(c),
                    bb: this.BB(c, 20, 2),
                    stoch: this.Stochastic(data, 14),
                    atr: this.ATR(data, 14),
                    adx: this.ADX(data, 14),
                    obv: this.OBV(data),
                    cci: this.CCI(data, 20),
                    willr: this.WilliamsR(data, 14),
                    mfi: this.MFI(data, 14),
                    vwap: this.VWAP(data),
                    psar: this.ParabolicSAR(data),
                    roc: this.ROC(c, 12),
                    aroon: this.Aroon(data, 25),
                    ichimoku: this.Ichimoku(data)
                };
            }
        }
        
        class PatternRecognition {
            static detectCandlePatterns(data) {
                const patterns = [];
                const len = data.length;
                
                for (let i = 3; i < len; i++) {
                    const c = data[i], p = data[i - 1], p2 = data[i - 2];
                    const cBody = Math.abs(c.close - c.open);
                    const pBody = Math.abs(p.close - p.open);
                    
                    if (c.close > c.open && (c.high - c.close) < cBody * 0.3 && (c.open - c.low) > cBody * 2) {
                        patterns.push({ name: 'Hammer', type: 'bullish', idx: i });
                    }
                    
                    if (c.close < c.open && (c.high - c.open) > cBody * 2 && (c.close - c.low) < cBody * 0.3) {
                        patterns.push({ name: 'Shooting Star', type: 'bearish', idx: i });
                    }
                    
                    if (c.close > c.open && p.close < p.open && c.close > p.open && c.open < p.close) {
                        patterns.push({ name: 'Bullish Engulfing', type: 'bullish', idx: i });
                    }
                    if (c.close < c.open && p.close > p.open && c.close < p.open && c.open > p.close) {
                        patterns.push({ name: 'Bearish Engulfing', type: 'bearish', idx: i });
                    }
                    
                    if (cBody < (c.high - c.low) * 0.1) {
                        patterns.push({ name: 'Doji', type: 'neutral', idx: i });
                    }
                    
                    if (p2.close < p2.open && Math.abs(p.close - p.open) < pBody * 0.3 && 
                        c.close > c.open && c.close > (p2.open + p2.close) / 2) {
                        patterns.push({ name: 'Morning Star', type: 'bullish', idx: i });
                    }
                    
                    if (p2.close > p2.open && Math.abs(p.close - p.open) < pBody * 0.3 && 
                        c.close < c.open && c.close < (p2.open + p2.close) / 2) {
                        patterns.push({ name: 'Evening Star', type: 'bearish', idx: i });
                    }
                }
                
                return patterns.slice(-5);
            }
            
            static detectTrend(data, ind) {
                const len = data.length;
                const c = data.map(d => d.close);
                const sma50 = ind.sma50[len - 1];
                const sma200 = ind.sma200[len - 1];
                const ema9 = ind.ema9[len - 1];
                const ema26 = ind.ema26[len - 1];
                const cur = c[len - 1];
                
                if (cur > ema9 && ema9 > ema26 && cur > sma50 && sma50 > sma200) {
                    return { trend: 'Strong Uptrend', strength: 'high' };
                } else if (cur > sma50 && sma50 > sma200) {
                    return { trend: 'Uptrend', strength: 'medium' };
                } else if (cur < ema9 && ema9 < ema26 && cur < sma50 && sma50 < sma200) {
                    return { trend: 'Strong Downtrend', strength: 'high' };
                } else if (cur < sma50 && sma50 < sma200) {
                    return { trend: 'Downtrend', strength: 'medium' };
                } else {
                    return { trend: 'Sideways', strength: 'low' };
                }
            }
        }
        
        class MLModel {
            static async createModel() {
                const model = tf.sequential();
                model.add(tf.layers.lstm({ units: 50, returnSequences: true, inputShape: [60, 5] }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.lstm({ units: 50, returnSequences: false }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.dense({ units: 25 }));
                model.add(tf.layers.dense({ units: 1 }));
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }
            
            static prepareData(data, lookback = 60) {
                const features = data.map(d => [
                    d.open, d.high, d.low, d.close, d.volume
                ]);
                
                const normalized = [];
                for (let i = 0; i < features[0].length; i++) {
                    const col = features.map(f => f[i]);
                    const min = Math.min(...col);
                    const max = Math.max(...col);
                    normalized.push({ min, max });
                }
                
                const normFeatures = features.map(f => f.map((v, i) => {
                    const { min, max } = normalized[i];
                    return max === min ? 0 : (v - min) / (max - min);
                }));
                
                const X = [], y = [];
                for (let i = lookback; i < normFeatures.length; i++) {
                    X.push(normFeatures.slice(i - lookback, i));
                    y.push(normFeatures[i][3]);
                }
                
                return { X, y, normalized };
            }
            
            static async trainPredict(data) {
                try {
                    if (data.length < 100) return null;
                    
                    const { X, y, normalized } = this.prepareData(data);
                    if (X.length < 10) return null;
                    
                    const splitIdx = Math.floor(X.length * 0.8);
                    const Xtrain = X.slice(0, splitIdx);
                    const ytrain = y.slice(0, splitIdx);
                    const Xtest = X.slice(splitIdx);
                    const ytest = y.slice(splitIdx);
                    
                    const model = await this.createModel();
                    
                    const Xtensor = tf.tensor3d(Xtrain);
                    const ytensor = tf.tensor2d(ytrain, [ytrain.length, 1]);
                    
                    const history = await model.fit(Xtensor, ytensor, {
                        epochs: 10,
                        batchSize: 32,
                        verbose: 0,
                        validationSplit: 0.1
                    });
                    
                    const lastSeq = tf.tensor3d([X[X.length - 1]]);
                    const pred = model.predict(lastSeq);
                    const predVal = (await pred.data())[0];
                    
                    const { min, max } = normalized[3];
                    const predPrice = predVal * (max - min) + min;
                    
                    const XtestTensor = tf.tensor3d(Xtest);
                    const ytestTensor = tf.tensor2d(ytest, [ytest.length, 1]);
                    const testPred = model.predict(XtestTensor);
                    const mae = tf.losses.absoluteDifference(ytestTensor, testPred).dataSync()[0];
                    const accuracy = Math.max(0, Math.min(100, (1 - mae) * 100));
                    
                    const finalLoss = history.history.loss[history.history.loss.length - 1];
                    
                    Xtensor.dispose();
                    ytensor.dispose();
                    lastSeq.dispose();
                    pred.dispose();
                    XtestTensor.dispose();
                    ytestTensor.dispose();
                    testPred.dispose();
                    
                    return {
                        predicted: predPrice,
                        accuracy: accuracy.toFixed(1),
                        loss: finalLoss.toFixed(6),
                        current: data[data.length - 1].close
                    };
                } catch (e) {
                    console.error('ML Error:', e);
                    return null;
                }
            }
        }
        
        class AI {
            static analyze(data, ind) {
                const c = data.map(d => d.close);
                const idx = c.length - 1;
                const cur = c[idx];
                const sigs = {};
                
                const rsi = ind.rsi[idx];
                if (rsi < 30) sigs.rsi = { sig: 'strong-buy', val: rsi, reason: 'Oversold (<30)', w: 2 };
                else if (rsi > 70) sigs.rsi = { sig: 'strong-sell', val: rsi, reason: 'Overbought (>70)', w: 2 };
                else if (rsi < 45) sigs.rsi = { sig: 'buy', val: rsi, reason: 'Bullish momentum', w: 1 };
                else if (rsi > 55) sigs.rsi = { sig: 'sell', val: rsi, reason: 'Bearish momentum', w: 1 };
                else sigs.rsi = { sig: 'neutral', val: rsi, reason: 'Neutral zone', w: 0.5 };
                
                const macd = ind.macd.hist[ind.macd.hist.length - 1];
                const pmacd = ind.macd.hist[ind.macd.hist.length - 2];
                if (macd > 0 && pmacd <= 0) sigs.macd = { sig: 'strong-buy', reason: 'Bullish crossover', w: 2 };
                else if (macd < 0 && pmacd >= 0) sigs.macd = { sig: 'strong-sell', reason: 'Bearish crossover', w: 2 };
                else if (macd > 0) sigs.macd = { sig: 'buy', reason: 'Positive histogram', w: 1 };
                else sigs.macd = { sig: 'sell', reason: 'Negative histogram', w: 1 };
                
                const sma50 = ind.sma50[idx];
                const sma200 = ind.sma200[idx];
                if (cur > sma50 && sma50 > sma200) sigs.ma = { sig: 'strong-buy', reason: 'Golden cross formation', w: 2 };
                else if (cur < sma50 && sma50 < sma200) sigs.ma = { sig: 'strong-sell', reason: 'Death cross formation', w: 2 };
                else sigs.ma = { sig: 'neutral', reason: 'Mixed MA signals', w: 0.5 };
                
                const bbu = ind.bb.upper[idx];
                const bbl = ind.bb.lower[idx];
                if (cur < bbl) sigs.bb = { sig: 'buy', reason: 'Below lower BB', w: 1.5 };
                else if (cur > bbu) sigs.bb = { sig: 'sell', reason: 'Above upper BB', w: 1.5 };
                else sigs.bb = { sig: 'neutral', reason: 'Within BB range', w: 0.5 };
                
                const stoch = ind.stoch[idx];
                if (stoch < 20) sigs.stoch = { sig: 'strong-buy', val: stoch, reason: 'Stochastic oversold', w: 1.5 };
                else if (stoch > 80) sigs.stoch = { sig: 'strong-sell', val: stoch, reason: 'Stochastic overbought', w: 1.5 };
                else sigs.stoch = { sig: 'neutral', val: stoch, reason: 'Normal range', w: 0.5 };
                
                const adx = ind.adx[ind.adx.length - 1];
                if (adx > 25) sigs.adx = { sig: 'neutral', val: adx, reason: 'Strong trend (ADX>25)', w: 1 };
                else sigs.adx = { sig: 'neutral', val: adx, reason: 'Weak trend', w: 0.5 };
                
                const cci = ind.cci[idx];
                if (cci < -100) sigs.cci = { sig: 'buy', val: cci, reason: 'CCI oversold', w: 1 };
                else if (cci > 100) sigs.cci = { sig: 'sell', val: cci, reason: 'CCI overbought', w: 1 };
                else sigs.cci = { sig: 'neutral', val: cci, reason: 'CCI normal', w: 0.5 };
                
                const willr = ind.willr[idx];
                if (willr < -80) sigs.willr = { sig: 'buy', val: willr, reason: 'Williams %R oversold', w: 1 };
                else if (willr > -20) sigs.willr = { sig: 'sell', val: willr, reason: 'Williams %R overbought', w: 1 };
                else sigs.willr = { sig: 'neutral', val: willr, reason: 'Williams %R normal', w: 0.5 };
                
                const obv = ind.obv;
                const obvTrend = obv[idx] > obv[idx - 20] ? 'buy' : 'sell';
                sigs.obv = { sig: obvTrend, reason: obvTrend === 'buy' ? 'Volume accumulation' : 'Volume distribution', w: 1 };
                
                let tot = 0, totW = 0;
                Object.values(sigs).forEach(s => {
                    const w = s.w || 1;
                    let sc = 0;
                    if (s.sig === 'strong-buy') sc = 2;
                    else if (s.sig === 'buy') sc = 1;
                    else if (s.sig === 'sell') sc = -1;
                    else if (s.sig === 'strong-sell') sc = -2;
                    tot += sc * w;
                    totW += w;
                });
                const score = tot / totW;
                
                let sig, conf;
                if (score > 0.8) {
                    sig = 'STRONG BUY';
                    conf = Math.min(95, 65 + Math.abs(score) * 30);
                } else if (score > 0.3) {
                    sig = 'BUY';
                    conf = Math.min(85, 55 + Math.abs(score) * 30);
                } else if (score > -0.3) {
                    sig = 'HOLD';
                    conf = 60;
                } else if (score > -0.8) {
                    sig = 'SELL';
                    conf = Math.min(85, 55 + Math.abs(score) * 30);
                } else {
                    sig = 'STRONG SELL';
                    conf = Math.min(95, 65 + Math.abs(score) * 30);
                }
                
                return { sig, conf: conf.toFixed(1), sigs, score };
            }
            
            static generateModels(data, ind, ana) {
                const models = [];
                
                const rsi = ind.rsi[ind.rsi.length - 1];
                const stoch = ind.stoch[ind.stoch.length - 1];
                const momScore = ((100 - rsi) + (100 - stoch)) / 2;
                models.push({
                    name: 'Momentum Model',
                    signal: momScore > 60 ? 'BUY' : momScore < 40 ? 'SELL' : 'HOLD',
                    confidence: Math.abs(momScore - 50) * 2,
                    desc: 'RSI + Stochastic momentum analysis'
                });
                
                const trendInfo = PatternRecognition.detectTrend(data, ind);
                models.push({
                    name: 'Trend Following',
                    signal: trendInfo.trend.includes('Up') ? 'BUY' : trendInfo.trend.includes('Down') ? 'SELL' : 'HOLD',
                    confidence: trendInfo.strength === 'high' ? 85 : trendInfo.strength === 'medium' ? 70 : 55,
                    desc: trendInfo.trend
                });
                
                const atr = ind.atr[ind.atr.length - 1];
                const bb = ind.bb;
                const bbWidth = ((bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1]) / bb.mid[bb.mid.length - 1]) * 100;
                models.push({
                    name: 'Volatility Model',
                    signal: bbWidth > 5 ? 'HIGH VOL' : 'LOW VOL',
                    confidence: 75,
                    desc: `BB Width: ${bbWidth.toFixed(2)}%, ATR: ${atr.toFixed(2)}`
                });
                
                const obv = ind.obv;
                const obvChange = ((obv[obv.length - 1] - obv[obv.length - 20]) / Math.abs(obv[obv.length - 20])) * 100;
                models.push({
                    name: 'Volume Model',
                    signal: obvChange > 10 ? 'BUY' : obvChange < -10 ? 'SELL' : 'HOLD',
                    confidence: Math.min(90, 50 + Math.abs(obvChange)),
                    desc: `OBV trend: ${obvChange > 0 ? '+' : ''}${obvChange.toFixed(1)}%`
                });
                
                const cur = data[data.length - 1].close;
                const sma20 = ind.sma20[ind.sma20.length - 1];
                const dev = ((cur - sma20) / sma20) * 100;
                models.push({
                    name: 'Mean Reversion',
                    signal: dev < -3 ? 'BUY' : dev > 3 ? 'SELL' : 'HOLD',
                    confidence: Math.min(85, 50 + Math.abs(dev) * 10),
                    desc: `Deviation from SMA20: ${dev > 0 ? '+' : ''}${dev.toFixed(2)}%`
                });
                
                return models;
            }
            
            static explainSignal(ana, ind, data) {
                const bullishFactors = [];
                const bearishFactors = [];
                
                Object.entries(ana.sigs).forEach(([name, sig]) => {
                    if (sig.sig.includes('buy')) {
                        bullishFactors.push(`${name.toUpperCase()}: ${sig.reason} (weight: ${sig.w}x)`);
                    } else if (sig.sig.includes('sell')) {
                        bearishFactors.push(`${name.toUpperCase()}: ${sig.reason} (weight: ${sig.w}x)`);
                    }
                });
                
                let explanation = `<strong>${ana.sig}</strong> signal generated based on ${Object.keys(ana.sigs).length} indicators with weighted scoring.<br><br>`;
                
                if (bullishFactors.length > 0) {
                    explanation += `<strong style="color: #10b981;">Bullish Factors (${bullishFactors.length}):</strong><br>`;
                    bullishFactors.forEach(f => explanation += `• ${f}<br>`);
                }
                
                if (bearishFactors.length > 0) {
                    explanation += `<br><strong style="color: #ef4444;">Bearish Factors (${bearishFactors.length}):</strong><br>`;
                    bearishFactors.forEach(f => explanation += `• ${f}<br>`);
                }
                
                explanation += `<br><strong>Final Score:</strong> ${(ana.score * 100).toFixed(1)}/100 (${ana.sig})`;
                
                return explanation;
            }
        }
        
        class UI {
            static initChart() {
                const cont = document.getElementById('chartElement');
                APP.chart = LightweightCharts.createChart(cont, {
                    layout: { background: { color: 'transparent' }, textColor: '#94a3b8' },
                    grid: { vertLines: { color: 'rgba(255,255,255,0.03)' }, horzLines: { color: 'rgba(255,255,255,0.03)' } },
                    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                    rightPriceScale: { borderColor: 'rgba(255,255,255,0.1)' },
                    timeScale: { borderColor: 'rgba(255,255,255,0.1)', timeVisible: true },
                    height: cont.offsetHeight,
                    width: cont.offsetWidth
                });
                
                APP.candleSeries = APP.chart.addCandlestickSeries({
                    upColor: '#10b981', downColor: '#ef4444',
                    borderVisible: false,
                    wickUpColor: '#10b981', wickDownColor: '#ef4444'
                });
                
                APP.volumeSeries = APP.chart.addHistogramSeries({
                    color: '#3b82f6', priceFormat: { type: 'volume' },
                    priceScaleId: '', scaleMargins: { top: 0.85, bottom: 0 }
                });
                
                const resizeObs = new ResizeObserver(() => {
                    APP.chart.applyOptions({ width: cont.offsetWidth, height: cont.offsetHeight });
                });
                resizeObs.observe(cont);
            }
            
            static loading(show, txt = '') {
                document.getElementById('loadingOverlay').classList.toggle('active', show);
                if (txt) document.getElementById('loadingText').textContent = txt;
            }
            
            static notify(title, msg) {
                const n = document.createElement('div');
                n.className = 'notification';
                n.innerHTML = `<div class="notif-title">${title}</div><div class="notif-body">${msg}</div>`;
                document.getElementById('notificationArea').appendChild(n);
                setTimeout(() => n.classList.add('show'), 100);
                setTimeout(() => { n.classList.remove('show'); setTimeout(() => n.remove(), 400); }, 4000);
            }
            
            static updatePrice(data) {
                const last = data[data.length - 1];
                const prev = data[data.length - 2];
                const chg = ((last.close - prev.close) / prev.close) * 100;
                document.getElementById('currentPrice').textContent = `$${last.close.toFixed(2)}`;
                document.getElementById('priceChange').textContent = `${chg >= 0 ? '+' : ''}${chg.toFixed(2)}%`;
                document.getElementById('priceChange').className = `price-change ${chg >= 0 ? 'up' : 'down'}`;
            }
            
            static updateSignal(ana, ind, data, mlPred) {
                const map = {
                    'STRONG BUY': { cls: 'signal-strong-buy', em: '🚀' },
                    'BUY': { cls: 'signal-buy', em: '📈' },
                    'HOLD': { cls: 'signal-hold', em: '⏸️' },
                    'SELL': { cls: 'signal-sell', em: '📉' },
                    'STRONG SELL': { cls: 'signal-strong-sell', em: '⚠️' }
                };
                const inf = map[ana.sig];
                document.getElementById('signalBadge').className = `signal-badge ${inf.cls}`;
                document.getElementById('signalEmoji').textContent = inf.em;
                document.getElementById('signalText').textContent = ana.sig;
                document.getElementById('confidenceText').textContent = `${ana.conf}%`;
                document.getElementById('confidenceFill').style.width = `${ana.conf}%`;
                
                const explanation = AI.explainSignal(ana, ind, data);
                document.getElementById('signalExplanation').innerHTML = explanation;
                
                if (mlPred) {
                    document.getElementById('predictionBox').style.display = 'block';
                    const move = ((mlPred.predicted - mlPred.current) / mlPred.current) * 100;
                    document.getElementById('mlTarget').textContent = `$${mlPred.predicted.toFixed(2)}`;
                    document.getElementById('mlMove').textContent = `${move > 0 ? '+' : ''}${move.toFixed(2)}%`;
                    document.getElementById('mlMove').style.color = move > 0 ? '#10b981' : '#ef4444';
                    document.getElementById('mlAccuracy').textContent = `${mlPred.accuracy}%`;
                    document.getElementById('mlLoss').textContent = mlPred.loss;
                } else {
                    document.getElementById('predictionBox').style.display = 'none';
                }
            }
            
            static updateBreakdown(sigs) {
                const html = Object.entries(sigs).map(([n, d]) => {
                    const tc = d.sig.includes('buy') ? 'bullish' : d.sig.includes('sell') ? 'bearish' : 'neutral';
                    const weightColor = d.w >= 2 ? '#10b981' : d.w >= 1 ? '#60a5fa' : '#94a3b8';
                    return `
                        <div class="breakdown-item">
                            <div>
                                <div style="font-weight: 700; font-size: 13px;">${n.toUpperCase()}</div>
                                <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${d.reason}</div>
                            </div>
                            <div class="breakdown-weight" style="background: rgba(${weightColor === '#10b981' ? '16, 185, 129' : weightColor === '#60a5fa' ? '96, 165, 250' : '148, 163, 184'}, 0.2); color: ${weightColor};">
                                ${d.w}x
                            </div>
                        </div>
                    `;
                }).join('');
                
                document.getElementById('breakdownContent').innerHTML = `
                    <div class="breakdown-section">
                        <div class="breakdown-title">Signal Components & Weighting</div>
                        ${html}
                    </div>
                `;
            }
            
            static updateIndicators(sigs) {
                const html = Object.entries(sigs).map(([n, d]) => {
                    const tc = d.sig.includes('buy') ? 'bullish' : d.sig.includes('sell') ? 'bearish' : 'neutral';
                    const bc = d.sig.includes('buy') ? 'badge-buy' : d.sig.includes('sell') ? 'badge-sell' : 'badge-neutral';
                    return `
                        <div class="indicator-item ${tc}">
                            <div class="indicator-header">
                                <span class="indicator-name">${n.toUpperCase()}</span>
                                <span class="indicator-badge ${bc}">${d.sig.toUpperCase()}</span>
                            </div>
                            <div class="indicator-value">${d.reason}${d.val !== undefined ? ` (${d.val.toFixed(2)})` : ''}</div>
                        </div>
                    `;
                }).join('');
                document.getElementById('indicatorsList').innerHTML = html;
            }
            
            static updateAIModels(models) {
                const html = models.map(m => {
                    const tc = m.signal.includes('BUY') ? 'bullish' : m.signal.includes('SELL') ? 'bearish' : 'neutral';
                    const bc = m.signal.includes('BUY') ? 'badge-buy' : m.signal.includes('SELL') ? 'badge-sell' : 'badge-neutral';
                    return `
                        <div class="indicator-item ${tc}">
                            <div class="indicator-header">
                                <span class="indicator-name">${m.name}</span>
                                <span class="indicator-badge ${bc}">${m.signal}</span>
                            </div>
                            <div class="indicator-value">${m.desc} • ${m.confidence.toFixed(0)}% confidence</div>
                        </div>
                    `;
                }).join('');
                document.getElementById('aiModelsList').innerHTML = html;
            }
            
            static updatePatterns(patterns, trendInfo) {
                let html = `<div style="margin-bottom: 12px;">
                    <strong style="color: var(--accent-light);">Market Trend:</strong> ${trendInfo.trend}
                </div>`;
                
                if (patterns.length > 0) {
                    html += '<div style="margin-top: 8px;">';
                    patterns.forEach(p => {
                        const cls = p.type === 'bullish' ? 'pattern-bullish' : p.type === 'bearish' ? 'pattern-bearish' : '';
                        html += `<span class="pattern-badge ${cls}">${p.name}</span>`;
                    });
                    html += '</div>';
                } else {
                    html += '<div style="color: var(--text-secondary); font-size: 12px; margin-top: 8px;">No significant patterns detected</div>';
                }
                
                document.getElementById('patternsList').innerHTML = html;
            }
            
            static updateMetrics(data, ind) {
                const c = data.map(d => d.close);
                const chg = ((c[c.length - 1] - c[0]) / c[0]) * 100;
                const hi = Math.max(...c);
                const lo = Math.min(...c);
                const volatility = ind.atr[ind.atr.length - 1];
                const adx = ind.adx[ind.adx.length - 1];
                const rsi = ind.rsi[ind.rsi.length - 1];
                const volume = data[data.length - 1].volume;
                const avgVol = data.slice(-20).reduce((sum, d) => sum + d.volume, 0) / 20;
                
                const html = `
                    <div class="metric-box">
                        <div class="metric-label">Period Return</div>
                        <div class="metric-value" style="color:${chg >= 0 ? '#10b981' : '#ef4444'}">${chg >= 0 ? '+' : ''}${chg.toFixed(2)}%</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">High</div>
                        <div class="metric-value">$${hi.toFixed(2)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Low</div>
                        <div class="metric-value">$${lo.toFixed(2)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">ATR (Volatility)</div>
                        <div class="metric-value">$${volatility.toFixed(2)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">ADX (Trend)</div>
                        <div class="metric-value">${adx.toFixed(1)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">RSI</div>
                        <div class="metric-value" style="color:${rsi < 30 ? '#10b981' : rsi > 70 ? '#ef4444' : '#94a3b8'}">${rsi.toFixed(1)}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Volume</div>
                        <div class="metric-value">${(volume / 1000000).toFixed(2)}M</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Vol vs Avg</div>
                        <div class="metric-value" style="color:${volume > avgVol ? '#10b981' : '#ef4444'}">${((volume / avgVol - 1) * 100).toFixed(0)}%</div>
                    </div>
                `;
                document.getElementById('metricsGrid').innerHTML = html;
            }
            
            static async loadMarkets() {
                try {
                    const ticks = await API.fetch24h();
                    const top = ticks.filter(t => t.symbol.endsWith('USDT')).slice(0, 10);
                    const html = top.map(t => {
                        const chg = parseFloat(t.priceChangePercent);
                        return `
                            <div class="market-item" data-symbol="${t.symbol}">
                                <div class="market-header">
                                    <div>
                                        <div class="market-symbol">${t.symbol.replace('USDT', '')}</div>
                                        <div class="market-price">$${parseFloat(t.lastPrice).toFixed(2)}</div>
                                    </div>
                                    <div class="market-change" style="background:${chg >= 0 ? 'rgba(16,185,129,0.2)' : 'rgba(239,68,68,0.2)'};color:${chg >= 0 ? '#10b981' : '#ef4444'}">
                                        ${chg >= 0 ? '+' : ''}${chg.toFixed(2)}%
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    document.getElementById('marketsList').innerHTML = html;
                    document.querySelectorAll('.market-item').forEach(el => {
                        el.addEventListener('click', () => {
                            APP.symbol = el.dataset.symbol;
                            loadData(APP.symbol, APP.timeframe);
                        });
                    });
                } catch (e) {
                    console.error('Markets error:', e);
                }
            }
        }
        
        async function loadData(sym, tf) {
            try {
                UI.loading(true, 'Loading market data...');
                const iv = API.mapTF(tf);
                const data = await API.fetchOHLCV(sym, iv, 500);
                APP.data = data;
                
                APP.candleSeries.setData(data);
                APP.volumeSeries.setData(data.map(d => ({
                    time: d.time,
                    value: d.volume,
                    color: d.close > d.open ? 'rgba(16,185,129,0.5)' : 'rgba(239,68,68,0.5)'
                })));
                
                UI.updatePrice(data);
                
                UI.loading(true, 'Calculating 12 indicators...');
                const ind = Indicators.calc(data);
                APP.indicators = ind;
                
                UI.loading(true, 'Running AI analysis (5 models)...');
                const ana = AI.analyze(data, ind);
                const models = AI.generateModels(data, ind, ana);
                
                UI.loading(true, 'Training LSTM Neural Network...');
                const mlPred = await MLModel.trainPredict(data);
                
                UI.loading(true, 'Detecting chart patterns...');
                const patterns = PatternRecognition.detectCandlePatterns(data);
                const trendInfo = PatternRecognition.detectTrend(data, ind);
                
                UI.updateSignal(ana, ind, data, mlPred);
                UI.updateBreakdown(ana.sigs);
                UI.updateIndicators(ana.sigs);
                UI.updateAIModels(models);
                UI.updatePatterns(patterns, trendInfo);
                UI.updateMetrics(data, ind);
                
                UI.loading(false);
                UI.notify('✅ Analysis Complete', `${sym} analyzed with 12 indicators, 5 AI models, and LSTM neural network`);
            } catch (e) {
                console.error(e);
                UI.loading(false);
                UI.notify('❌ Error', e.message);
            }
        }
        
        let searchTO;
        document.getElementById('searchInput').addEventListener('input', async (e) => {
            clearTimeout(searchTO);
            const q = e.target.value.toUpperCase();
            if (q.length < 1) {
                document.getElementById('searchResults').classList.remove('active');
                return;
            }
            document.getElementById('searchResults').innerHTML = '<div style="padding:20px;text-align:center;color:#94a3b8;">Searching...</div>';
            document.getElementById('searchResults').classList.add('active');
            searchTO = setTimeout(async () => {
                try {
                    if (APP.allSymbols.length === 0) {
                        try {
                            APP.allSymbols = await API.fetchSymbols();
                        } catch {
                            APP.allSymbols = POPULAR_SYMBOLS;
                        }
                    }
                    const res = APP.allSymbols.filter(s => s.base.includes(q) || s.symbol.includes(q)).slice(0, 20);
                    if (res.length === 0) {
                        document.getElementById('searchResults').innerHTML = '<div style="padding:20px;text-align:center;color:#94a3b8;">No results</div>';
                        return;
                    }
                    const html = res.map(s => `
                        <div class="search-item" data-symbol="${s.symbol}">
                            <strong style="font-size:14px;">${s.base}</strong><span style="color:#6B7280;">/USDT</span>
                        </div>
                    `).join('');
                    document.getElementById('searchResults').innerHTML = html;
                    document.querySelectorAll('.search-item').forEach(el => {
                        el.addEventListener('click', () => {
                            APP.symbol = el.dataset.symbol;
                            document.getElementById('searchInput').value = el.dataset.symbol;
                            document.getElementById('searchResults').classList.remove('active');
                            loadData(APP.symbol, APP.timeframe);
                        });
                    });
                } catch (e) {
                    document.getElementById('searchResults').innerHTML = '<div style="padding:20px;text-align:center;color:#ef4444;">Error</div>';
                }
            }, 300);
        });
        
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-wrapper')) {
                document.getElementById('searchResults').classList.remove('active');
            }
        });
        
        document.querySelectorAll('.tf-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                APP.timeframe = btn.dataset.tf;
                loadData(APP.symbol, APP.timeframe);
            });
        });
        
        document.querySelectorAll('.tab').forEach(btn => {
            btn.addEventListener('click', () => {
                const tab = btn.dataset.tab;
                const parent = btn.closest('.card');
                parent.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
                parent.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(`${tab}Tab`).classList.add('active');
            });
        });
        
        window.addEventListener('DOMContentLoaded', () => {
            UI.initChart();
            UI.loadMarkets();
            
            API.fetchSymbols()
                .then(s => { APP.allSymbols = s; })
                .catch(() => { APP.allSymbols = POPULAR_SYMBOLS; });
            
            setTimeout(() => loadData(APP.symbol, APP.timeframe), 500);
        });
    </script>
</body>
</html>
