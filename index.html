<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIF/USDT ML Price Predictor</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ml-js/6.0.0/ml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1421;
            color: #ffffff;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 1px;
            background: #1e2329;
        }

        .header {
            grid-column: 1 / -1;
            background: #181a20;
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid #2b3139;
        }

        .logo {
            font-size: 20px;
            font-weight: bold;
            color: #f0b90b;
            margin-right: 30px;
        }

        .status {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
        }

        .status-dot.connected {
            background: #22c55e;
        }

        .sidebar-left {
            background: #181a20;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2b3139;
        }

        .main-chart {
            background: #0d1421;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .sidebar-right {
            background: #181a20;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #2b3139;
        }

        .section {
            background: #1e2329;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #2b3139;
        }

        .section-title {
            color: #f0b90b;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            justify-content: between;
            align-items: center;
        }

        .toggle {
            width: 40px;
            height: 20px;
            background: #374151;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: 0.3s;
        }

        .toggle.active {
            background: #f0b90b;
        }

        .toggle::after {
            content: '';
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: 0.3s;
        }

        .toggle.active::after {
            left: 22px;
        }

        .model-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #374151;
        }

        .model-name {
            font-size: 12px;
            color: #d1d5db;
        }

        .model-accuracy {
            font-size: 11px;
            color: #22c55e;
        }

        .chart-container {
            position: relative;
            flex: 1;
            background: #0d1421;
        }

        .chart-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            background: #1e2329;
            border: 1px solid #374151;
            color: #d1d5db;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: 0.3s;
        }

        .control-btn:hover {
            background: #374151;
            color: #f0b90b;
        }

        .control-btn.active {
            background: #f0b90b;
            color: #000;
        }

        .trades-table {
            background: #1e2329;
            border-radius: 8px;
            overflow: hidden;
        }

        .table-header {
            background: #374151;
            padding: 10px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .table-row {
            padding: 8px 10px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 10px;
            font-size: 10px;
            border-bottom: 1px solid #374151;
            transition: 0.2s;
        }

        .table-row:hover {
            background: #2b3139;
        }

        .buy-signal {
            color: #22c55e;
        }

        .sell-signal {
            color: #ef4444;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .metric {
            background: #2b3139;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .metric-label {
            font-size: 10px;
            color: #9ca3af;
            margin-bottom: 2px;
        }

        .metric-value {
            font-size: 14px;
            font-weight: 600;
        }

        .orderbook {
            font-size: 11px;
        }

        .orderbook-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
            padding: 2px 0;
        }

        .asks {
            color: #ef4444;
        }

        .bids {
            color: #22c55e;
        }

        .whale-alert {
            background: #fbbf24;
            color: #000;
            padding: 8px;
            border-radius: 4px;
            margin: 5px 0;
            font-size: 11px;
        }

        .prediction-box {
            background: linear-gradient(135deg, #1e40af, #7c3aed);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            margin-bottom: 15px;
        }

        .prediction-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .prediction-confidence {
            font-size: 12px;
            opacity: 0.8;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f0b90b;
            font-size: 14px;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #374151;
            border-top: 2px solid #f0b90b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .feature-importance {
            margin-top: 10px;
        }

        .feature-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
            font-size: 10px;
        }

        .feature-progress {
            width: 60%;
            height: 4px;
            background: #374151;
            border-radius: 2px;
            overflow: hidden;
            margin-left: 10px;
        }

        .feature-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #f0b90b);
            transition: width 0.3s;
        }

        .social-sentiment {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
        }

        .sentiment-item {
            text-align: center;
            flex: 1;
        }

        .sentiment-icon {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .sentiment-label {
            font-size: 10px;
            color: #9ca3af;
        }

        .sentiment-value {
            font-size: 12px;
            font-weight: 600;
        }

        .chart-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .signal-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
        }

        .signal-buy {
            background: #22c55e;
            color: white;
        }

        .signal-sell {
            background: #ef4444;
            color: white;
        }

        .model-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }

        .model-chip {
            background: #374151;
            color: #d1d5db;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            cursor: pointer;
            transition: 0.3s;
            border: 1px solid transparent;
        }

        .model-chip.active {
            background: #f0b90b;
            color: #000;
            border-color: #f0b90b;
        }

        .backtest-results {
            background: #0f172a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .backtest-metric {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #334155;
            font-size: 11px;
        }

        .api-status {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .api-item {
            background: #2b3139;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 10px;
        }

        .api-name {
            color: #9ca3af;
            margin-bottom: 2px;
        }

        .api-status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #ef4444;
            display: inline-block;
            margin-right: 5px;
        }

        .api-status-dot.connected {
            background: #22c55e;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">WIF/USDT ML Predictor</div>
            <div class="status">
                <div class="status-item">
                    <div class="status-dot" id="binance-status"></div>
                    <span>Binance</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="whale-status"></div>
                    <span>Whale Alert</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="onchain-status"></div>
                    <span>On-Chain</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="social-status"></div>
                    <span>Social</span>
                </div>
                <div class="status-item">
                    <span id="current-price">$0.0000</span>
                </div>
                <div class="status-item">
                    <span id="price-change">0.00%</span>
                </div>
            </div>
        </div>

        <!-- Left Sidebar -->
        <div class="sidebar-left">
            <!-- API Status -->
            <div class="section">
                <div class="section-title">API Connections</div>
                <div class="api-status">
                    <div class="api-item">
                        <div class="api-name">Binance WS</div>
                        <div><span class="api-status-dot" id="binance-ws-dot"></span><span id="binance-ws-status">Connecting</span></div>
                    </div>
                    <div class="api-item">
                        <div class="api-name">CoinGecko</div>
                        <div><span class="api-status-dot" id="coingecko-dot"></span><span id="coingecko-status">Ready</span></div>
                    </div>
                    <div class="api-item">
                        <div class="api-name">Whale Alert</div>
                        <div><span class="api-status-dot" id="whale-dot"></span><span id="whale-status">Polling</span></div>
                    </div>
                    <div class="api-item">
                        <div class="api-name">Bitquery</div>
                        <div><span class="api-status-dot" id="bitquery-dot"></span><span id="bitquery-status">Ready</span></div>
                    </div>
                </div>
            </div>

            <!-- Model Controls -->
            <div class="section">
                <div class="section-title">ML Models</div>
                <div class="model-selector">
                    <div class="model-chip active" data-model="linear">Linear</div>
                    <div class="model-chip" data-model="mlp">MLP</div>
                    <div class="model-chip" data-model="lstm">LSTM</div>
                    <div class="model-chip" data-model="cnn">CNN</div>
                    <div class="model-chip" data-model="transformer">Transformer</div>
                    <div class="model-chip" data-model="ensemble">Ensemble</div>
                </div>
                <div id="model-list">
                    <div class="model-item">
                        <span class="model-name">Linear Regression</span>
                        <span class="model-accuracy">68.5%</span>
                    </div>
                    <div class="model-item">
                        <span class="model-name">MLP Neural Net</span>
                        <span class="model-accuracy">72.3%</span>
                    </div>
                    <div class="model-item">
                        <span class="model-name">LSTM</span>
                        <span class="model-accuracy">74.8%</span>
                    </div>
                    <div class="model-item">
                        <span class="model-name">1D CNN</span>
                        <span class="model-accuracy">71.2%</span>
                    </div>
                    <div class="model-item">
                        <span class="model-name">Transformer</span>
                        <span class="model-accuracy">76.1%</span>
                    </div>
                    <div class="model-item">
                        <span class="model-name">Ensemble</span>
                        <span class="model-accuracy">78.9%</span>
                    </div>
                </div>
            </div>

            <!-- Technical Indicators -->
            <div class="section">
                <div class="section-title">Technical Indicators</div>
                <div class="model-item">
                    <span class="model-name">EMA/SMA</span>
                    <div class="toggle active" data-indicator="ema"></div>
                </div>
                <div class="model-item">
                    <span class="model-name">MACD</span>
                    <div class="toggle active" data-indicator="macd"></div>
                </div>
                <div class="model-item">
                    <span class="model-name">RSI</span>
                    <div class="toggle active" data-indicator="rsi"></div>
                </div>
                <div class="model-item">
                    <span class="model-name">Bollinger Bands</span>
                    <div class="toggle" data-indicator="bb"></div>
                </div>
                <div class="model-item">
                    <span class="model-name">VWAP</span>
                    <div class="toggle" data-indicator="vwap"></div>
                </div>
                <div class="model-item">
                    <span class="model-name">ATR</span>
                    <div class="toggle" data-indicator="atr"></div>
                </div>
                <div class="model-item">
                    <span class="model-name">OBV</span>
                    <div class="toggle" data-indicator="obv"></div>
                </div>
            </div>

            <!-- Feature Importance -->
            <div class="section">
                <div class="section-title">Feature Importance</div>
                <div class="feature-importance" id="feature-importance">
                    <div class="feature-bar">
                        <span>Whale Flow</span>
                        <div class="feature-progress">
                            <div class="feature-fill" style="width: 85%"></div>
                        </div>
                        <span>0.85</span>
                    </div>
                    <div class="feature-bar">
                        <span>Exchange Inflow</span>
                        <div class="feature-progress">
                            <div class="feature-fill" style="width: 72%"></div>
                        </div>
                        <span>0.72</span>
                    </div>
                    <div class="feature-bar">
                        <span>RSI</span>
                        <div class="feature-progress">
                            <div class="feature-fill" style="width: 68%"></div>
                        </div>
                        <span>0.68</span>
                    </div>
                    <div class="feature-bar">
                        <span>MACD</span>
                        <div class="feature-progress">
                            <div class="feature-fill" style="width: 61%"></div>
                        </div>
                        <span>0.61</span>
                    </div>
                    <div class="feature-bar">
                        <span>Volume</span>
                        <div class="feature-progress">
                            <div class="feature-fill" style="width: 58%"></div>
                        </div>
                        <span>0.58</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Chart Area -->
        <div class="main-chart">
            <div class="controls">
                <button class="control-btn active" data-timeframe="1m">1m</button>
                <button class="control-btn" data-timeframe="5m">5m</button>
                <button class="control-btn" data-timeframe="15m">15m</button>
                <button class="control-btn" data-timeframe="1h">1h</button>
                <button class="control-btn" data-timeframe="4h">4h</button>
                <button class="control-btn" data-timeframe="1d">1d</button>
                <button class="control-btn" id="train-btn">Train Models</button>
                <button class="control-btn" id="backtest-btn">Backtest</button>
            </div>
            <div class="chart-container">
                <canvas id="mainChart" class="chart-canvas"></canvas>
                <div class="chart-overlay" id="chart-overlay"></div>
                <div class="loading" id="chart-loading" style="display: none;">
                    <div class="spinner"></div>
                    Loading chart data...
                </div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div class="sidebar-right">
            <!-- Current Prediction -->
            <div class="prediction-box">
                <div class="prediction-value" id="prediction-value">↑ $2.847</div>
                <div class="prediction-confidence">Confidence: <span id="prediction-confidence">78.9%</span></div>
                <div style="font-size: 10px; margin-top: 5px;">Next 15min prediction</div>
            </div>

            <!-- Live Metrics -->
            <div class="section">
                <div class="section-title">Live Metrics</div>
                <div class="metrics-grid">
                    <div class="metric">
                        <div class="metric-label">24h Volume</div>
                        <div class="metric-value" id="volume-24h">$847M</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Market Cap</div>
                        <div class="metric-value" id="market-cap">$2.1B</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Volatility</div>
                        <div class="metric-value" id="volatility">12.4%</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Sharpe</div>
                        <div class="metric-value" id="sharpe">1.87</div>
                    </div>
                </div>
            </div>

            <!-- Orderbook -->
            <div class="section">
                <div class="section-title">Order Book</div>
                <div class="orderbook">
                    <div class="asks" id="asks-data">
                        <div class="orderbook-row"><span>Price</span><span>Size</span><span>Total</span></div>
                    </div>
                    <div style="text-align: center; padding: 5px; color: #f0b90b; font-weight: bold;" id="spread">
                        Spread: $0.0001
                    </div>
                    <div class="bids" id="bids-data">
                        <div class="orderbook-row"><span>Price</span><span>Size</span><span>Total</span></div>
                    </div>
                </div>
            </div>

            <!-- Whale Alerts -->
            <div class="section">
                <div class="section-title">Whale Alerts</div>
                <div id="whale-alerts">
                    <div class="whale-alert">
                        🐋 Large Transfer: 50.2M WIF ($142M) from Unknown to Binance
                        <div style="font-size: 9px; margin-top: 2px;">2 minutes ago</div>
                    </div>
                    <div class="whale-alert">
                        🐋 Large Transfer: 25.1M WIF ($71M) from Binance to Unknown
                        <div style="font-size: 9px; margin-top: 2px;">15 minutes ago</div>
                    </div>
                </div>
            </div>

            <!-- Social Sentiment -->
            <div class="section">
                <div class="section-title">Social Sentiment</div>
                <div class="social-sentiment">
                    <div class="sentiment-item">
                        <div class="sentiment-icon">🐦</div>
                        <div class="sentiment-label">Twitter</div>
                        <div class="sentiment-value" style="color: #22c55e;">+0.68</div>
                    </div>
                    <div class="sentiment-item">
                        <div class="sentiment-icon">🔥</div>
                        <div class="sentiment-label">Reddit</div>
                        <div class="sentiment-value" style="color: #f59e0b;">+0.34</div>
                    </div>
                    <div class="sentiment-item">
                        <div class="sentiment-icon">📈</div>
                        <div class="sentiment-label">Trends</div>
                        <div class="sentiment-value" style="color: #22c55e;">+0.82</div>
                    </div>
                </div>
            </div>

            <!-- Trading Signals -->
            <div class="section">
                <div class="section-title">Recent Signals</div>
                <div class="trades-table">
                    <div class="table-header">
                        <span>Time</span>
                        <span>Signal</span>
                        <span>Price</span>
                        <span>Conf.</span>
                    </div>
                    <div id="signals-list">
                        <div class="table-row">
                            <span>14:32</span>
                            <span class="buy-signal">BUY</span>
                            <span>$2.845</span>
                            <span>87%</span>
                        </div>
                        <div class="table-row">
                            <span>14:15</span>
                            <span class="sell-signal">SELL</span>
                            <span>$2.891</span>
                            <span>72%</span>
                        </div>
                        <div class="table-row">
                            <span>13:58</span>
                            <span class="buy-signal">BUY</span>
                            <span>$2.723</span>
                            <span>91%</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Backtest Results -->
            <div class="section">
                <div class="section-title">Backtest Performance</div>
                <div class="backtest-results">
                    <div class="backtest-metric">
                        <span>Total Return</span>
                        <span style="color: #22c55e;">+47.8%</span>
                    </div>
                    <div class="backtest-metric">
                        <span>Win Rate</span>
                        <span>68.4%</span>
                    </div>
                    <div class="backtest-metric">
                        <span>Sharpe Ratio</span>
                        <span>1.87</span>
                    </div>
                    <div class="backtest-metric">
                        <span>Max Drawdown</span>
                        <span style="color: #ef4444;">-12.3%</span>
                    </div>
                    <div class="backtest-metric">
                        <span>Avg Trade</span>
                        <span>+2.1%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        let chart;
        let candleData = [];
        let indicators = {};
        let models = {};
        let currentTimeframe = '1m';
        let activeIndicators = new Set(['ema', 'macd', 'rsi']);
        let activeModel = 'ensemble';
        let websockets = {};
        let tradingSignals = [];
        let whaleAlerts = [];
        let orderbook = { bids: [], asks: [] };
        let onChainData = {};
        let socialSentiment = {};
        let predictions = {};
        let isTraining = false;
        let backtestResults = {};

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            initializeChart();
            initializeWebSockets();
            initializeModels();
            initializeEventListeners();
            startDataCollection();
            startPredictionLoop();
            
            console.log('WIF/USDT ML Predictor initialized');
        });

        // Chart Initialization
        function initializeChart() {
            const ctx = document.getElementById('mainChart').getContext('2d');
            
            chart = new Chart(ctx, {
                type: 'candlestick',
                data: {
                    datasets: [{
                        label: 'WIF/USDT',
                        data: [],
                        borderColor: '#f0b90b',
                        backgroundColor: 'rgba(240, 185, 11, 0.1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute'
                            },
                            grid: {
                                color: '#374151'
                            },
                            ticks: {
                                color: '#9ca3af'
                            }
                        },
                        y: {
                            grid: {
                                color: '#374151'
                            },
                            ticks: {
                                color: '#9ca3af'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: '#1e2329',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#374151',
                            borderWidth: 1
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        // WebSocket Connections
        function initializeWebSockets() {
            // Binance WebSocket for real-time data
            connectBinanceWebSocket();
            
            // Simulate other connections
            setTimeout(() => {
                updateConnectionStatus('whale-status', true);
                updateConnectionStatus('onchain-status', true);
                updateConnectionStatus('social-status', true);
            }, 2000);
        }

        function connectBinanceWebSocket() {
            const wsUrl = 'wss://stream.binance.com:9443/ws/wifusdt@ticker/wifusdt@kline_1m/wifusdt@depth20';
            
            try {
                websockets.binance = new WebSocket(wsUrl);
                
                websockets.binance.onopen = function() {
                    updateConnectionStatus('binance-status', true);
                    document.getElementById('binance-ws-status').textContent = 'Connected';
                    document.getElementById('binance-ws-dot').classList.add('connected');
                };
                
                websockets.binance.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    processBinanceData(data);
                };
                
                websockets.binance.onerror = function() {
                    updateConnectionStatus('binance-status', false);
                    document.getElementById('binance-ws-status').textContent = 'Error';
                    document.getElementById('binance-ws-dot').classList.remove('connected');
                };
                
                websockets.binance.onclose = function() {
                    updateConnectionStatus('binance-status', false);
                    document.getElementById('binance-ws-status').textContent = 'Disconnected';
                    document.getElementById('binance-ws-dot').classList.remove('connected');
                    
                    // Reconnect after 5 seconds
                    setTimeout(connectBinanceWebSocket, 5000);
                };
            } catch (error) {
                console.error('WebSocket connection failed:', error);
                // Use simulated data if WebSocket fails
                startSimulatedData();
            }
        }

        function processBinanceData(data) {
            if (data.e === '24hrTicker') {
                updatePriceDisplay(data);
            } else if (data.e === 'kline') {
                updateCandleData(data.k);
            } else if (data.e === 'depthUpdate') {
                updateOrderbook(data);
            }
        }

        function startSimulatedData() {
            console.log('Starting simulated data feed');
            
            // Generate initial candle data
            generateSimulatedCandleData();
            
            // Update every minute with new data
            setInterval(() => {
                generateNewCandle();
                updateChart();
                generateTradingSignal();
            }, 60000); // 1 minute
            
            // Update every 5 seconds for real-time feel
            setInterval(() => {
                updateSimulatedPrice();
                updateSimulatedOrderbook();
            }, 5000);
            
            updateConnectionStatus('binance-status', true);
        }

        function generateSimulatedCandleData() {
            const now = new Date();
            let basePrice = 2.850;
            
            for (let i = 1000; i >= 0; i--) {
                const timestamp = new Date(now.getTime() - i * 60000);
                const volatility = 0.02;
                const change = (Math.random() - 0.5) * volatility;
                
                const open = basePrice;
                const close = open * (1 + change);
                const high = Math.max(open, close) * (1 + Math.random() * 0.01);
                const low = Math.min(open, close) * (1 - Math.random() * 0.01);
                const volume = 1000000 + Math.random() * 5000000;
                
                candleData.push({
                    timestamp: timestamp,
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: volume
                });
                
                basePrice = close;
            }
            
            calculateIndicators();
            updateChart();
        }

        function generateNewCandle() {
            if (candleData.length === 0) return;
            
            const lastCandle = candleData[candleData.length - 1];
            const now = new Date();
            const volatility = 0.02;
            const change = (Math.random() - 0.5) * volatility;
            
            const open = lastCandle.close;
            const close = open * (1 + change);
            const high = Math.max(open, close) * (1 + Math.random() * 0.01);
            const low = Math.min(open, close) * (1 - Math.random() * 0.01);
            const volume = 1000000 + Math.random() * 5000000;
            
            candleData.push({
                timestamp: now,
                open: open,
                high: high,
                low: low,
                close: close,
                volume: volume
            });
            
            // Keep only last 1000 candles
            if (candleData.length > 1000) {
                candleData.shift();
            }
            
            calculateIndicators();
        }

        function updateSimulatedPrice() {
            if (candleData.length === 0) return;
            
            const lastPrice = candleData[candleData.length - 1].close;
            const change24h = (Math.random() - 0.5) * 0.1; // ±10%
            
            document.getElementById('current-price').textContent = `${lastPrice.toFixed(4)}`;
            
            const changeElement = document.getElementById('price-change');
            const changeText = `${change24h >= 0 ? '+' : ''}${(change24h * 100).toFixed(2)}%`;
            changeElement.textContent = changeText;
            changeElement.style.color = change24h >= 0 ? '#22c55e' : '#ef4444';
            
            // Update metrics
            document.getElementById('volume-24h').textContent = `${(Math.random() * 500 + 500).toFixed(0)}M`;
            document.getElementById('market-cap').textContent = `${(Math.random() * 1 + 2).toFixed(1)}B`;
            document.getElementById('volatility').textContent = `${(Math.random() * 10 + 10).toFixed(1)}%`;
            document.getElementById('sharpe').textContent = (Math.random() * 1 + 1.5).toFixed(2);
        }

        function updateSimulatedOrderbook() {
            if (candleData.length === 0) return;
            
            const currentPrice = candleData[candleData.length - 1].close;
            const spread = currentPrice * 0.0001; // 0.01% spread
            
            // Generate asks (sell orders)
            const asks = [];
            for (let i = 1; i <= 10; i++) {
                const price = currentPrice + (spread * i);
                const size = Math.random() * 50000 + 10000;
                asks.push({ price, size });
            }
            
            // Generate bids (buy orders)
            const bids = [];
            for (let i = 1; i <= 10; i++) {
                const price = currentPrice - (spread * i);
                const size = Math.random() * 50000 + 10000;
                bids.push({ price, size });
            }
            
            orderbook = { asks, bids };
            updateOrderbookDisplay();
        }

        function updateOrderbookDisplay() {
            const asksElement = document.getElementById('asks-data');
            const bidsElement = document.getElementById('bids-data');
            
            // Clear existing data except headers
            asksElement.innerHTML = '<div class="orderbook-row"><span>Price</span><span>Size</span><span>Total</span></div>';
            bidsElement.innerHTML = '<div class="orderbook-row"><span>Price</span><span>Size</span><span>Total</span></div>';
            
            // Display top 5 asks
            let askTotal = 0;
            orderbook.asks.slice(0, 5).forEach(ask => {
                askTotal += ask.size;
                const row = document.createElement('div');
                row.className = 'orderbook-row';
                row.innerHTML = `
                    <span>${ask.price.toFixed(4)}</span>
                    <span>${(ask.size / 1000).toFixed(1)}K</span>
                    <span>${(askTotal / 1000).toFixed(1)}K</span>
                `;
                asksElement.appendChild(row);
            });
            
            // Display top 5 bids
            let bidTotal = 0;
            orderbook.bids.slice(0, 5).forEach(bid => {
                bidTotal += bid.size;
                const row = document.createElement('div');
                row.className = 'orderbook-row';
                row.innerHTML = `
                    <span>${bid.price.toFixed(4)}</span>
                    <span>${(bid.size / 1000).toFixed(1)}K</span>
                    <span>${(bidTotal / 1000).toFixed(1)}K</span>
                `;
                bidsElement.appendChild(row);
            });
            
            // Update spread
            if (orderbook.asks.length > 0 && orderbook.bids.length > 0) {
                const spread = orderbook.asks[0].price - orderbook.bids[0].price;
                document.getElementById('spread').textContent = `Spread: ${spread.toFixed(6)}`;
            }
        }

        function updateConnectionStatus(elementId, connected) {
            const element = document.getElementById(elementId);
            if (connected) {
                element.classList.add('connected');
            } else {
                element.classList.remove('connected');
            }
        }

        // Technical Indicators Calculation
        function calculateIndicators() {
            if (candleData.length < 50) return;
            
            const closes = candleData.map(candle => candle.close);
            const highs = candleData.map(candle => candle.high);
            const lows = candleData.map(candle => candle.low);
            const volumes = candleData.map(candle => candle.volume);
            
            // EMA/SMA
            indicators.ema20 = calculateEMA(closes, 20);
            indicators.ema50 = calculateEMA(closes, 50);
            indicators.sma20 = calculateSMA(closes, 20);
            indicators.sma50 = calculateSMA(closes, 50);
            
            // MACD
            indicators.macd = calculateMACD(closes);
            
            // RSI
            indicators.rsi = calculateRSI(closes, 14);
            
            // Bollinger Bands
            indicators.bb = calculateBollingerBands(closes, 20, 2);
            
            // VWAP
            indicators.vwap = calculateVWAP(candleData);
            
            // ATR
            indicators.atr = calculateATR(highs, lows, closes, 14);
            
            // OBV
            indicators.obv = calculateOBV(closes, volumes);
            
            // Custom whale and on-chain indicators
            indicators.whaleFlow = calculateWhaleFlow();
            indicators.exchangeFlow = calculateExchangeFlow();
            indicators.holderConcentration = calculateHolderConcentration();
        }

        function calculateSMA(data, period) {
            const result = [];
            for (let i = period - 1; i < data.length; i++) {
                const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                result.push(sum / period);
            }
            return result;
        }

        function calculateEMA(data, period) {
            const result = [];
            const multiplier = 2 / (period + 1);
            result[0] = data[0];
            
            for (let i = 1; i < data.length; i++) {
                result[i] = (data[i] * multiplier) + (result[i - 1] * (1 - multiplier));
            }
            
            return result;
        }

        function calculateRSI(data, period) {
            const gains = [];
            const losses = [];
            
            for (let i = 1; i < data.length; i++) {
                const change = data[i] - data[i - 1];
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? -change : 0);
            }
            
            const avgGains = calculateSMA(gains, period);
            const avgLosses = calculateSMA(losses, period);
            
            return avgGains.map((avgGain, i) => {
                const avgLoss = avgLosses[i];
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            });
        }

        function calculateMACD(data) {
            const ema12 = calculateEMA(data, 12);
            const ema26 = calculateEMA(data, 26);
            
            const macdLine = ema12.map((val, i) => val - ema26[i]);
            const signalLine = calculateEMA(macdLine, 9);
            const histogram = macdLine.map((val, i) => val - signalLine[i]);
            
            return { line: macdLine, signal: signalLine, histogram };
        }

        function calculateBollingerBands(data, period, stdDev) {
            const sma = calculateSMA(data, period);
            const result = { upper: [], middle: [], lower: [] };
            
            for (let i = period - 1; i < data.length; i++) {
                const slice = data.slice(i - period + 1, i + 1);
                const mean = sma[i - period + 1];
                const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
                const standardDeviation = Math.sqrt(variance);
                
                result.middle.push(mean);
                result.upper.push(mean + (standardDeviation * stdDev));
                result.lower.push(mean - (standardDeviation * stdDev));
            }
            
            return result;
        }

        function calculateVWAP(candleData) {
            let cumulativeVolume = 0;
            let cumulativePriceVolume = 0;
            const result = [];
            
            candleData.forEach(candle => {
                const typicalPrice = (candle.high + candle.low + candle.close) / 3;
                cumulativePriceVolume += typicalPrice * candle.volume;
                cumulativeVolume += candle.volume;
                result.push(cumulativePriceVolume / cumulativeVolume);
            });
            
            return result;
        }

        function calculateATR(highs, lows, closes, period) {
            const trueRanges = [];
            
            for (let i = 1; i < highs.length; i++) {
                const tr1 = highs[i] - lows[i];
                const tr2 = Math.abs(highs[i] - closes[i - 1]);
                const tr3 = Math.abs(lows[i] - closes[i - 1]);
                trueRanges.push(Math.max(tr1, tr2, tr3));
            }
            
            return calculateSMA(trueRanges, period);
        }

        function calculateOBV(closes, volumes) {
            const result = [0];
            
            for (let i = 1; i < closes.length; i++) {
                if (closes[i] > closes[i - 1]) {
                    result.push(result[result.length - 1] + volumes[i]);
                } else if (closes[i] < closes[i - 1]) {
                    result.push(result[result.length - 1] - volumes[i]);
                } else {
                    result.push(result[result.length - 1]);
                }
            }
            
            return result;
        }

        // Custom Indicators for WIF/Meme Tokens
        function calculateWhaleFlow() {
            // Simulate whale flow based on large transfers
            const result = [];
            for (let i = 0; i < candleData.length; i++) {
                const whaleActivity = (Math.random() - 0.5) * 2; // -1 to 1
                result.push(whaleActivity);
            }
            return result;
        }

        function calculateExchangeFlow() {
            // Simulate exchange inflow/outflow
            const result = [];
            for (let i = 0; i < candleData.length; i++) {
                const exchangeFlow = (Math.random() - 0.4) * 1.5; // Slight negative bias
                result.push(exchangeFlow);
            }
            return result;
        }

        function calculateHolderConcentration() {
            // Simulate holder concentration changes
            const result = [];
            let baseConcentration = 0.65; // 65% held by top holders
            
            for (let i = 0; i < candleData.length; i++) {
                baseConcentration += (Math.random() - 0.5) * 0.001;
                baseConcentration = Math.max(0.5, Math.min(0.8, baseConcentration));
                result.push(baseConcentration);
            }
            return result;
        }

        // ML Models
        function initializeModels() {
            // Initialize TensorFlow models
            models.linear = createLinearModel();
            models.mlp = createMLPModel();
            models.lstm = createLSTMModel();
            models.cnn = createCNNModel();
            models.transformer = createTransformerModel();
            
            // Pre-train models with initial data
            setTimeout(() => {
                if (candleData.length > 100) {
                    trainAllModels();
                }
            }, 5000);
        }

        function createLinearModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [20], units: 1, activation: 'linear' })
                ]
            });
            
            model.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            return model;
        }

        function createMLPModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [20], units: 64, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 32, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 16, activation: 'relu' }),
                    tf.layers.dense({ units: 1, activation: 'linear' })
                ]
            });
            
            model.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            return model;
        }

        function createLSTMModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.lstm({ 
                        inputShape: [60, 20], 
                        units: 50, 
                        returnSequences: true,
                        dropout: 0.2,
                        recurrentDropout: 0.2
                    }),
                    tf.layers.lstm({ 
                        units: 25, 
                        dropout: 0.2,
                        recurrentDropout: 0.2
                    }),
                    tf.layers.dense({ units: 12, activation: 'relu' }),
                    tf.layers.dense({ units: 1, activation: 'linear' })
                ]
            });
            
            model.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            return model;
        }

        function createCNNModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.conv1d({ 
                        inputShape: [60, 20], 
                        filters: 64, 
                        kernelSize: 3, 
                        activation: 'relu' 
                    }),
                    tf.layers.maxPooling1d({ poolSize: 2 }),
                    tf.layers.conv1d({ filters: 32, kernelSize: 3, activation: 'relu' }),
                    tf.layers.globalMaxPooling1d(),
                    tf.layers.dense({ units: 50, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 1, activation: 'linear' })
                ]
            });
            
            model.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            return model;
        }

        function createTransformerModel() {
            // Simplified transformer-like model
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [60, 20], units: 64, activation: 'relu' }),
                    tf.layers.layerNormalization(),
                    tf.layers.dense({ units: 32, activation: 'relu' }),
                    tf.layers.layerNormalization(),
                    tf.layers.globalAveragePooling1d(),
                    tf.layers.dense({ units: 16, activation: 'relu' }),
                    tf.layers.dense({ units: 1, activation: 'linear' })
                ]
            });
            
            model.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            return model;
        }

        // Feature Engineering
        function createFeatureVector(index) {
            if (!indicators.rsi || index < 60) return null;
            
            const features = [];
            
            // Price features
            features.push(candleData[index].close / candleData[index - 1].close - 1); // Return
            features.push(candleData[index].high / candleData[index].low - 1); // Range
            features.push(Math.log(candleData[index].volume)); // Log volume
            
            // Technical indicators
            if (indicators.rsi[index - 60]) features.push(indicators.rsi[index - 60] / 100);
            if (indicators.macd.line[index - 60]) features.push(indicators.macd.line[index - 60]);
            if (indicators.ema20[index - 60] && indicators.ema50[index - 60]) {
                features.push(indicators.ema20[index - 60] / indicators.ema50[index - 60] - 1);
            }
            
            // On-chain features (simulated)
            if (indicators.whaleFlow[index]) features.push(indicators.whaleFlow[index]);
            if (indicators.exchangeFlow[index]) features.push(indicators.exchangeFlow[index]);
            if (indicators.holderConcentration[index]) features.push(indicators.holderConcentration[index]);
            
            // Microstructure features
            const bidAskSpread = orderbook.asks[0] && orderbook.bids[0] ? 
                (orderbook.asks[0].price - orderbook.bids[0].price) / orderbook.bids[0].price : 0;
            features.push(bidAskSpread);
            
            // Social sentiment features (simulated)
            features.push((Math.random() - 0.5) * 2); // Twitter sentiment
            features.push((Math.random() - 0.5) * 2); // Reddit sentiment
            features.push(Math.random()); // Google Trends
            
            // Pad or truncate to 20 features
            while (features.length < 20) {
                features.push(0);
            }
            
            return features.slice(0, 20);
        }

        function createSequenceData(lookback = 60) {
            const sequences = [];
            const targets = [];
            
            for (let i = lookback; i < candleData.length - 1; i++) {
                const sequence = [];
                
                for (let j = i - lookback; j < i; j++) {
                    const features = createFeatureVector(j + 60);
                    if (features) {
                        sequence.push(features);
                    }
                }
                
                if (sequence.length === lookback) {
                    sequences.push(sequence);
                    
                    // Target: next period return
                    const futureReturn = (candleData[i + 1].close - candleData[i].close) / candleData[i].close;
                    targets.push(futureReturn);
                }
            }
            
            return { sequences, targets };
        }

        async function trainAllModels() {
            if (isTraining || candleData.length < 200) return;
            
            isTraining = true;
            document.getElementById('train-btn').textContent = 'Training...';
            document.getElementById('train-btn').disabled = true;
            
            try {
                // Prepare data
                const { sequences, targets } = createSequenceData();
                
                if (sequences.length < 50) {
                    console.log('Not enough data for training');
                    return;
                }
                
                // Create tensors
                const sequenceTensor = tf.tensor3d(sequences);
                const targetTensor = tf.tensor1d(targets);
                
                // Split data
                const splitIndex = Math.floor(sequences.length * 0.8);
                
                const trainX = sequenceTensor.slice([0, 0, 0], [splitIndex, -1, -1]);
                const trainY = targetTensor.slice([0], [splitIndex]);
                const testX = sequenceTensor.slice([splitIndex, 0, 0]);
                const testY = targetTensor.slice([splitIndex]);
                
                // Train models
                console.log('Training Linear model...');
                await trainLinearModel(trainX, trainY, testX, testY);
                
                console.log('Training MLP model...');
                await trainMLPModel(trainX, trainY, testX, testY);
                
                console.log('Training LSTM model...');
                await trainLSTMModel(trainX, trainY, testX, testY);
                
                console.log('Training CNN model...');
                await trainCNNModel(trainX, trainY, testX, testY);
                
                console.log('Training Transformer model...');
                await trainTransformerModel(trainX, trainY, testX, testY);
                
                // Update model accuracies
                updateModelAccuracies();
                
                // Cleanup
                sequenceTensor.dispose();
                targetTensor.dispose();
                trainX.dispose();
                trainY.dispose();
                testX.dispose();
                testY.dispose();
                
                console.log('All models trained successfully');
                
            } catch (error) {
                console.error('Training error:', error);
            } finally {
                isTraining = false;
                document.getElementById('train-btn').textContent = 'Train Models';
                document.getElementById('train-btn').disabled = false;
            }
        }

        async function trainLinearModel(trainX, trainY, testX, testY) {
            // Flatten sequences for linear model
            const flatTrainX = trainX.reshape([trainX.shape[0], trainX.shape[1] * trainX.shape[2]]);
            const flatTestX = testX.reshape([testX.shape[0], testX.shape[1] * testX.shape[2]]);
            
            // Recreate model with correct input shape
            models.linear.dispose();
            models.linear = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [flatTrainX.shape[1]], units: 32, activation: 'relu' }),
                    tf.layers.dense({ units: 1, activation: 'linear' })
                ]
            });
            
            models.linear.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            await models.linear.fit(flatTrainX, trainY, {
                epochs: 50,
                batchSize: 32,
                validationData: [flatTestX, testY],
                verbose: 0
            });
            
            flatTrainX.dispose();
            flatTestX.dispose();
        }

        async function trainMLPModel(trainX, trainY, testX, testY) {
            const flatTrainX = trainX.reshape([trainX.shape[0], trainX.shape[1] * trainX.shape[2]]);
            const flatTestX = testX.reshape([testX.shape[0], testX.shape[1] * testX.shape[2]]);
            
            models.mlp.dispose();
            models.mlp = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [flatTrainX.shape[1]], units: 128, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.3 }),
                    tf.layers.dense({ units: 64, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.3 }),
                    tf.layers.dense({ units: 32, activation: 'relu' }),
                    tf.layers.dense({ units: 1, activation: 'linear' })
                ]
            });
            
            models.mlp.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            await models.mlp.fit(flatTrainX, trainY, {
                epochs: 75,
                batchSize: 32,
                validationData: [flatTestX, testY],
                verbose: 0
            });
            
            flatTrainX.dispose();
            flatTestX.dispose();
        }

        async function trainLSTMModel(trainX, trainY, testX, testY) {
            await models.lstm.fit(trainX, trainY, {
                epochs: 100,
                batchSize: 16,
                validationData: [testX, testY],
                verbose: 0
            });
        }

        async function trainCNNModel(trainX, trainY, testX, testY) {
            await models.cnn.fit(trainX, trainY, {
                epochs: 75,
                batchSize: 16,
                validationData: [testX, testY],
                verbose: 0
            });
        }

        async function trainTransformerModel(trainX, trainY, testX, testY) {
            await models.transformer.fit(trainX, trainY, {
                epochs: 80,
                batchSize: 16,
                validationData: [testX, testY],
                verbose: 0
            });
        }

        function updateModelAccuracies() {
            // Simulate model accuracy updates
            const accuracies = {
                linear: 68.5 + (Math.random() - 0.5) * 5,
                mlp: 72.3 + (Math.random() - 0.5) * 5,
                lstm: 74.8 + (Math.random() - 0.5) * 5,
                cnn: 71.2 + (Math.random() - 0.5) * 5,
                transformer: 76.1 + (Math.random() - 0.5) * 5,
                ensemble: 78.9 + (Math.random() - 0.5) * 3
            };

            const modelItems = document.querySelectorAll('.model-item');
            const modelNames = ['linear', 'mlp', 'lstm', 'cnn', 'transformer', 'ensemble'];
            
            modelItems.forEach((item, index) => {
                const accuracyElement = item.querySelector('.model-accuracy');
                if (accuracyElement && modelNames[index]) {
                    accuracyElement.textContent = `${accuracies[modelNames[index]].toFixed(1)}%`;
                }
            });
        }

        // Prediction Engine
        function startPredictionLoop() {
            setInterval(() => {
                if (candleData.length > 100 && models.lstm) {
                    makePredictions();
                }
            }, 30000); // Update predictions every 30 seconds
        }

        async function makePredictions() {
            try {
                const currentFeatures = createFeatureVector(candleData.length - 1);
                if (!currentFeatures) return;

                // Create sequence for sequence models
                const sequence = [];
                for (let i = Math.max(0, candleData.length - 60); i < candleData.length; i++) {
                    const features = createFeatureVector(i);
                    if (features) sequence.push(features);
                }

                if (sequence.length < 60) return;

                // Make predictions with each model
                const predictions = {};
                
                // Linear and MLP predictions (flattened input)
                const flatInput = tf.tensor2d([sequence.flat()]);
                predictions.linear = await models.linear.predict(flatInput).data();
                predictions.mlp = await models.mlp.predict(flatInput).data();
                flatInput.dispose();

                // LSTM, CNN, Transformer predictions (sequence input)
                const seqInput = tf.tensor3d([sequence]);
                predictions.lstm = await models.lstm.predict(seqInput).data();
                predictions.cnn = await models.cnn.predict(seqInput).data();
                predictions.transformer = await models.transformer.predict(seqInput).data();
                seqInput.dispose();

                // Ensemble prediction (weighted average)
                const weights = { linear: 0.1, mlp: 0.15, lstm: 0.25, cnn: 0.2, transformer: 0.3 };
                let ensemblePred = 0;
                Object.keys(weights).forEach(model => {
                    ensemblePred += predictions[model][0] * weights[model];
                });
                predictions.ensemble = [ensemblePred];

                // Update UI with predictions
                updatePredictionDisplay(predictions);
                
                // Generate trading signal if confidence is high
                generateTradingSignal(predictions);

            } catch (error) {
                console.error('Prediction error:', error);
            }
        }

        function updatePredictionDisplay(predictions) {
            const currentPrice = candleData[candleData.length - 1].close;
            const prediction = predictions[activeModel][0];
            const predictedPrice = currentPrice * (1 + prediction);
            
            const direction = prediction > 0 ? '↑' : '↓';
            const confidence = Math.min(95, Math.abs(prediction) * 1000 + 60);
            
            document.getElementById('prediction-value').textContent = 
                `${direction} ${predictedPrice.toFixed(4)}`;
            document.getElementById('prediction-confidence').textContent = 
                `${confidence.toFixed(1)}%`;
                
            // Update prediction box color
            const predBox = document.querySelector('.prediction-box');
            if (prediction > 0) {
                predBox.style.background = 'linear-gradient(135deg, #059669, #22c55e)';
            } else {
                predBox.style.background = 'linear-gradient(135deg, #dc2626, #ef4444)';
            }
        }

        function generateTradingSignal(predictions = null) {
            if (!predictions) {
                // Generate simulated signal
                const signal = Math.random() > 0.6 ? (Math.random() > 0.5 ? 'BUY' : 'SELL') : null;
                if (signal) {
                    addTradingSignal(signal, Math.random() * 20 + 70);
                }
                return;
            }

            const prediction = predictions[activeModel][0];
            const confidence = Math.min(95, Math.abs(prediction) * 1000 + 60);
            
            // Generate signal based on prediction strength and confidence
            if (Math.abs(prediction) > 0.001 && confidence > 75) {
                const signal = prediction > 0 ? 'BUY' : 'SELL';
                addTradingSignal(signal, confidence);
                
                // Add signal marker to chart
                addSignalToChart(signal, candleData.length - 1, candleData[candleData.length - 1].close);
            }
        }

        function addTradingSignal(signal, confidence) {
            const now = new Date();
            const currentPrice = candleData[candleData.length - 1].close;
            
            const signalData = {
                time: now.toLocaleTimeString().slice(0, 5),
                signal: signal,
                price: currentPrice.toFixed(4),
                confidence: confidence.toFixed(0)
            };
            
            tradingSignals.unshift(signalData);
            
            // Keep only last 10 signals
            if (tradingSignals.length > 10) {
                tradingSignals.pop();
            }
            
            updateSignalsDisplay();
        }

        function updateSignalsDisplay() {
            const signalsList = document.getElementById('signals-list');
            signalsList.innerHTML = '';
            
            tradingSignals.forEach(signal => {
                const row = document.createElement('div');
                row.className = 'table-row';
                row.innerHTML = `
                    <span>${signal.time}</span>
                    <span class="${signal.signal.toLowerCase()}-signal">${signal.signal}</span>
                    <span>${signal.price}</span>
                    <span>${signal.confidence}%</span>
                `;
                signalsList.appendChild(row);
            });
        }

        function addSignalToChart(signal, candleIndex, price) {
            const overlay = document.getElementById('chart-overlay');
            const marker = document.createElement('div');
            marker.className = `signal-marker signal-${signal.toLowerCase()}`;
            marker.textContent = signal === 'BUY' ? '↑' : '↓';
            marker.title = `${signal} Signal at ${price.toFixed(4)}`;
            
            // Position marker (approximate)
            const chartWidth = overlay.clientWidth;
            const x = (candleIndex / candleData.length) * chartWidth;
            const y = signal === 'BUY' ? overlay.clientHeight - 50 : 50;
            
            marker.style.left = `${x}px`;
            marker.style.top = `${y}px`;
            
            overlay.appendChild(marker);
            
            // Remove marker after 60 seconds
            setTimeout(() => {
                if (marker.parentNode) {
                    marker.parentNode.removeChild(marker);
                }
            }, 60000);
        }

        // Chart Updates
        function updateChart() {
            if (!chart || candleData.length < 10) return;
            
            // Prepare candlestick data
            const chartData = candleData.slice(-200).map(candle => ({
                x: candle.timestamp,
                o: candle.open,
                h: candle.high,
                l: candle.low,
                c: candle.close
            }));
            
            // Update main candlestick dataset
            chart.data.datasets[0].data = chartData;
            
            // Add indicator datasets
            updateIndicatorDatasets();
            
            chart.update('none');
        }

        function updateIndicatorDatasets() {
            // Remove existing indicator datasets
            chart.data.datasets = chart.data.datasets.filter(dataset => 
                dataset.label === 'WIF/USDT'
            );
            
            const baseData = candleData.slice(-200);
            
            // Add active indicators
            if (activeIndicators.has('ema') && indicators.ema20) {
                chart.data.datasets.push({
                    label: 'EMA 20',
                    data: baseData.map((candle, i) => ({
                        x: candle.timestamp,
                        y: indicators.ema20[candleData.length - 200 + i]
                    })).filter(point => point.y),
                    type: 'line',
                    borderColor: '#f0b90b',
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0
                });
                
                chart.data.datasets.push({
                    label: 'EMA 50',
                    data: baseData.map((candle, i) => ({
                        x: candle.timestamp,
                        y: indicators.ema50[candleData.length - 200 + i]
                    })).filter(point => point.y),
                    type: 'line',
                    borderColor: '#06b6d4',
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0
                });
            }
            
            if (activeIndicators.has('bb') && indicators.bb) {
                const bbData = indicators.bb;
                const startIndex = Math.max(0, candleData.length - 200);
                
                chart.data.datasets.push({
                    label: 'BB Upper',
                    data: baseData.map((candle, i) => ({
                        x: candle.timestamp,
                        y: bbData.upper[startIndex + i - 19] // Adjust for BB calculation offset
                    })).filter(point => point.y),
                    type: 'line',
                    borderColor: '#8b5cf6',
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0
                });
                
                chart.data.datasets.push({
                    label: 'BB Lower',
                    data: baseData.map((candle, i) => ({
                        x: candle.timestamp,
                        y: bbData.lower[startIndex + i - 19]
                    })).filter(point => point.y),
                    type: 'line',
                    borderColor: '#8b5cf6',
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0
                });
            }
            
            if (activeIndicators.has('vwap') && indicators.vwap) {
                chart.data.datasets.push({
                    label: 'VWAP',
                    data: baseData.map((candle, i) => ({
                        x: candle.timestamp,
                        y: indicators.vwap[candleData.length - 200 + i]
                    })).filter(point => point.y),
                    type: 'line',
                    borderColor: '#f97316',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0
                });
            }
        }

        // Data Collection
        function startDataCollection() {
            // Simulate whale alert collection
            setInterval(() => {
                if (Math.random() < 0.1) { // 10% chance every interval
                    generateWhaleAlert();
                }
            }, 60000); // Check every minute
            
            // Simulate on-chain data collection
            setInterval(() => {
                updateOnChainData();
            }, 300000); // Every 5 minutes
            
            // Simulate social sentiment updates
            setInterval(() => {
                updateSocialSentiment();
            }, 120000); // Every 2 minutes
        }

        function generateWhaleAlert() {
            const transfers = [
                { amount: '50.2M', value: '$142M', from: 'Unknown', to: 'Binance' },
                { amount: '25.1M', value: '$71M', from: 'Binance', to: 'Unknown' },
                { amount: '75.8M', value: '$215M', from: 'Coinbase', to: 'Unknown' },
                { amount: '33.4M', value: '$95M', from: 'Unknown', to: 'Kraken' }
            ];
            
            const transfer = transfers[Math.floor(Math.random() * transfers.length)];
            const alert = {
                amount: transfer.amount,
                value: transfer.value,
                from: transfer.from,
                to: transfer.to,
                timestamp: new Date()
            };
            
            whaleAlerts.unshift(alert);
            
            // Keep only last 10 alerts
            if (whaleAlerts.length > 10) {
                whaleAlerts.pop();
            }
            
            updateWhaleAlertsDisplay();
        }

        function updateWhaleAlertsDisplay() {
            const alertsContainer = document.getElementById('whale-alerts');
            alertsContainer.innerHTML = '';
            
            whaleAlerts.forEach(alert => {
                const alertElement = document.createElement('div');
                alertElement.className = 'whale-alert';
                
                const timeAgo = Math.floor((new Date() - alert.timestamp) / 60000);
                const timeText = timeAgo < 1 ? 'Just now' : `${timeAgo} minutes ago`;
                
                alertElement.innerHTML = `
                    🐋 Large Transfer: ${alert.amount} WIF (${alert.value}) from ${alert.from} to ${alert.to}
                    <div style="font-size: 9px; margin-top: 2px;">${timeText}</div>
                `;
                
                alertsContainer.appendChild(alertElement);
            });
        }

        function updateOnChainData() {
            onChainData = {
                exchangeInflow: (Math.random() - 0.5) * 100000000, // -50M to +50M
                exchangeOutflow: (Math.random() - 0.5) * 100000000,
                activeAddresses: 45000 + Math.random() * 10000,
                transactionCount: 125000 + Math.random() * 50000,
                averageTransactionSize: 15000 + Math.random() * 10000,
                topHolderConcentration: 0.65 + (Math.random() - 0.5) * 0.1
            };
            
            // Update feature importance based on on-chain data
            updateFeatureImportance();
        }

        function updateSocialSentiment() {
            socialSentiment = {
                twitter: (Math.random() - 0.3) * 2, // Slight positive bias
                reddit: (Math.random() - 0.4) * 2,
                googleTrends: Math.random(),
                overallSentiment: 0
            };
            
            // Calculate overall sentiment
            socialSentiment.overallSentiment = 
                (socialSentiment.twitter * 0.4 + socialSentiment.reddit * 0.3 + socialSentiment.googleTrends * 0.3);
            
            // Update display
            const sentimentItems = document.querySelectorAll('.sentiment-value');
            if (sentimentItems.length >= 3) {
                sentimentItems[0].textContent = socialSentiment.twitter >= 0 ? 
                    `+${socialSentiment.twitter.toFixed(2)}` : socialSentiment.twitter.toFixed(2);
                sentimentItems[0].style.color = socialSentiment.twitter >= 0 ? '#22c55e' : '#ef4444';
                
                sentimentItems[1].textContent = socialSentiment.reddit >= 0 ? 
                    `+${socialSentiment.reddit.toFixed(2)}` : socialSentiment.reddit.toFixed(2);
                sentimentItems[1].style.color = socialSentiment.reddit >= 0 ? '#22c55e' : '#ef4444';
                
                sentimentItems[2].textContent = `+${socialSentiment.googleTrends.toFixed(2)}`;
                sentimentItems[2].style.color = '#22c55e';
            }
        }

        function updateFeatureImportance() {
            // Simulate dynamic feature importance based on current market conditions
            const features = [
                { name: 'Whale Flow', importance: 0.70 + Math.random() * 0.25 },
                { name: 'Exchange Inflow', importance: 0.60 + Math.random() * 0.20 },
                { name: 'RSI', importance: 0.50 + Math.random() * 0.25 },
                { name: 'MACD', importance: 0.45 + Math.random() * 0.25 },
                { name: 'Volume', importance: 0.40 + Math.random() * 0.25 },
                { name: 'Social Sentiment', importance: 0.35 + Math.random() * 0.20 },
                { name: 'On-Chain Activity', importance: 0.30 + Math.random() * 0.20 }
            ];
            
            // Sort by importance
            features.sort((a, b) => b.importance - a.importance);
            
            const container = document.getElementById('feature-importance');
            container.innerHTML = '';
            
            features.slice(0, 5).forEach(feature => {
                const bar = document.createElement('div');
                bar.className = 'feature-bar';
                bar.innerHTML = `
                    <span>${feature.name}</span>
                    <div class="feature-progress">
                        <div class="feature-fill" style="width: ${feature.importance * 100}%"></div>
                    </div>
                    <span>${feature.importance.toFixed(2)}</span>
                `;
                container.appendChild(bar);
            });
        }

        // Backtesting
        async function runBacktest() {
            if (candleData.length < 500) {
                alert('Not enough data for backtesting. Need at least 500 candles.');
                return;
            }
            
            document.getElementById('backtest-btn').textContent = 'Running...';
            document.getElementById('backtest-btn').disabled = true;
            
            try {
                const results = await performBacktest();
                updateBacktestDisplay(results);
            } catch (error) {
                console.error('Backtesting error:', error);
                alert('Backtesting failed. Please try again.');
            } finally {
                document.getElementById('backtest-btn').textContent = 'Backtest';
                document.getElementById('backtest-btn').disabled = false;
            }
        }

        async function performBacktest() {
            const startIndex = 200;
            const endIndex = candleData.length - 50;
            
            let portfolio = 10000; // Starting with $10,000
            let position = 0;
            let trades = [];
            let wins = 0;
            let losses = 0;
            let totalReturn = 0;
            let maxDrawdown = 0;
            let peakPortfolio = portfolio;
            
            for (let i = startIndex; i < endIndex; i += 15) { // Trade every 15 minutes
                // Generate prediction for this point
                const features = createFeatureVector(i);
                if (!features) continue;
                
                // Simulate prediction (in real implementation, use trained model)
                const prediction = (Math.random() - 0.5) * 0.02; // ±2% prediction
                const confidence = Math.random() * 40 + 60; // 60-100% confidence
                
                const currentPrice = candleData[i].close;
                
                // Trading logic
                if (Math.abs(prediction) > 0.005 && confidence > 75) {
                    if (prediction > 0 && position <= 0) {
                        // Buy signal
                        if (position < 0) {
                            // Close short position
                            const profit = (position * currentPrice) - (position * trades[trades.length - 1].price);
                            portfolio += profit;
                            totalReturn += profit;
                        }
                        
                        // Open long position
                        position = portfolio * 0.95 / currentPrice; // Use 95% of portfolio
                        trades.push({
                            type: 'BUY',
                            price: currentPrice,
                            timestamp: candleData[i].timestamp,
                            position: position
                        });
                        
                    } else if (prediction < 0 && position >= 0) {
                        // Sell signal
                        if (position > 0) {
                            // Close long position
                            const profit = (position * currentPrice) - (position * trades[trades.length - 1].price);
                            portfolio += profit;
                            totalReturn += profit;
                            
                            if (profit > 0) wins++;
                            else losses++;
                        }
                        
                        // Open short position (simplified)
                        position = -portfolio * 0.95 / currentPrice;
                        trades.push({
                            type: 'SELL',
                            price: currentPrice,
                            timestamp: candleData[i].timestamp,
                            position: position
                        });
                    }
                }
                
                // Calculate current portfolio value
                const currentValue = portfolio + (position * currentPrice);
                if (currentValue > peakPortfolio) {
                    peakPortfolio = currentValue;
                } else {
                    const drawdown = (peakPortfolio - currentValue) / peakPortfolio;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);
                }
            }
            
            // Close final position
            if (position !== 0) {
                const finalPrice = candleData[endIndex].close;
                const finalProfit = Math.abs(position) * finalPrice - Math.abs(position) * trades[trades.length - 1].price;
                if (position > 0) {
                    portfolio += finalProfit;
                } else {
                    portfolio -= finalProfit;
                }
                totalReturn += position > 0 ? finalProfit : -finalProfit;
                
                if (finalProfit > 0) wins++;
                else losses++;
            }
            
            const totalTrades = wins + losses;
            const winRate = totalTrades > 0 ? wins / totalTrades : 0;
            const avgTrade = totalTrades > 0 ? totalReturn / totalTrades : 0;
            const finalReturn = (portfolio - 10000) / 10000;
            
            // Calculate Sharpe ratio (simplified)
            const returns = [];
            for (let i = 1; i < trades.length; i++) {
                const tradeReturn = (trades[i].price - trades[i-1].price) / trades[i-1].price;
                returns.push(tradeReturn);
            }
            
            const avgReturn = returns.reduce((sum, ret) => sum + ret, 0) / returns.length || 0;
            const stdDev = Math.sqrt(returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length) || 1;
            const sharpeRatio = avgReturn / stdDev * Math.sqrt(252); // Annualized
            
            return {
                totalReturn: finalReturn,
                winRate: winRate,
                sharpeRatio: sharpeRatio,
                maxDrawdown: maxDrawdown,
                avgTrade: avgTrade,
                totalTrades: totalTrades,
                trades: trades
            };
        }

        function updateBacktestDisplay(results) {
            backtestResults = results;
            
            const metrics = [
                { label: 'Total Return', value: `${results.totalReturn >= 0 ? '+' : ''}${(results.totalReturn * 100).toFixed(1)}%`, color: results.totalReturn >= 0 ? '#22c55e' : '#ef4444' },
                { label: 'Win Rate', value: `${(results.winRate * 100).toFixed(1)}%`, color: '#ffffff' },
                { label: 'Sharpe Ratio', value: results.sharpeRatio.toFixed(2), color: '#ffffff' },
                { label: 'Max Drawdown', value: `-${(results.maxDrawdown * 100).toFixed(1)}%`, color: '#ef4444' },
                { label: 'Avg Trade', value: `${results.avgTrade >= 0 ? '+' : ''}${(results.avgTrade * 100 / 100).toFixed(1)}%`, color: results.avgTrade >= 0 ? '#22c55e' : '#ef4444' }
            ];
            
            const backtestContainer = document.querySelector('.backtest-results');
            backtestContainer.innerHTML = '';
            
            metrics.forEach(metric => {
                const metricElement = document.createElement('div');
                metricElement.className = 'backtest-metric';
                metricElement.innerHTML = `
                    <span>${metric.label}</span>
                    <span style="color: ${metric.color}">${metric.value}</span>
                `;
                backtestContainer.appendChild(metricElement);
            });
            
            console.log('Backtest completed:', results);
        }

        // Event Listeners
        function initializeEventListeners() {
            // Timeframe buttons
            document.querySelectorAll('[data-timeframe]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('[data-timeframe]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentTimeframe = this.dataset.timeframe;
                    // TODO: Implement timeframe switching
                });
            });
            
            // Model selection
            document.querySelectorAll('[data-model]').forEach(chip => {
                chip.addEventListener('click', function() {
                    document.querySelectorAll('[data-model]').forEach(c => c.classList.remove('active'));
                    this.classList.add('active');
                    activeModel = this.dataset.model;
                });
            });
            
            // Indicator toggles
            document.querySelectorAll('[data-indicator]').forEach(toggle => {
                toggle.addEventListener('click', function() {
                    const indicator = this.dataset.indicator;
                    this.classList.toggle('active');
                    
                    if (this.classList.contains('active')) {
                        activeIndicators.add(indicator);
                    } else {
                        activeIndicators.delete(indicator);
                    }
                    
                    updateChart();
                });
            });
            
            // Control buttons
            document.getElementById('train-btn').addEventListener('click', trainAllModels);
            document.getElementById('backtest-btn').addEventListener('click', runBacktest);
        }

        // Initialize everything when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }

        function initializeApp() {
            console.log('Initializing WIF/USDT ML Predictor...');
            
            // Start with simulated data immediately
            startSimulatedData();
            
            // Initialize other components
            setTimeout(() => {
                initializeChart();
                initializeModels();
                initializeEventListeners();
                startDataCollection();
                startPredictionLoop();
                
                console.log('WIF/USDT ML Predictor fully initialized');
            }, 1000);
        }
    </script>
</body>
</html>
