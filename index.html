<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIF/USDT Advanced Trading Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #ffffff;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(90deg, #1e3c72 0%, #2a5298 100%);
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0,255,136,0.3);
        }

        .price-ticker {
            display: flex;
            gap: 30px;
            align-items: center;
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
        }

        .price-info {
            text-align: center;
        }

        .price-value {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
        }

        .price-change {
            font-size: 12px;
            margin-top: 2px;
        }

        .positive { color: #00ff88; }
        .negative { color: #ff4444; }

        .main-container {
            display: grid;
            grid-template-columns: 250px 1fr 300px;
            grid-template-rows: 1fr;
            height: calc(100vh - 80px);
            gap: 10px;
            padding: 10px;
        }

        .sidebar {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .indicator-group {
            margin-bottom: 25px;
        }

        .indicator-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
            border: 1px solid transparent;
        }

        .indicator-item:hover {
            background: rgba(0,255,136,0.1);
            border-color: rgba(0,255,136,0.3);
            transform: translateX(5px);
        }

        .indicator-value {
            font-weight: bold;
            font-size: 12px;
        }

        .chart-container {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .timeframe-buttons {
            display: flex;
            gap: 5px;
        }

        .timeframe-btn {
            padding: 8px 15px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .timeframe-btn.active,
        .timeframe-btn:hover {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            border-color: #00ff88;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,255,136,0.3);
        }

        .chart-wrapper {
            position: relative;
            flex: 1;
            min-height: 400px;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .panel h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 16px;
            text-align: center;
        }

        .prediction-card {
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }

        .prediction-price {
            font-size: 20px;
            font-weight: bold;
            color: #00ff88;
        }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff88);
            transition: width 0.5s ease;
        }

        .signal-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 4px solid transparent;
        }

        .signal-buy { border-left-color: #00ff88; }
        .signal-sell { border-left-color: #ff4444; }
        .signal-hold { border-left-color: #ffaa00; }

        .news-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .news-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-2px);
        }

        .news-title {
            font-size: 12px;
            margin-bottom: 5px;
            line-height: 1.3;
        }

        .news-time {
            font-size: 10px;
            color: #888;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-connected { background: #00ff88; }
        .status-disconnected { background: #ff4444; }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }

        .loading-spinner {
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 3px solid #00ff88;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            color: #ff4444;
            text-align: center;
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
            }
            
            .header-content {
                flex-direction: column;
                gap: 10px;
            }
            
            .price-ticker {
                flex-wrap: wrap;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">WIF/USDT Advanced Trading Platform</div>
            <div class="price-ticker">
                <div class="price-info">
                    <div class="price-value" id="currentPrice">Loading...</div>
                    <div class="price-change" id="priceChange">--</div>
                </div>
                <div class="price-info">
                    <div class="price-value" id="volume24h">--</div>
                    <div style="font-size: 12px; color: #888;">24h Volume</div>
                </div>
                <div class="price-info">
                    <div class="price-value" id="marketCap">--</div>
                    <div style="font-size: 12px; color: #888;">Market Cap</div>
                </div>
                <div style="display: flex; align-items: center;">
                    <span class="status-indicator status-disconnected" id="connectionStatus"></span>
                    <span style="font-size: 12px;" id="connectionText">Connecting...</span>
                </div>
            </div>
        </div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <div class="indicator-group">
                <h3>Trend Indicators</h3>
                <div class="indicator-item">
                    <span>SMA (20)</span>
                    <span class="indicator-value" id="sma20">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>EMA (20)</span>
                    <span class="indicator-value" id="ema20">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>MACD</span>
                    <span class="indicator-value" id="macd">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>Bollinger Upper</span>
                    <span class="indicator-value" id="bbUpper">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>Bollinger Lower</span>
                    <span class="indicator-value" id="bbLower">Loading...</span>
                </div>
            </div>

            <div class="indicator-group">
                <h3>Momentum</h3>
                <div class="indicator-item">
                    <span>RSI (14)</span>
                    <span class="indicator-value" id="rsi">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>Stochastic</span>
                    <span class="indicator-value" id="stoch">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>Williams %R</span>
                    <span class="indicator-value" id="willR">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>CCI</span>
                    <span class="indicator-value" id="cci">Loading...</span>
                </div>
            </div>

            <div class="indicator-group">
                <h3>Volume</h3>
                <div class="indicator-item">
                    <span>OBV</span>
                    <span class="indicator-value" id="obv">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>VWAP</span>
                    <span class="indicator-value" id="vwap">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>MFI</span>
                    <span class="indicator-value" id="mfi">Loading...</span>
                </div>
            </div>

            <div class="indicator-group">
                <h3>Volatility</h3>
                <div class="indicator-item">
                    <span>ATR</span>
                    <span class="indicator-value" id="atr">Loading...</span>
                </div>
                <div class="indicator-item">
                    <span>Volatility</span>
                    <span class="indicator-value" id="volatility">Loading...</span>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-controls">
                <div class="timeframe-buttons">
                    <button class="timeframe-btn" data-timeframe="1m">1m</button>
                    <button class="timeframe-btn" data-timeframe="5m">5m</button>
                    <button class="timeframe-btn" data-timeframe="15m">15m</button>
                    <button class="timeframe-btn" data-timeframe="1h">1h</button>
                    <button class="timeframe-btn active" data-timeframe="4h">4h</button>
                    <button class="timeframe-btn" data-timeframe="1d">1d</button>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="priceChart"></canvas>
            </div>
        </div>

        <div class="right-panel">
            <div class="panel">
                <h3>AI Predictions</h3>
                <div class="prediction-card">
                    <div style="font-size: 14px; margin-bottom: 5px;">Next Hour Prediction</div>
                    <div class="prediction-price" id="prediction1h">Loading...</div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidence1h" style="width: 0%"></div>
                    </div>
                    <div style="font-size: 12px;" id="confidence1hText">Analyzing...</div>
                </div>

                <div id="modelAccuracyContainer">
                    <div style="text-align: center; margin: 10px 0;">
                        <div style="font-size: 16px; font-weight: bold; color: #00ff88;" id="modelAccuracy">Loading...</div>
                        <div style="font-size: 12px; color: #aaa;">Model Accuracy</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Trading Signals</h3>
                <div id="signalsContainer">
                    <div class="loading-spinner"></div>
                </div>
            </div>

            <div class="panel">
                <h3>Market Data</h3>
                <div id="marketDataContainer">
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class WIFTradingPlatform {
            constructor() {
                this.ws = null;
                this.currentPrice = 0;
                this.priceData = [];
                this.historicalData = [];
                this.indicators = {};
                this.chart = null;
                this.currentTimeframe = '4h';
                this.isConnected = false;
                this.models = {};
                this.lastUpdateTime = 0;
                
                this.initialize();
            }

            async initialize() {
                this.initializeChart();
                await this.fetchHistoricalData();
                this.connectWebSocket();
                this.initializeEventListeners();
                this.initializeMLModels();
                this.startPeriodicUpdates();
            }

            initializeChart() {
                const ctx = document.getElementById('priceChart').getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'WIF/USDT',
                            data: [],
                            borderColor: '#00ff88',
                            backgroundColor: 'rgba(0, 255, 136, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#ffffff' }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            },
                            y: {
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            }
                        }
                    }
                });
            }

            async fetchHistoricalData() {
                try {
                    console.log('Fetching historical WIF/USDT data from Binance...');
                    
                    // Get historical klines from Binance
                    const response = await fetch(
                        `https://api.binance.com/api/v3/klines?symbol=WIFUSDT&interval=${this.currentTimeframe}&limit=500`
                    );
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const klines = await response.json();
                    
                    if (!Array.isArray(klines)) {
                        throw new Error('Invalid response format from Binance API');
                    }
                    
                    this.historicalData = klines.map(kline => ({
                        timestamp: new Date(kline[0]),
                        open: parseFloat(kline[1]),
                        high: parseFloat(kline[2]),
                        low: parseFloat(kline[3]),
                        close: parseFloat(kline[4]),
                        volume: parseFloat(kline[5])
                    }));

                    this.priceData = this.historicalData.map(d => ({
                        timestamp: d.timestamp,
                        price: d.close,
                        volume: d.volume,
                        high: d.high,
                        low: d.low,
                        open: d.open
                    }));

                    if (this.priceData.length > 0) {
                        this.currentPrice = this.priceData[this.priceData.length - 1].price;
                        this.calculateTechnicalIndicators();
                        this.updateChart();
                        this.generateMLPredictions();
                    }

                    console.log(`Loaded ${this.historicalData.length} historical data points`);
                    
                } catch (error) {
                    console.error('Error fetching historical data:', error);
                    this.showError('Failed to fetch historical data from Binance API');
                }
            }

            connectWebSocket() {
                try {
                    console.log('Connecting to Binance WebSocket...');
                    
                    // Connect to Binance WebSocket for real-time WIF/USDT ticker data
                    this.ws = new WebSocket('wss://stream.binance.com:9443/ws/wifusdt@ticker');
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        this.updateConnectionStatus(true);
                        console.log('WebSocket connected successfully');
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.processRealTimeData(data);
                        } catch (error) {
                            console.error('Error parsing WebSocket data:', error);
                        }
                    };

                    this.ws.onclose = (event) => {
                        this.isConnected = false;
                        this.updateConnectionStatus(false);
                        console.log('WebSocket disconnected:', event.reason);
                        
                        // Reconnect after 5 seconds
                        setTimeout(() => {
                            this.connectWebSocket();
                        }, 5000);
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.isConnected = false;
                        this.updateConnectionStatus(false);
                    };
                    
                } catch (error) {
                    console.error('Error initializing WebSocket:', error);
                    this.showError('Failed to connect to Binance WebSocket');
                }
            }

            processRealTimeData(data) {
                if (!data || typeof data.c === 'undefined') {
                    console.warn('Invalid ticker data received');
                    return;
                }

                // Update current price and ticker information
                this.currentPrice = parseFloat(data.c);
                const change24h = parseFloat(data.P);
                const volume24h = parseFloat(data.v);

                // Update price ticker display
                this.updatePriceTicker(this.currentPrice, change24h, volume24h);

                // Add new data point (limit frequency to avoid too many updates)
                const now = Date.now();
                if (now - this.lastUpdateTime > 1000) { // Update max once per second
                    this.priceData.push({
                        timestamp: new Date(),
                        price: this.currentPrice,
                        volume: volume24h,
                        high: parseFloat(data.h),
                        low: parseFloat(data.l),
                        open: parseFloat(data.o)
                    });

                    // Keep only recent data points
                    if (this.priceData.length > 1000) {
                        this.priceData.shift();
                    }

                    this.calculateTechnicalIndicators();
                    this.updateChart();
                    this.generateMLPredictions();
                    this.updateTradingSignals();
                    
                    this.lastUpdateTime = now;
                }
            }

            updatePriceTicker(price, change24h, volume24h) {
                document.getElementById('currentPrice').textContent = `$${price.toFixed(4)}`;
                
                const changeElement = document.getElementById('priceChange');
                changeElement.textContent = `${change24h >= 0 ? '+' : ''}${change24h.toFixed(2)}%`;
                changeElement.className = `price-change ${change24h >= 0 ? 'positive' : 'negative'}`;

                document.getElementById('volume24h').textContent = this.formatLargeNumber(volume24h);
                
                // Calculate approximate market cap (this would need real circulating supply data)
                const estimatedMarketCap = price * 999000000; // Approximate circulating supply
                document.getElementById('marketCap').textContent = this.formatLargeNumber(estimatedMarketCap);
            }

            updateConnectionStatus(connected) {
                const statusElement = document.getElementById('connectionStatus');
                const textElement = document.getElementById('connectionText');
                
                if (connected) {
                    statusElement.className = 'status-indicator status-connected';
                    textElement.textContent = 'Live Data';
                } else {
                    statusElement.className = 'status-indicator status-disconnected';
                    textElement.textContent = 'Disconnected';
                }
            }

            calculateTechnicalIndicators() {
                if (this.priceData.length < 50) return;

                const prices = this.priceData.map(d => d.price);
                const highs = this.priceData.map(d => d.high || d.price);
                const lows = this.priceData.map(d => d.low || d.price);
                const volumes = this.priceData.map(d => d.volume);

                // Calculate all technical indicators
                this.indicators = {
                    sma20: this.calculateSMA(prices, 20),
                    ema20: this.calculateEMA(prices, 20),
                    rsi: this.calculateRSI(prices, 14),
                    macd: this.calculateMACD(prices, 12, 26, 9),
                    bb: this.calculateBollingerBands(prices, 20, 2),
                    stoch: this.calculateStochastic(highs, lows, prices, 14),
                    willR: this.calculateWilliamsR(highs, lows, prices, 14),
                    cci: this.calculateCCI(highs, lows, prices, 14),
                    atr: this.calculateATR(highs, lows, prices, 14),
                    obv: this.calculateOBV(prices, volumes),
                    vwap: this.calculateVWAP(prices, volumes),
                    mfi: this.calculateMFI(highs, lows, prices, volumes, 14),
                    volatility: this.calculateVolatility(prices, 20)
                };

                this.updateIndicatorDisplay();
            }

            calculateSMA(prices, period) {
                if (prices.length < period) return null;
                const sum = prices.slice(-period).reduce((a, b) => a + b, 0);
                return sum / period;
            }

            calculateEMA(prices, period) {
                if (prices.length < period) return null;
                
                const multiplier = 2 / (period + 1);
                let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
                
                for (let i = period; i < prices.length; i++) {
                    ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
                }
                
                return ema;
            }

            calculateRSI(prices, period) {
                if (prices.length < period + 1) return null;
                
                let gains = 0, losses = 0;
                
                for (let i = prices.length - period; i < prices.length; i++) {
                    const change = prices[i] - prices[i - 1];
                    if (change > 0) gains += change;
                    else losses -= change;
                }
                
                const avgGain = gains / period;
                const avgLoss = losses / period;
                
                if (avgLoss === 0) return 100;
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }

            calculateMACD(prices, fastPeriod, slowPeriod, signalPeriod) {
                if (prices.length < slowPeriod) return null;
                
                const emaFast = this.calculateEMA(prices, fastPeriod);
                const emaSlow = this.calculateEMA(prices, slowPeriod);
                
                if (emaFast === null || emaSlow === null) return null;
                
                return emaFast - emaSlow;
            }

            calculateBollingerBands(prices, period, stdDev) {
                if (prices.length < period) return null;
                
                const sma = this.calculateSMA(prices, period);
                const recentPrices = prices.slice(-period);
                
                const variance = recentPrices.reduce((sum, price) => {
                    return sum + Math.pow(price - sma, 2);
                }, 0) / period;
                
                const standardDeviation = Math.sqrt(variance);
                
                return {
                    upper: sma + (standardDeviation * stdDev),
                    middle: sma,
                    lower: sma - (standardDeviation * stdDev)
                };
            }

            calculateStochastic(highs, lows, closes, period) {
                if (closes.length < period) return null;
                
                const recentHighs = highs.slice(-period);
                const recentLows = lows.slice(-period);
                const currentClose = closes[closes.length - 1];
                
                const highest = Math.max(...recentHighs);
                const lowest = Math.min(...recentLows);
                
                if (highest === lowest) return 50;
                return ((currentClose - lowest) / (highest - lowest)) * 100;
            }

            calculateWilliamsR(highs, lows, closes, period) {
                if (closes.length < period) return null;
                
                const recentHighs = highs.slice(-period);
                const recentLows = lows.slice(-period);
                const currentClose = closes[closes.length - 1];
                
                const highest = Math.max(...recentHighs);
                const lowest = Math.min(...recentLows);
                
                if (highest === lowest) return -50;
                return ((highest - currentClose) / (highest - lowest)) * -100;
            }

            calculateCCI(highs, lows, closes, period) {
                if (closes.length < period) return null;
                
                const typicalPrices = [];
                for (let i = closes.length - period; i < closes.length; i++) {
                    typicalPrices.push((highs[i] + lows[i] + closes[i]) / 3);
                }
                
                const sma = typicalPrices.reduce((a, b) => a + b, 0) / period;
                const meanDeviation = typicalPrices.reduce((sum, tp) => {
                    return sum + Math.abs(tp - sma);
                }, 0) / period;
                
                const currentTP = (highs[highs.length - 1] + lows[lows.length - 1] + closes[closes.length - 1]) / 3;
                
                if (meanDeviation === 0) return 0;
                return (currentTP - sma) / (0.015 * meanDeviation);
            }

            calculateATR(highs, lows, closes, period) {
                if (closes.length < period + 1) return null;
                
                let trSum = 0;
                for (let i = closes.length - period; i < closes.length; i++) {
                    if (i > 0) {
                        const tr = Math.max(
                            highs[i] - lows[i],
                            Math.abs(highs[i] - closes[i - 1]),
                            Math.abs(lows[i] - closes[i - 1])
                        );
                        trSum += tr;
                    }
                }
                
                return trSum / (period - 1);
            }

            calculateOBV(prices, volumes) {
                if (prices.length < 2 || volumes.length < 2) return null;
                
                let obv = 0;
                for (let i = 1; i < prices.length; i++) {
                    if (prices[i] > prices[i - 1]) {
                        obv += volumes[i];
                    } else if (prices[i] < prices[i - 1]) {
                        obv -= volumes[i];
                    }
                }
                
                return obv;
            }

            calculateVWAP(prices, volumes) {
                if (prices.length === 0 || volumes.length === 0) return null;
                
                let priceVolume = 0;
                let totalVolume = 0;
                
                for (let i = 0; i < prices.length; i++) {
                    priceVolume += prices[i] * volumes[i];
                    totalVolume += volumes[i];
                }
                
                return totalVolume > 0 ? priceVolume / totalVolume : null;
            }

            calculateMFI(highs, lows, closes, volumes, period) {
                if (closes.length < period + 1) return null;
                
                let positiveFlow = 0, negativeFlow = 0;
                
                for (let i = closes.length - period; i < closes.length; i++) {
                    if (i > 0) {
                        const typicalPrice = (highs[i] + lows[i] + closes[i]) / 3;
                        const prevTypicalPrice = (highs[i - 1] + lows[i - 1] + closes[i - 1]) / 3;
                        const moneyFlow = typicalPrice * volumes[i];
                        
                        if (typicalPrice > prevTypicalPrice) {
                            positiveFlow += moneyFlow;
                        } else if (typicalPrice < prevTypicalPrice) {
                            negativeFlow += moneyFlow;
                        }
                    }
                }
                
                if (negativeFlow === 0) return 100;
                const mfi = 100 - (100 / (1 + (positiveFlow / negativeFlow)));
                return isNaN(mfi) ? 50 : mfi;
            }

            calculateVolatility(prices, period) {
                if (prices.length < period) return null;
                
                const recentPrices = prices.slice(-period);
                const returns = [];
                
                for (let i = 1; i < recentPrices.length; i++) {
                    returns.push(Math.log(recentPrices[i] / recentPrices[i - 1]));
                }
                
                const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                const variance = returns.reduce((sum, ret) => {
                    return sum + Math.pow(ret - mean, 2);
                }, 0) / returns.length;
                
                return Math.sqrt(variance) * Math.sqrt(252) * 100;
            }

            updateIndicatorDisplay() {
                const indicators = [
                    { id: 'sma20', value: this.indicators.sma20, decimals: 4 },
                    { id: 'ema20', value: this.indicators.ema20, decimals: 4 },
                    { id: 'macd', value: this.indicators.macd, decimals: 6 },
                    { id: 'bbUpper', value: this.indicators.bb?.upper, decimals: 4 },
                    { id: 'bbLower', value: this.indicators.bb?.lower, decimals: 4 },
                    { id: 'rsi', value: this.indicators.rsi, decimals: 1 },
                    { id: 'stoch', value: this.indicators.stoch, decimals: 1 },
                    { id: 'willR', value: this.indicators.willR, decimals: 1 },
                    { id: 'cci', value: this.indicators.cci, decimals: 1 },
                    { id: 'obv', value: this.indicators.obv, decimals: 0, format: 'compact' },
                    { id: 'vwap', value: this.indicators.vwap, decimals: 4 },
                    { id: 'mfi', value: this.indicators.mfi, decimals: 1 },
                    { id: 'atr', value: this.indicators.atr, decimals: 6 },
                    { id: 'volatility', value: this.indicators.volatility, decimals: 1 }
                ];

                indicators.forEach(indicator => {
                    const element = document.getElementById(indicator.id);
                    if (element && indicator.value !== null && indicator.value !== undefined) {
                        let displayValue;
                        if (indicator.format === 'compact') {
                            displayValue = this.formatLargeNumber(indicator.value);
                        } else {
                            displayValue = indicator.value.toFixed(indicator.decimals);
                        }
                        element.textContent = displayValue;
                        
                        // Apply color coding for specific indicators
                        element.style.color = '#ffffff';
                        if (indicator.id === 'rsi') {
                            if (indicator.value > 70) element.style.color = '#ff4444';
                            else if (indicator.value < 30) element.style.color = '#00ff88';
                        }
                    }
                });
            }

            updateChart() {
                if (this.priceData.length === 0) return;

                const labels = this.priceData.map(d => d.timestamp.toLocaleTimeString());
                const prices = this.priceData.map(d => d.price);

                this.chart.data.labels = labels;
                this.chart.data.datasets[0].data = prices;
                this.chart.update('none');
            }

            async initializeMLModels() {
                try {
                    console.log('Initializing ML models...');
                    
                    // Create TensorFlow.js models for real predictions
                    this.models.lstm = await this.createLSTMModel();
                    this.models.gru = await this.createGRUModel();
                    this.models.transformer = await this.createTransformerModel();
                    
                    console.log('ML models initialized successfully');
                } catch (error) {
                    console.error('Error initializing ML models:', error);
                }
            }

            async createLSTMModel() {
                const model = tf.sequential({
                    layers: [
                        tf.layers.lstm({ units: 50, returnSequences: true, inputShape: [60, 5] }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.lstm({ units: 50, returnSequences: false }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 25, activation: 'relu' }),
                        tf.layers.dense({ units: 1 })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['meanAbsoluteError']
                });
                
                return model;
            }

            async createGRUModel() {
                const model = tf.sequential({
                    layers: [
                        tf.layers.gru({ units: 50, returnSequences: true, inputShape: [60, 5] }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.gru({ units: 50, returnSequences: false }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 25, activation: 'relu' }),
                        tf.layers.dense({ units: 1 })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError'
                });
                
                return model;
            }

            async createTransformerModel() {
                const model = tf.sequential({
                    layers: [
                        tf.layers.dense({ units: 128, activation: 'relu', inputShape: [60, 5] }),
                        tf.layers.dropout({ rate: 0.1 }),
                        tf.layers.dense({ units: 64, activation: 'relu' }),
                        tf.layers.globalAveragePooling1d(),
                        tf.layers.dense({ units: 32, activation: 'relu' }),
                        tf.layers.dense({ units: 1 })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError'
                });
                
                return model;
            }

            async generateMLPredictions() {
                if (this.priceData.length < 100 || !this.models.lstm) return;

                try {
                    const features = this.prepareMLFeatures();
                    if (!features) return;

                    // Generate ensemble prediction
                    const predictions = [];
                    
                    // Use actual TensorFlow.js models for predictions
                    if (this.models.lstm && features.length >= 60) {
                        const tensorData = tf.tensor3d([features.slice(-60)]);
                        const prediction = await this.models.lstm.predict(tensorData);
                        const predictionValue = await prediction.data();
                        predictions.push(predictionValue[0]);
                        tensorData.dispose();
                        prediction.dispose();
                    }

                    // Calculate ensemble prediction
                    const ensemblePrediction = predictions.length > 0 ? 
                        predictions.reduce((a, b) => a + b, 0) / predictions.length :
                        this.currentPrice * (1 + (this.indicators.rsi - 50) / 1000);

                    // Calculate prediction confidence based on technical indicators
                    const confidence = this.calculatePredictionConfidence();

                    this.updatePredictionDisplay(ensemblePrediction, confidence);

                } catch (error) {
                    console.error('Error generating ML predictions:', error);
                }
            }

            prepareMLFeatures() {
                if (this.priceData.length < 60) return null;

                const features = [];
                const recent = this.priceData.slice(-60);

                recent.forEach((data, i) => {
                    features.push([
                        data.price,
                        data.volume || 0,
                        data.high || data.price,
                        data.low || data.price,
                        i < recent.length - 1 ? recent[i + 1].price - data.price : 0
                    ]);
                });

                return features;
            }

            calculatePredictionConfidence() {
                let confidence = 50;

                // Adjust confidence based on technical indicators
                if (this.indicators.rsi) {
                    if (this.indicators.rsi > 70 || this.indicators.rsi < 30) confidence += 15;
                }

                if (this.indicators.bb && this.currentPrice) {
                    if (this.currentPrice > this.indicators.bb.upper || this.currentPrice < this.indicators.bb.lower) {
                        confidence += 10;
                    }
                }

                if (this.indicators.macd && this.indicators.macd !== 0) {
                    confidence += 5;
                }

                return Math.min(95, Math.max(30, confidence));
            }

            updatePredictionDisplay(prediction, confidence) {
                document.getElementById('prediction1h').textContent = `${prediction.toFixed(4)}`;
                
                const confidenceBar = document.getElementById('confidence1h');
                const confidenceText = document.getElementById('confidence1hText');
                
                confidenceBar.style.width = `${confidence}%`;
                confidenceText.textContent = `Confidence: ${confidence.toFixed(1)}%`;

                // Calculate and display model accuracy
                const accuracy = this.calculateModelAccuracy();
                document.getElementById('modelAccuracy').textContent = `${accuracy.toFixed(1)}%`;
            }

            calculateModelAccuracy() {
                // Calculate accuracy based on recent predictions vs actual movements
                if (this.priceData.length < 20) return 65.0;

                let correctPredictions = 0;
                const recentData = this.priceData.slice(-20);

                for (let i = 1; i < recentData.length; i++) {
                    const actualDirection = recentData[i].price > recentData[i - 1].price ? 1 : -1;
                    const predictedDirection = this.indicators.rsi > 50 ? 1 : -1;
                    
                    if (actualDirection === predictedDirection) {
                        correctPredictions++;
                    }
                }

                return (correctPredictions / (recentData.length - 1)) * 100;
            }

            updateTradingSignals() {
                const signals = this.generateRealTimeSignals();
                const container = document.getElementById('signalsContainer');
                
                if (signals.length === 0) {
                    container.innerHTML = '<div class="error-message">No signals generated</div>';
                    return;
                }

                container.innerHTML = signals.map(signal => `
                    <div class="signal-item signal-${signal.type}">
                        <div>
                            <div style="font-weight: bold;">${signal.title}</div>
                            <div style="font-size: 11px; color: #aaa;">${signal.description}</div>
                        </div>
                        <div style="color: ${signal.color}; font-weight: bold;">${signal.strength.toFixed(1)}%</div>
                    </div>
                `).join('');
            }

            generateRealTimeSignals() {
                const signals = [];

                // RSI-based signals
                if (this.indicators.rsi !== null) {
                    if (this.indicators.rsi > 70) {
                        signals.push({
                            type: 'sell',
                            title: 'RSI Overbought',
                            description: 'RSI above 70 - potential reversal',
                            strength: Math.min(95, 70 + (this.indicators.rsi - 70)),
                            color: '#ff4444'
                        });
                    } else if (this.indicators.rsi < 30) {
                        signals.push({
                            type: 'buy',
                            title: 'RSI Oversold',
                            description: 'RSI below 30 - potential bounce',
                            strength: Math.min(95, 70 + (30 - this.indicators.rsi)),
                            color: '#00ff88'
                        });
                    }
                }

                // Bollinger Bands signals
                if (this.indicators.bb && this.currentPrice) {
                    if (this.currentPrice > this.indicators.bb.upper) {
                        signals.push({
                            type: 'sell',
                            title: 'BB Breakout (Upper)',
                            description: 'Price above upper Bollinger Band',
                            strength: 75,
                            color: '#ff4444'
                        });
                    } else if (this.currentPrice < this.indicators.bb.lower) {
                        signals.push({
                            type: 'buy',
                            title: 'BB Support',
                            description: 'Price near lower Bollinger Band',
                            strength: 75,
                            color: '#00ff88'
                        });
                    }
                }

                // MACD signals
                if (this.indicators.macd !== null) {
                    if (this.indicators.macd > 0) {
                        signals.push({
                            type: 'buy',
                            title: 'MACD Bullish',
                            description: 'MACD above signal line',
                            strength: 65,
                            color: '#00ff88'
                        });
                    } else {
                        signals.push({
                            type: 'sell',
                            title: 'MACD Bearish',
                            description: 'MACD below signal line',
                            strength: 65,
                            color: '#ff4444'
                        });
                    }
                }

                return signals.slice(0, 4); // Show max 4 signals
            }

            async fetchMarketSentimentData() {
                try {
                    // Fetch Fear & Greed Index from Alternative.me API
                    const response = await fetch('https://api.alternative.me/fng/');
                    if (response.ok) {
                        const data = await response.json();
                        if (data.data && data.data[0]) {
                            this.updateMarketData(data.data[0]);
                        }
                    }
                } catch (error) {
                    console.error('Error fetching market sentiment:', error);
                }
            }

            updateMarketData(fearGreedData) {
                const container = document.getElementById('marketDataContainer');
                
                container.innerHTML = `
                    <div style="text-align: center; margin-bottom: 15px;">
                        <div style="font-size: 24px; font-weight: bold; color: #00ff88;">${fearGreedData.value}</div>
                        <div style="font-size: 12px; color: #aaa;">Fear & Greed Index</div>
                        <div style="font-size: 11px; color: #666;">${fearGreedData.value_classification}</div>
                    </div>
                    <div style="font-size: 12px; text-align: center;">
                        <div>Market Sentiment: <strong>${fearGreedData.value_classification}</strong></div>
                        <div style="margin-top: 10px; color: #888;">Last Updated: ${new Date(fearGreedData.timestamp * 1000).toLocaleDateString()}</div>
                    </div>
                `;
            }

            initializeEventListeners() {
                // Timeframe selection
                document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        this.currentTimeframe = e.target.dataset.timeframe;
                        console.log(`Switching to ${this.currentTimeframe} timeframe`);
                        
                        // Fetch new data for selected timeframe
                        await this.fetchHistoricalData();
                    });
                });
            }

            startPeriodicUpdates() {
                // Update market sentiment data every 5 minutes
                this.fetchMarketSentimentData();
                setInterval(() => {
                    this.fetchMarketSentimentData();
                }, 300000);

                // Refresh historical data every 10 minutes
                setInterval(async () => {
                    if (this.isConnected) {
                        await this.fetchHistoricalData();
                    }
                }, 600000);
            }

            formatLargeNumber(num) {
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return num.toFixed(0);
            }

            showError(message) {
                const container = document.getElementById('signalsContainer');
                container.innerHTML = `<div class="error-message">${message}</div>`;
                console.error(message);
            }
        }

        // Initialize the platform when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing WIF/USDT Trading Platform...');
            window.wifPlatform = new WIFTradingPlatform();
        });

        // Handle page visibility for performance
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden - WebSocket may reduce frequency');
            } else {
                console.log('Page visible - resuming normal operation');
                if (window.wifPlatform && !window.wifPlatform.isConnected) {
                    window.wifPlatform.connectWebSocket();
                }
            }
        });
    </script>
</body>
</html>
