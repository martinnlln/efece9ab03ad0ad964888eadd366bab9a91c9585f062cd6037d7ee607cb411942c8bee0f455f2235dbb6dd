<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Personal Trading Assistant</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            overflow-x: auto;
            animation: backgroundShift 20s ease-in-out infinite alternate;
        }
        
        @keyframes backgroundShift {
            0% { background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); }
            100% { background: linear-gradient(135deg, #16213e 0%, #0a0a0a 50%, #1a1a2e 100%); }
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 30px;
            border: 2px solid transparent;
            background-clip: padding-box;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff6b6b, #ffd93d);
            z-index: -1;
            border-radius: 25px;
            padding: 2px;
            animation: borderGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes borderGlow {
            0% { opacity: 0.5; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.02); }
        }
        
        .header h1 {
            font-size: 3rem;
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: textGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes textGlow {
            0% { text-shadow: 0 0 10px rgba(0, 255, 136, 0.3); }
            100% { text-shadow: 0 0 30px rgba(0, 255, 136, 0.7), 0 0 40px rgba(0, 204, 255, 0.5); }
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #b0b0b0;
            margin-bottom: 20px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-group label {
            font-size: 0.9rem;
            color: #00ff88;
            font-weight: 600;
        }
        
        select, input, button {
            padding: 12px;
            border: 2px solid rgba(0, 255, 136, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            transform: scale(1.02);
        }
        
        button {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 255, 136, 0.3);
            filter: brightness(1.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .chart-container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 136, 0.1), transparent);
            z-index: -1;
            border-radius: 22px;
            animation: chartGlow 4s linear infinite;
        }
        
        @keyframes chartGlow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .chart-title {
            font-size: 1.5rem;
            color: #00ff88;
            font-weight: bold;
        }
        
        .price-display {
            font-size: 1.8rem;
            font-weight: bold;
        }
        
        .price-up { color: #00ff88; }
        .price-down { color: #ff6b6b; }
        
        .indicators-panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 600px;
            overflow-y: auto;
        }
        
        .indicator-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #00ff88;
            transition: all 0.3s ease;
        }
        
        .indicator-card:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.2);
        }
        
        .indicator-title {
            font-weight: bold;
            color: #00ccff;
            margin-bottom: 8px;
        }
        
        .indicator-value {
            font-size: 1.1rem;
            color: #ffffff;
        }
        
        .indicator-signal {
            font-size: 0.9rem;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .signal-buy { color: #00ff88; }
        .signal-sell { color: #ff6b6b; }
        .signal-hold { color: #ffd93d; }
        
        .predictions-section {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }
        
        .section-title {
            font-size: 1.8rem;
            color: #00ff88;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .predictions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .prediction-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .prediction-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .prediction-card:hover::before {
            left: 100%;
        }
        
        .prediction-card:hover {
            transform: translateY(-5px);
            border-color: #00ff88;
            box-shadow: 0 15px 35px rgba(0, 255, 136, 0.2);
        }
        
        .prediction-symbol {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00ccff;
            margin-bottom: 10px;
        }
        
        .prediction-price {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .prediction-change {
            font-size: 1rem;
            margin-bottom: 10px;
        }
        
        .prediction-confidence {
            font-size: 0.9rem;
            color: #b0b0b0;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
            color: #00ccff;
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .error {
            color: #ff6b6b;
            text-align: center;
            padding: 20px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }
        
        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
        }
        
        .status-online {
            color: #00ff88;
        }
        
        .status-offline {
            color: #ff6b6b;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
        }
        
        .advanced-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .metric-card:hover {
            transform: scale(1.05);
            border-color: #00ff88;
        }
        
        .metric-title {
            font-size: 0.9rem;
            color: #b0b0b0;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #00ccff;
        }
    </style>
</head>
<body>
    <div class="status-indicator" id="statusIndicator">
        <span id="statusText">Connecting...</span>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>🚀 Advanced Personal Trading Assistant</h1>
            <p class="subtitle">Real-time crypto analysis with advanced technical indicators</p>
            
            <div class="controls">
                <div class="control-group">
                    <label for="symbolSelect">Select Cryptocurrency:</label>
                    <select id="symbolSelect">
                        <option value="BTCUSDT">Bitcoin (BTC)</option>
                        <option value="ETHUSDT">Ethereum (ETH)</option>
                        <option value="SOLUSDT">Solana (SOL)</option>
                        <option value="WIFUSDT">dogwifhat (WIF)</option>
                        <option value="AVAXUSDT">Avalanche (AVAX)</option>
                        <option value="PYTHUSDT">Pyth Network (PYTH)</option>
                        <option value="ADAUSDT">Cardano (ADA)</option>
                        <option value="DOGEUSDT">Dogecoin (DOGE)</option>
                        <option value="MATICUSDT">Polygon (MATIC)</option>
                        <option value="LINKUSDT">Chainlink (LINK)</option>
                        <option value="DOTUSDT">Polkadot (DOT)</option>
                        <option value="UNIUSDT">Uniswap (UNI)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="intervalSelect">Time Interval:</label>
                    <select id="intervalSelect">
                        <option value="1m">1 Minute</option>
                        <option value="5m">5 Minutes</option>
                        <option value="15m" selected>15 Minutes</option>
                        <option value="1h">1 Hour</option>
                        <option value="4h">4 Hours</option>
                        <option value="1d">1 Day</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="limitSelect">Data Points:</label>
                    <select id="limitSelect">
                        <option value="100">100</option>
                        <option value="200" selected>200</option>
                        <option value="500">500</option>
                        <option value="1000">1000</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <button id="refreshBtn">🔄 Refresh Data</button>
                </div>
                
                <div class="control-group">
                    <button id="autoRefreshBtn">⚡ Auto Refresh: OFF</button>
                </div>
            </div>
        </div>
        
        <div class="dashboard">
            <div class="chart-container">
                <div class="chart-header">
                    <h3 class="chart-title" id="chartTitle">Price Chart</h3>
                    <div class="price-display" id="priceDisplay">Loading...</div>
                </div>
                <canvas id="priceChart" width="800" height="400"></canvas>
            </div>
            
            <div class="indicators-panel">
                <h3 class="section-title">📊 Technical Indicators</h3>
                <div id="indicatorsContainer">
                    <div class="loading">Loading indicators...</div>
                </div>
            </div>
        </div>
        
        <div class="predictions-section">
            <h3 class="section-title">🔮 Market Predictions & Analysis</h3>
            <div class="predictions-grid" id="predictionsGrid">
                <div class="loading">Loading predictions...</div>
            </div>
        </div>
        
        <div class="advanced-metrics" id="advancedMetrics">
            <!-- Advanced metrics will be populated here -->
        </div>
    </div>

    <script>
        class TradingAssistant {
            constructor() {
                this.chart = null;
                this.currentData = null;
                this.autoRefreshInterval = null;
                this.autoRefreshEnabled = false;
                this.wsConnection = null;
                this.indicators = {};
                this.predictions = {};
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.loadData();
                this.updateStatus('online');
            }
            
            setupEventListeners() {
                document.getElementById('refreshBtn').addEventListener('click', () => this.loadData());
                document.getElementById('symbolSelect').addEventListener('change', () => this.loadData());
                document.getElementById('intervalSelect').addEventListener('change', () => this.loadData());
                document.getElementById('limitSelect').addEventListener('change', () => this.loadData());
                document.getElementById('autoRefreshBtn').addEventListener('click', () => this.toggleAutoRefresh());
            }
            
            updateStatus(status) {
                const statusEl = document.getElementById('statusText');
                const indicatorEl = document.getElementById('statusIndicator');
                
                if (status === 'online') {
                    statusEl.textContent = '🟢 Live Data';
                    statusEl.className = 'status-online';
                } else {
                    statusEl.textContent = '🔴 Offline';
                    statusEl.className = 'status-offline';
                }
            }
            
            async loadData() {
                try {
                    this.showLoading();
                    
                    const symbol = document.getElementById('symbolSelect').value;
                    const interval = document.getElementById('intervalSelect').value;
                    const limit = document.getElementById('limitSelect').value;
                    
                    // Using Binance API for real-time data
                    const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
                    
                    if (!response.ok) {
                        throw new Error('Failed to fetch data');
                    }
                    
                    const data = await response.json();
                    this.currentData = this.processKlineData(data);
                    
                    this.updateChart();
                    this.calculateIndicators();
                    this.generatePredictions();
                    this.updateAdvancedMetrics();
                    this.updateStatus('online');
                    
                } catch (error) {
                    console.error('Error loading data:', error);
                    this.showError('Failed to load market data. Please try again.');
                    this.updateStatus('offline');
                }
            }
            
            processKlineData(klineData) {
                return klineData.map(candle => ({
                    timestamp: parseInt(candle[0]),
                    open: parseFloat(candle[1]),
                    high: parseFloat(candle[2]),
                    low: parseFloat(candle[3]),
                    close: parseFloat(candle[4]),
                    volume: parseFloat(candle[5])
                }));
            }
            
            updateChart() {
                if (!this.currentData || this.currentData.length === 0) return;
                
                const ctx = document.getElementById('priceChart').getContext('2d');
                
                const labels = this.currentData.map(d => new Date(d.timestamp).toLocaleTimeString());
                const prices = this.currentData.map(d => d.close);
                const volumes = this.currentData.map(d => d.volume);
                
                if (this.chart) {
                    this.chart.destroy();
                }
                
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Price',
                                data: prices,
                                borderColor: '#00ff88',
                                backgroundColor: 'rgba(0, 255, 136, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.1
                            },
                            {
                                label: 'SMA 20',
                                data: this.calculateSMA(prices, 20),
                                borderColor: '#00ccff',
                                borderWidth: 1,
                                fill: false,
                                pointRadius: 0
                            },
                            {
                                label: 'EMA 12',
                                data: this.calculateEMA(prices, 12),
                                borderColor: '#ff6b6b',
                                borderWidth: 1,
                                fill: false,
                                pointRadius: 0
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff'
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            }
                        }
                    }
                });
                
                // Update price display
                const currentPrice = prices[prices.length - 1];
                const previousPrice = prices[prices.length - 2];
                const priceChange = ((currentPrice - previousPrice) / previousPrice * 100).toFixed(2);
                
                const priceEl = document.getElementById('priceDisplay');
                priceEl.textContent = `$${currentPrice.toLocaleString()} (${priceChange > 0 ? '+' : ''}${priceChange}%)`;
                priceEl.className = `price-display ${priceChange > 0 ? 'price-up' : 'price-down'}`;
                
                document.getElementById('chartTitle').textContent = `${document.getElementById('symbolSelect').value} Price Chart`;
            }
            
            calculateIndicators() {
                if (!this.currentData) return;
                
                const prices = this.currentData.map(d => d.close);
                const highs = this.currentData.map(d => d.high);
                const lows = this.currentData.map(d => d.low);
                const volumes = this.currentData.map(d => d.volume);
                
                // Calculate various indicators
                const indicators = {
                    rsi: this.calculateRSI(prices, 14),
                    macd: this.calculateMACD(prices),
                    bb: this.calculateBollingerBands(prices, 20, 2),
                    stoch: this.calculateStochastic(highs, lows, prices, 14),
                    atr: this.calculateATR(highs, lows, prices, 14),
                    adx: this.calculateADX(highs, lows, prices, 14),
                    cci: this.calculateCCI(highs, lows, prices, 20),
                    williams: this.calculateWilliamsR(highs, lows, prices, 14),
                    mfi: this.calculateMFI(highs, lows, prices, volumes, 14),
                    obv: this.calculateOBV(prices, volumes)
                };
                
                this.indicators = indicators;
                this.displayIndicators(indicators);
            }
            
            displayIndicators(indicators) {
                const container = document.getElementById('indicatorsContainer');
                container.innerHTML = '';
                
                const indicatorCards = [
                    {
                        title: 'RSI (14)',
                        value: indicators.rsi.toFixed(2),
                        signal: this.getRSISignal(indicators.rsi),
                        description: 'Relative Strength Index'
                    },
                    {
                        title: 'MACD',
                        value: indicators.macd.histogram.toFixed(4),
                        signal: this.getMACDSignal(indicators.macd),
                        description: 'Moving Average Convergence Divergence'
                    },
                    {
                        title: 'Bollinger Bands',
                        value: `${indicators.bb.position.toFixed(2)}%`,
                        signal: this.getBBSignal(indicators.bb),
                        description: 'Price position within bands'
                    },
                    {
                        title: 'Stochastic',
                        value: `${indicators.stoch.k.toFixed(2)}%`,
                        signal: this.getStochSignal(indicators.stoch),
                        description: 'Momentum oscillator'
                    },
                    {
                        title: 'ATR (14)',
                        value: indicators.atr.toFixed(4),
                        signal: this.getATRSignal(indicators.atr),
                        description: 'Average True Range - Volatility'
                    },
                    {
                        title: 'ADX (14)',
                        value: indicators.adx.toFixed(2),
                        signal: this.getADXSignal(indicators.adx),
                        description: 'Trend strength indicator'
                    },
                    {
                        title: 'CCI (20)',
                        value: indicators.cci.toFixed(2),
                        signal: this.getCCISignal(indicators.cci),
                        description: 'Commodity Channel Index'
                    },
                    {
                        title: 'Williams %R',
                        value: indicators.williams.toFixed(2),
                        signal: this.getWilliamsSignal(indicators.williams),
                        description: 'Momentum indicator'
                    },
                    {
                        title: 'Money Flow Index',
                        value: indicators.mfi.toFixed(2),
                        signal: this.getMFISignal(indicators.mfi),
                        description: 'Volume-weighted RSI'
                    }
                ];
                
                indicatorCards.forEach(indicator => {
                    const card = document.createElement('div');
                    card.className = 'indicator-card';
                    card.innerHTML = `
                        <div class="indicator-title">${indicator.title}</div>
                        <div class="indicator-value">${indicator.value}</div>
                        <div class="indicator-signal signal-${indicator.signal.toLowerCase()}">${indicator.signal}</div>
                        <div style="font-size: 0.8rem; color: #888; margin-top: 5px;">${indicator.description}</div>
                    `;
                    container.appendChild(card);
                });
            }
            
            generatePredictions() {
                if (!this.currentData || !this.indicators) return;
                
                const predictions = this.analyzeTechnicals();
                this.displayPredictions(predictions);
            }
            
            analyzeTechnicals() {
                const { rsi, macd, bb, stoch, adx } = this.indicators;
                const prices = this.currentData.map(d => d.close);
                const currentPrice = prices[prices.length - 1];
                
                // Advanced prediction algorithm
                let bullishScore = 0;
                let bearishScore = 0;
                
                // RSI Analysis
                if (rsi < 30) bullishScore += 2;
                else if (rsi > 70) bearishScore += 2;
                else if (rsi > 50) bullishScore += 1;
                else bearishScore += 1;
                
                // MACD Analysis
                if (macd.histogram > 0) bullishScore += 1.5;
                else bearishScore += 1.5;
                
                // Bollinger Bands Analysis
                if (bb.position < 20) bullishScore += 1.5;
                else if (bb.position > 80) bearishScore += 1.5;
                
                // Stochastic Analysis
                if (stoch.k < 20) bullishScore += 1;
                else if (stoch.k > 80) bearishScore += 1;
                
                // Trend strength (ADX)
                const trendMultiplier = adx > 25 ? 1.5 : 1;
                
                const totalScore = (bullishScore - bearishScore) * trendMultiplier;
                const confidence = Math.min(Math.abs(totalScore) * 10, 95);
                
                // Price predictions
                const volatility = this.calculateVolatility(prices);
                const trend = this.calculateTrend(prices);
                
                const predictions = {
                    '1h': {
                        price: currentPrice * (1 + (totalScore * 0.001 + trend * 0.002)),
                        change: totalScore * 0.1 + trend * 0.2,
                        confidence: confidence
                    },
                    '4h': {
                        price: currentPrice * (1 + (totalScore * 0.003 + trend * 0.005)),
                        change: totalScore * 0.3 + trend * 0.5,
                        confidence: Math.max(confidence - 10, 60)
                    },
                    '1d': {
                        price: currentPrice * (1 + (totalScore * 0.008 + trend * 0.012)),
                        change: totalScore * 0.8 + trend * 1.2,
                        confidence: Math.max(confidence - 20, 50)
                    },
                    '1w': {
                        price: currentPrice * (1 + (totalScore * 0.025 + trend * 0.035)),
                        change: totalScore * 2.5 + trend * 3.5,
                        confidence: Math.max(confidence - 30, 40)
                    }
                };
                
                return predictions;
            }
            
            displayPredictions(predictions) {
                const container = document.getElementById('predictionsGrid');
                container.innerHTML = '';
                
                const timeframes = ['1h', '4h', '1d', '1w'];
                const labels = ['1 Hour', '4 Hours', '1 Day', '1 Week'];
                
                timeframes.forEach((timeframe, index) => {
                    const pred = predictions[timeframe];
                    const card = document.createElement('div');
                    card.className = 'prediction-card';
                    
                    const changeClass = pred.change >= 0 ? 'price-up' : 'price-down';
                    const changeIcon = pred.change >= 0 ? '📈' : '📉';
                    
                    card.innerHTML = `
                        <div class="prediction-symbol">${labels[index]} ${changeIcon}</div>
                        <div class="prediction-price ${changeClass}">${pred.price.toLocaleString()}</div>
                        <div class="prediction-change ${changeClass}">
                            ${pred.change >= 0 ? '+' : ''}${pred.change.toFixed(2)}%
                        </div>
                        <div class="prediction-confidence">Confidence: ${pred.confidence.toFixed(0)}%</div>
                    `;
                    
                    container.appendChild(card);
                });
                
                // Add overall market sentiment
                const sentimentCard = document.createElement('div');
                sentimentCard.className = 'prediction-card';
                const overallSentiment = this.calculateOverallSentiment();
                
                sentimentCard.innerHTML = `
                    <div class="prediction-symbol">Overall Sentiment</div>
                    <div class="prediction-price" style="color: ${overallSentiment.color};">
                        ${overallSentiment.label}
                    </div>
                    <div class="prediction-change">
                        Score: ${overallSentiment.score.toFixed(1)}/10
                    </div>
                    <div class="prediction-confidence">${overallSentiment.description}</div>
                `;
                
                container.appendChild(sentimentCard);
            }
            
            updateAdvancedMetrics() {
                if (!this.currentData || !this.indicators) return;
                
                const container = document.getElementById('advancedMetrics');
                const prices = this.currentData.map(d => d.close);
                const volumes = this.currentData.map(d => d.volume);
                
                const metrics = {
                    'Volatility': (this.calculateVolatility(prices) * 100).toFixed(2) + '%',
                    'Volume Trend': this.getVolumeTrend(volumes),
                    'Support Level': ' + this.calculateSupport(prices).toLocaleString(),
                    'Resistance Level': ' + this.calculateResistance(prices).toLocaleString(),
                    'Momentum': this.getMomentumScore(prices).toFixed(1) + '/10',
                    'Risk Level': this.getRiskLevel(),
                    'Trend Strength': this.getTrendStrength() + '/10',
                    'Buy Pressure': this.getBuyPressure() + '%'
                };
                
                container.innerHTML = '';
                Object.entries(metrics).forEach(([title, value]) => {
                    const card = document.createElement('div');
                    card.className = 'metric-card';
                    card.innerHTML = `
                        <div class="metric-title">${title}</div>
                        <div class="metric-value">${value}</div>
                    `;
                    container.appendChild(card);
                });
            }
            
            // Technical Analysis Functions
            calculateSMA(data, period) {
                const sma = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        sma.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                        sma.push(sum / period);
                    }
                }
                return sma;
            }
            
            calculateEMA(data, period) {
                const ema = [];
                const multiplier = 2 / (period + 1);
                
                for (let i = 0; i < data.length; i++) {
                    if (i === 0) {
                        ema.push(data[i]);
                    } else {
                        ema.push((data[i] * multiplier) + (ema[i - 1] * (1 - multiplier)));
                    }
                }
                return ema;
            }
            
            calculateRSI(data, period = 14) {
                const gains = [];
                const losses = [];
                
                for (let i = 1; i < data.length; i++) {
                    const change = data[i] - data[i - 1];
                    gains.push(change > 0 ? change : 0);
                    losses.push(change < 0 ? Math.abs(change) : 0);
                }
                
                const avgGain = gains.slice(-period).reduce((a, b) => a + b, 0) / period;
                const avgLoss = losses.slice(-period).reduce((a, b) => a + b, 0) / period;
                
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }
            
            calculateMACD(data) {
                const ema12 = this.calculateEMA(data, 12);
                const ema26 = this.calculateEMA(data, 26);
                
                const macdLine = ema12[ema12.length - 1] - ema26[ema26.length - 1];
                const signalLine = this.calculateEMA([macdLine], 9)[0];
                const histogram = macdLine - signalLine;
                
                return {
                    macd: macdLine,
                    signal: signalLine,
                    histogram: histogram
                };
            }
            
            calculateBollingerBands(data, period = 20, deviation = 2) {
                const sma = this.calculateSMA(data, period);
                const currentSMA = sma[sma.length - 1];
                const currentPrice = data[data.length - 1];
                
                // Calculate standard deviation
                const recentData = data.slice(-period);
                const variance = recentData.reduce((sum, price) => sum + Math.pow(price - currentSMA, 2), 0) / period;
                const stdDev = Math.sqrt(variance);
                
                const upper = currentSMA + (stdDev * deviation);
                const lower = currentSMA - (stdDev * deviation);
                
                const position = ((currentPrice - lower) / (upper - lower)) * 100;
                
                return {
                    upper: upper,
                    middle: currentSMA,
                    lower: lower,
                    position: position
                };
            }
            
            calculateStochastic(highs, lows, closes, period = 14) {
                const recentHighs = highs.slice(-period);
                const recentLows = lows.slice(-period);
                const currentClose = closes[closes.length - 1];
                
                const highestHigh = Math.max(...recentHighs);
                const lowestLow = Math.min(...recentLows);
                
                const k = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
                const d = k; // Simplified - normally would be SMA of K
                
                return { k: k, d: d };
            }
            
            calculateATR(highs, lows, closes, period = 14) {
                const trueRanges = [];
                
                for (let i = 1; i < closes.length; i++) {
                    const tr1 = highs[i] - lows[i];
                    const tr2 = Math.abs(highs[i] - closes[i - 1]);
                    const tr3 = Math.abs(lows[i] - closes[i - 1]);
                    trueRanges.push(Math.max(tr1, tr2, tr3));
                }
                
                return trueRanges.slice(-period).reduce((a, b) => a + b, 0) / period;
            }
            
            calculateADX(highs, lows, closes, period = 14) {
                // Simplified ADX calculation
                let positiveDM = 0;
                let negativeDM = 0;
                
                for (let i = 1; i < Math.min(period, closes.length); i++) {
                    const highDiff = highs[i] - highs[i - 1];
                    const lowDiff = lows[i - 1] - lows[i];
                    
                    if (highDiff > lowDiff && highDiff > 0) positiveDM += highDiff;
                    if (lowDiff > highDiff && lowDiff > 0) negativeDM += lowDiff;
                }
                
                const atr = this.calculateATR(highs, lows, closes, period);
                const posDI = (positiveDM / period / atr) * 100;
                const negDI = (negativeDM / period / atr) * 100;
                
                return Math.abs(posDI - negDI) / (posDI + negDI) * 100;
            }
            
            calculateCCI(highs, lows, closes, period = 20) {
                const typicalPrices = [];
                for (let i = 0; i < closes.length; i++) {
                    typicalPrices.push((highs[i] + lows[i] + closes[i]) / 3);
                }
                
                const recentTP = typicalPrices.slice(-period);
                const smaTP = recentTP.reduce((a, b) => a + b, 0) / period;
                const meanDeviation = recentTP.reduce((sum, tp) => sum + Math.abs(tp - smaTP), 0) / period;
                
                const currentTP = typicalPrices[typicalPrices.length - 1];
                return (currentTP - smaTP) / (0.015 * meanDeviation);
            }
            
            calculateWilliamsR(highs, lows, closes, period = 14) {
                const recentHighs = highs.slice(-period);
                const recentLows = lows.slice(-period);
                const currentClose = closes[closes.length - 1];
                
                const highestHigh = Math.max(...recentHighs);
                const lowestLow = Math.min(...recentLows);
                
                return ((highestHigh - currentClose) / (highestHigh - lowestLow)) * -100;
            }
            
            calculateMFI(highs, lows, closes, volumes, period = 14) {
                const typicalPrices = [];
                const moneyFlows = [];
                
                for (let i = 0; i < closes.length; i++) {
                    const tp = (highs[i] + lows[i] + closes[i]) / 3;
                    typicalPrices.push(tp);
                    
                    if (i > 0) {
                        const mf = tp * volumes[i];
                        moneyFlows.push({
                            flow: mf,
                            positive: tp > typicalPrices[i - 1]
                        });
                    }
                }
                
                const recentFlows = moneyFlows.slice(-period);
                const positiveFlow = recentFlows.filter(mf => mf.positive).reduce((sum, mf) => sum + mf.flow, 0);
                const negativeFlow = recentFlows.filter(mf => !mf.positive).reduce((sum, mf) => sum + mf.flow, 0);
                
                const moneyRatio = positiveFlow / negativeFlow;
                return 100 - (100 / (1 + moneyRatio));
            }
            
            calculateOBV(closes, volumes) {
                let obv = 0;
                for (let i = 1; i < closes.length; i++) {
                    if (closes[i] > closes[i - 1]) obv += volumes[i];
                    else if (closes[i] < closes[i - 1]) obv -= volumes[i];
                }
                return obv;
            }
            
            // Signal Analysis Functions
            getRSISignal(rsi) {
                if (rsi < 30) return 'BUY';
                if (rsi > 70) return 'SELL';
                return 'HOLD';
            }
            
            getMACDSignal(macd) {
                if (macd.histogram > 0 && macd.macd > macd.signal) return 'BUY';
                if (macd.histogram < 0 && macd.macd < macd.signal) return 'SELL';
                return 'HOLD';
            }
            
            getBBSignal(bb) {
                if (bb.position < 20) return 'BUY';
                if (bb.position > 80) return 'SELL';
                return 'HOLD';
            }
            
            getStochSignal(stoch) {
                if (stoch.k < 20) return 'BUY';
                if (stoch.k > 80) return 'SELL';
                return 'HOLD';
            }
            
            getATRSignal(atr) {
                const avgATR = 0.02; // Simplified comparison
                if (atr > avgATR * 1.5) return 'HIGH VOLATILITY';
                if (atr < avgATR * 0.5) return 'LOW VOLATILITY';
                return 'NORMAL';
            }
            
            getADXSignal(adx) {
                if (adx > 25) return 'STRONG TREND';
                if (adx < 20) return 'WEAK TREND';
                return 'MODERATE';
            }
            
            getCCISignal(cci) {
                if (cci > 100) return 'SELL';
                if (cci < -100) return 'BUY';
                return 'HOLD';
            }
            
            getWilliamsSignal(williams) {
                if (williams < -80) return 'BUY';
                if (williams > -20) return 'SELL';
                return 'HOLD';
            }
            
            getMFISignal(mfi) {
                if (mfi < 20) return 'BUY';
                if (mfi > 80) return 'SELL';
                return 'HOLD';
            }
            
            // Advanced Analysis Functions
            calculateVolatility(prices) {
                const returns = [];
                for (let i = 1; i < prices.length; i++) {
                    returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
                }
                
                const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
                return Math.sqrt(variance);
            }
            
            calculateTrend(prices) {
                const n = prices.length;
                const x = Array.from({length: n}, (_, i) => i);
                const y = prices;
                
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
                const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                return slope / (sumY / n); // Normalized slope
            }
            
            calculateSupport(prices) {
                const sortedPrices = [...prices].sort((a, b) => a - b);
                return sortedPrices[Math.floor(sortedPrices.length * 0.1)]; // 10th percentile
            }
            
            calculateResistance(prices) {
                const sortedPrices = [...prices].sort((a, b) => a - b);
                return sortedPrices[Math.floor(sortedPrices.length * 0.9)]; // 90th percentile
            }
            
            getMomentumScore(prices) {
                const shortTerm = prices.slice(-5);
                const mediumTerm = prices.slice(-20);
                
                const shortAvg = shortTerm.reduce((a, b) => a + b, 0) / shortTerm.length;
                const mediumAvg = mediumTerm.reduce((a, b) => a + b, 0) / mediumTerm.length;
                
                const momentum = ((shortAvg - mediumAvg) / mediumAvg) * 100;
                return Math.max(0, Math.min(10, 5 + momentum * 2));
            }
            
            getVolumeTrend(volumes) {
                const recent = volumes.slice(-10);
                const previous = volumes.slice(-20, -10);
                
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const previousAvg = previous.reduce((a, b) => a + b, 0) / previous.length;
                
                const change = ((recentAvg - previousAvg) / previousAvg) * 100;
                
                if (change > 10) return '📈 Increasing';
                if (change < -10) return '📉 Decreasing';
                return '➡️ Stable';
            }
            
            getRiskLevel() {
                if (!this.indicators) return 'Unknown';
                
                const { rsi, atr } = this.indicators;
                let riskScore = 0;
                
                if (rsi > 70 || rsi < 30) riskScore += 2;
                if (atr > 0.03) riskScore += 2;
                
                if (riskScore >= 3) return '🔴 High';
                if (riskScore >= 1) return '🟡 Medium';
                return '🟢 Low';
            }
            
            getTrendStrength() {
                if (!this.indicators) return '0';
                return Math.round(this.indicators.adx / 10);
            }
            
            getBuyPressure() {
                if (!this.currentData) return '0';
                
                const prices = this.currentData.map(d => d.close);
                const volumes = this.currentData.map(d => d.volume);
                
                let buyVolume = 0;
                let totalVolume = 0;
                
                for (let i = 1; i < prices.length; i++) {
                    totalVolume += volumes[i];
                    if (prices[i] > prices[i - 1]) {
                        buyVolume += volumes[i];
                    }
                }
                
                return ((buyVolume / totalVolume) * 100).toFixed(1);
            }
            
            calculateOverallSentiment() {
                if (!this.indicators) {
                    return {
                        label: 'Unknown',
                        score: 5,
                        color: '#ffd93d',
                        description: 'Loading analysis...'
                    };
                }
                
                const { rsi, macd, bb, stoch } = this.indicators;
                
                let bullishSignals = 0;
                let bearishSignals = 0;
                let totalSignals = 0;
                
                // RSI
                if (rsi < 30) bullishSignals++;
                else if (rsi > 70) bearishSignals++;
                totalSignals++;
                
                // MACD
                if (macd.histogram > 0) bullishSignals++;
                else bearishSignals++;
                totalSignals++;
                
                // Bollinger Bands
                if (bb.position < 20) bullishSignals++;
                else if (bb.position > 80) bearishSignals++;
                totalSignals++;
                
                // Stochastic
                if (stoch.k < 20) bullishSignals++;
                else if (stoch.k > 80) bearishSignals++;
                totalSignals++;
                
                const score = ((bullishSignals - bearishSignals) / totalSignals * 5) + 5;
                
                let label, color, description;
                if (score >= 7) {
                    label = '🚀 Very Bullish';
                    color = '#00ff88';
                    description = 'Strong buy signals detected';
                } else if (score >= 6) {
                    label = '📈 Bullish';
                    color = '#00cc66';
                    description = 'Positive momentum building';
                } else if (score >= 4) {
                    label = '🔄 Neutral';
                    color = '#ffd93d';
                    description = 'Mixed signals, wait for clarity';
                } else if (score >= 3) {
                    label = '📉 Bearish';
                    color = '#ff8c66';
                    description = 'Negative pressure increasing';
                } else {
                    label = '🔻 Very Bearish';
                    color = '#ff6b6b';
                    description = 'Strong sell signals present';
                }
                
                return { label, score, color, description };
            }
            
            toggleAutoRefresh() {
                const btn = document.getElementById('autoRefreshBtn');
                
                if (this.autoRefreshEnabled) {
                    clearInterval(this.autoRefreshInterval);
                    this.autoRefreshEnabled = false;
                    btn.textContent = '⚡ Auto Refresh: OFF';
                    btn.style.background = 'linear-gradient(45deg, #666, #888)';
                } else {
                    this.autoRefreshInterval = setInterval(() => {
                        this.loadData();
                    }, 30000); // Refresh every 30 seconds
                    
                    this.autoRefreshEnabled = true;
                    btn.textContent = '⚡ Auto Refresh: ON';
                    btn.style.background = 'linear-gradient(45deg, #00ff88, #00ccff)';
                }
            }
            
            showLoading() {
                document.getElementById('indicatorsContainer').innerHTML = '<div class="loading">Analyzing market data...</div>';
                document.getElementById('predictionsGrid').innerHTML = '<div class="loading">Generating predictions...</div>';
            }
            
            showError(message) {
                const errorDiv = `<div class="error">${message}</div>`;
                document.getElementById('indicatorsContainer').innerHTML = errorDiv;
                document.getElementById('predictionsGrid').innerHTML = errorDiv;
            }
        }
        
        // Initialize the trading assistant when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TradingAssistant();
        });
        
        // Add some Easter eggs and advanced features
        document.addEventListener('keydown', (e) => {
            // Konami code for advanced mode
            if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                alert('🚀 Advanced Trading Mode Activated! \n\n' +
                      '• Real-time data streaming enabled\n' +
                      '• Advanced algorithms active\n' +
                      '• Professional-grade analysis tools unlocked');
            }
        });
    </script>
</body>
</html>
