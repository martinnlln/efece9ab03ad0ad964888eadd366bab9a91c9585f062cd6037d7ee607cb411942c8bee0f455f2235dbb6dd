<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Personal Trading Assistant - Live Market Data</title>
    
    <!-- 
    ================================================================================
    PERSONAL TRADING ASSISTANT (PTA) - PRODUCTION GRADE SINGLE FILE APPLICATION
    ================================================================================
    
    QUICK START:
    -----------
    1. Save this file as index.html
    2. Run locally: python3 -m http.server 8000 (or any static server)
    3. Open http://localhost:8000
    
    CORS HANDLING:
    -------------
    For production use without CORS issues:
    Option 1: Use the built-in CORS proxy URLs (see corsProxies array below)
    Option 2: Run your own proxy server:
    
    // Simple Express.js proxy (save as proxy.js):
    const express = require('express');
    const axios = require('axios');
    const app = express();
    app.use(express.json());
    app.use((req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*');
        res.header('Access-Control-Allow-Headers', 'Content-Type');
        next();
    });
    app.get('/api/*', async (req, res) => {
        try {
            const url = 'https://api.binance.com' + req.url;
            const response = await axios.get(url, { params: req.query });
            res.json(response.data);
        } catch (error) {
            res.status(error.response?.status || 500).json({ error: error.message });
        }
    });
    app.listen(3001, () => console.log('Proxy running on port 3001'));
    
    RATE LIMITS:
    -----------
    Binance public endpoints: 1200 weight per minute
    WebSocket: 5 connections per IP
    The app implements automatic rate limiting and exponential backoff
    
    SECURITY WARNING:
    ----------------
    NEVER store API keys in client-side code!
    For trading features, use a secure backend server with environment variables
    
    FEATURES:
    ---------
    ✓ Real-time market data from Binance
    ✓ 20+ Technical indicators
    ✓ ML predictions with TensorFlow.js
    ✓ Backtesting engine
    ✓ Paper trading simulator
    ✓ WebSocket streaming
    ✓ Mobile responsive design
    ✓ Local storage caching
    ✓ Export/Import functionality
    
    ================================================================================
    -->
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-green: #26a641;
            --accent-red: #da3633;
            --accent-blue: #58a6ff;
            --accent-yellow: #d29922;
            --border-color: #30363d;
            --shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        body.light-theme {
            --bg-primary: #ffffff;
            --bg-secondary: #f6f8fa;
            --bg-tertiary: #ffffff;
            --text-primary: #24292f;
            --text-secondary: #57606a;
            --border-color: #d0d7de;
            --shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        /* Header Styles */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 0.75rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: var(--shadow);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .logo {
            font-size: 1.25rem;
            font-weight: bold;
            color: var(--accent-blue);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .market-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        select, button, input {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        select:hover, button:hover {
            background: var(--bg-primary);
            border-color: var(--accent-blue);
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        button.active {
            background: var(--accent-blue);
            color: white;
        }
        
        /* Price Display */
        .price-display {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .price-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .price-change {
            font-size: 0.875rem;
        }
        
        .price-change.positive {
            color: var(--accent-green);
        }
        
        .price-change.negative {
            color: var(--accent-red);
        }
        
        /* Main Layout */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 1rem;
        }
        
        @media (max-width: 968px) {
            .main-container {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                order: -1;
            }
        }
        
        /* Chart Container */
        .chart-section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .chart-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .chart-container {
            position: relative;
            height: 500px;
            width: 100%;
        }
        
        @media (max-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        
        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .sidebar-section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .sidebar-section h3 {
            font-size: 1rem;
            margin-bottom: 0.75rem;
            color: var(--accent-blue);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Indicators Panel */
        .indicators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .indicator-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 0.75rem;
        }
        
        .indicator-toggle input[type="checkbox"] {
            cursor: pointer;
        }
        
        /* Signals Panel */
        .signals-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .signal-item {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
        }
        
        .signal-buy {
            border-left: 3px solid var(--accent-green);
        }
        
        .signal-sell {
            border-left: 3px solid var(--accent-red);
        }
        
        .signal-neutral {
            border-left: 3px solid var(--text-secondary);
        }
        
        /* Prediction Panel */
        .prediction-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .prediction-card {
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            text-align: center;
        }
        
        .prediction-value {
            font-size: 1.25rem;
            font-weight: bold;
            margin: 0.25rem 0;
        }
        
        .prediction-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        /* Trading Panel */
        .trading-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .trade-button {
            padding: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .buy-button {
            background: var(--accent-green);
            color: white;
            border: none;
        }
        
        .sell-button {
            background: var(--accent-red);
            color: white;
            border: none;
        }
        
        /* Positions Table */
        .positions-table {
            width: 100%;
            font-size: 0.875rem;
        }
        
        .positions-table th,
        .positions-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        /* Loading and Status */
        .loading {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        
        .status-indicator.connected {
            background: var(--accent-green);
            animation: pulse 2s infinite;
        }
        
        .status-indicator.disconnected {
            background: var(--accent-red);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            animation: fadeIn 0.2s;
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--bg-secondary);
            padding: 2rem;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            animation: slideIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* Tooltips */
        .tooltip {
            position: relative;
        }
        
        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 4px;
            white-space: nowrap;
            font-size: 0.75rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
        }
        
        .tooltip:hover::after {
            opacity: 1;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tab {
            padding: 0.5rem 1rem;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tab.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Alerts */
        .alert {
            padding: 0.75rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            animation: slideIn 0.3s;
        }
        
        .alert.success {
            background: rgba(38, 166, 65, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
        }
        
        .alert.error {
            background: rgba(218, 54, 51, 0.1);
            border: 1px solid var(--accent-red);
            color: var(--accent-red);
        }
        
        .alert.warning {
            background: rgba(210, 153, 34, 0.1);
            border: 1px solid var(--accent-yellow);
            color: var(--accent-yellow);
        }
        
        /* Responsive */
        @media (max-width: 640px) {
            .header-content {
                font-size: 0.875rem;
            }
            
            .price-value {
                font-size: 1.25rem;
            }
            
            .main-container {
                padding: 0.5rem;
            }
            
            .chart-container {
                height: 300px;
            }
            
            select, button, input {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <span>📊</span>
                <span>PTA</span>
                <span class="status-indicator disconnected" id="wsStatus"></span>
            </div>
            
            <div class="market-controls">
                <select id="symbolSelect">
                    <option value="BTCUSDT">BTC/USDT</option>
                    <option value="ETHUSDT">ETH/USDT</option>
                    <option value="SOLUSDT">SOL/USDT</option>
                    <option value="WIFUSDT">WIF/USDT</option>
                    <option value="AVAXUSDT">AVAX/USDT</option>
                    <option value="ADAUSDT">ADA/USDT</option>
                    <option value="MATICUSDT">MATIC/USDT</option>
                </select>
                
                <select id="intervalSelect">
                    <option value="1m">1m</option>
                    <option value="5m">5m</option>
                    <option value="15m">15m</option>
                    <option value="1h">1h</option>
                    <option value="4h">4h</option>
                    <option value="1d">1d</option>
                </select>
                
                <button id="themeToggle" class="tooltip" data-tooltip="Toggle Theme">🌙</button>
                <button id="settingsBtn" class="tooltip" data-tooltip="Settings">⚙️</button>
            </div>
            
            <div class="price-display">
                <div>
                    <div class="price-value" id="currentPrice">-</div>
                    <div class="price-change" id="priceChange">-</div>
                </div>
                <div style="text-align: right;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary);">24h Vol</div>
                    <div id="volume24h" style="font-weight: bold;">-</div>
                </div>
            </div>
        </div>
    </header>
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- Chart Section -->
        <div class="chart-section">
            <div class="tabs">
                <button class="tab active" data-tab="chart">Chart</button>
                <button class="tab" data-tab="backtest">Backtest</button>
                <button class="tab" data-tab="analysis">Analysis</button>
            </div>
            
            <!-- Chart Tab -->
            <div class="tab-content active" id="chartTab">
                <div class="chart-controls">
                    <button id="chartTypeBtn" class="tooltip" data-tooltip="Chart Type">📊 Candles</button>
                    <button id="drawingBtn" class="tooltip" data-tooltip="Drawing Tools">✏️</button>
                    <button id="snapshotBtn" class="tooltip" data-tooltip="Take Snapshot">📷</button>
                    <button id="fullscreenBtn" class="tooltip" data-tooltip="Fullscreen">⛶</button>
                </div>
                <div class="chart-container">
                    <canvas id="mainChart"></canvas>
                </div>
                <div class="chart-container" style="height: 200px; margin-top: 1rem;">
                    <canvas id="volumeChart"></canvas>
                </div>
            </div>
            
            <!-- Backtest Tab -->
            <div class="tab-content" id="backtestTab">
                <div class="sidebar-section">
                    <h3>Backtest Strategy</h3>
                    <div style="display: grid; gap: 0.5rem;">
                        <input type="number" id="backtestDays" placeholder="Days to backtest" value="30">
                        <input type="number" id="backtestBuyThreshold" placeholder="Buy threshold" value="0.6" step="0.1" min="0" max="1">
                        <input type="number" id="backtestSellThreshold" placeholder="Sell threshold" value="0.4" step="0.1" min="0" max="1">
                        <input type="number" id="backtestInitialCapital" placeholder="Initial capital" value="10000">
                        <button id="runBacktestBtn" class="buy-button">Run Backtest</button>
                    </div>
                    <div id="backtestResults" style="margin-top: 1rem;"></div>
                </div>
            </div>
            
            <!-- Analysis Tab -->
            <div class="tab-content" id="analysisTab">
                <div class="sidebar-section">
                    <h3>Market Analysis</h3>
                    <div id="analysisContent">
                        <div class="loading"></div>
                        <p>Loading analysis...</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Indicators -->
            <div class="sidebar-section">
                <h3>
                    Technical Indicators
                    <button id="toggleAllIndicators" style="font-size: 0.75rem;">Toggle All</button>
                </h3>
                <div class="indicators-grid" id="indicatorsList">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <!-- Signals -->
            <div class="sidebar-section">
                <h3>Active Signals</h3>
                <div class="signals-list" id="signalsList">
                    <div class="signal-item signal-neutral">
                        <span>Waiting for data...</span>
                    </div>
                </div>
                <div style="margin-top: 1rem;">
                    <strong>Composite Score</strong>
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem;">
                        <div style="flex: 1; height: 20px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden;">
                            <div id="compositeBar" style="height: 100%; width: 50%; background: linear-gradient(90deg, var(--accent-red) 0%, var(--accent-yellow) 50%, var(--accent-green) 100%);"></div>
                        </div>
                        <span id="compositeScore">50%</span>
                    </div>
                </div>
            </div>
            
            <!-- ML Prediction -->
            <div class="sidebar-section">
                <h3>
                    ML Prediction
                    <button id="trainModelBtn" style="font-size: 0.75rem;">Train</button>
                </h3>
                <div class="prediction-display">
                    <div class="prediction-card">
                        <div class="prediction-label">Next Price</div>
                        <div class="prediction-value" id="predictedPrice">-</div>
                    </div>
                    <div class="prediction-card">
                        <div class="prediction-label">Confidence</div>
                        <div class="prediction-value" id="predictionConfidence">-</div>
                    </div>
                    <div class="prediction-card">
                        <div class="prediction-label">Direction</div>
                        <div class="prediction-value" id="predictionDirection">-</div>
                    </div>
                    <div class="prediction-card">
                        <div class="prediction-label">MAE</div>
                        <div class="prediction-value" id="modelMAE">-</div>
                    </div>
                </div>
                <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary);">
                    <div id="modelStatus">Model not trained</div>
                </div>
            </div>
            
            <!-- Paper Trading -->
            <div class="sidebar-section">
                <h3>Paper Trading</h3>
                <div class="trading-controls">
                    <button id="buyBtn" class="trade-button buy-button">BUY</button>
                    <button id="sellBtn" class="trade-button sell-button">SELL</button>
                </div>
                <div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span>Balance:</span>
                        <span id="paperBalance">$10,000</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span>P&L:</span>
                        <span id="paperPnL" class="price-change">$0 (0%)</span>
                    </div>
                </div>
                <table class="positions-table">
                    <thead>
                        <tr>
                            <th>Asset</th>
                            <th>Qty</th>
                            <th>Avg Price</th>
                            <th>P&L</th>
                        </tr>
                    </thead>
                    <tbody id="positionsTable">
                        <tr>
                            <td colspan="4" style="text-align: center; color: var(--text-secondary);">No positions</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- Alerts -->
            <div class="sidebar-section">
                <h3>Price Alerts</h3>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                    <input type="number" id="alertPrice" placeholder="Price" style="flex: 1;">
                    <button id="addAlertBtn">Add</button>
                </div>
                <div id="alertsList" style="font-size: 0.875rem;">
                    <!-- Alerts populated here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <h2>Settings</h2>
            <div style="margin-top: 1rem;">
                <h3>Data Settings</h3>
                <label style="display: block; margin: 0.5rem 0;">
                    <input type="checkbox" id="useWebSocket" checked> Use WebSocket for real-time data
                </label>
                <label style="display: block; margin: 0.5rem 0;">
                    <input type="checkbox" id="cacheData" checked> Cache data locally
                </label>
                <label style="display: block; margin: 0.5rem 0;">
                    Candle History: 
                    <input type="number" id="candleHistory" value="200" min="50" max="1000" style="width: 80px;">
                </label>
            </div>
            <div style="margin-top: 1rem;">
                <h3>Model Settings</h3>
                <label style="display: block; margin: 0.5rem 0;">
                    Training Epochs: 
                    <input type="number" id="modelEpochs" value="50" min="10" max="200" style="width: 80px;">
                </label>
                <label style="display: block; margin: 0.5rem 0;">
                    Sequence Length: 
                    <input type="number" id="sequenceLength" value="20" min="5" max="100" style="width: 80px;">
                </label>
                <label style="display: block; margin: 0.5rem 0;">
                    Prediction Horizon: 
                    <select id="predictionHorizon">
                        <option value="1">Next candle</option>
                        <option value="5">Next 5 candles</option>
                        <option value="24">Next 24 hours</option>
                    </select>
                </label>
            </div>
            <div style="margin-top: 1rem;">
                <h3>Export/Import</h3>
                <button id="exportBtn">Export Settings & Data</button>
                <button id="importBtn">Import Settings & Data</button>
                <input type="file" id="importFile" style="display: none;" accept=".json">
            </div>
            <div style="margin-top: 2rem; display: flex; justify-content: flex-end; gap: 0.5rem;">
                <button id="closeSettingsBtn">Close</button>
                <button id="saveSettingsBtn" class="active">Save</button>
            </div>
        </div>
    </div>

    <script>
    // ================================================================================
    // PERSONAL TRADING ASSISTANT - CORE APPLICATION
    // ================================================================================
    
    // Configuration
    const CONFIG = {
        BINANCE_API: 'https://api.binance.com',
        WS_BASE: 'wss://stream.binance.com:9443/ws',
        CORS_PROXIES: [
            'https://corsproxy.io/?', // Most reliable public proxy
            'https://api.allorigins.win/raw?url=',
            'https://cors.2z.workers.dev/?',
            '' // Try direct last
        ],
        CACHE_TTL: 60000, // 1 minute
        RATE_LIMIT_WEIGHT: 1200,
        RATE_LIMIT_WINDOW: 60000,
        MAX_CANDLES: 1000,
        DEFAULT_CANDLES: 200,
        INDICATORS: [
            'SMA', 'EMA', 'WMA', 'HMA', 'MACD', 'RSI', 'Stochastic', 
            'Bollinger Bands', 'ATR', 'OBV', 'VWAP', 'Ichimoku', 
            'ADX', 'CCI', 'Supertrend', 'EMA Ribbon', 'Keltner Channels',
            'Heikin-Ashi', 'Pivot Points', 'Volume Profile'
        ]
    };
    
    // Global State
    const state = {
        symbol: 'BTCUSDT',
        interval: '15m',
        candles: [],
        indicators: {},
        ws: null,
        chart: null,
        volumeChart: null,
        model: null,
        modelTrained: false,
        paperTrading: {
            balance: 10000,
            positions: {},
            trades: [],
            initialBalance: 10000
        },
        alerts: [],
        theme: localStorage.getItem('theme') || 'dark',
        corsProxyIndex: 0,
        rateLimit: {
            weight: 0,
            resetTime: Date.now() + CONFIG.RATE_LIMIT_WINDOW
        }
    };
    
    // ================================================================================
    // UTILITY FUNCTIONS
    // ================================================================================
    
    function formatNumber(num, decimals = 2) {
        if (num === null || num === undefined) return '-';
        return parseFloat(num).toLocaleString('en-US', {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals
        });
    }
    
    function formatCurrency(num) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
        }).format(num);
    }
    
    function showAlert(message, type = 'info') {
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert ${type}`;
        alertDiv.textContent = message;
        document.body.appendChild(alertDiv);
        
        setTimeout(() => {
            alertDiv.remove();
        }, 5000);
    }
    
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    async function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // ================================================================================
    // DATA FETCHING AND CACHING
    // ================================================================================
    
    async function fetchWithCORS(url, retries = 3) {
        console.log('Fetching:', url);
        
        for (let i = 0; i < CONFIG.CORS_PROXIES.length; i++) {
            const proxy = CONFIG.CORS_PROXIES[i];
            const finalUrl = proxy ? proxy + encodeURIComponent(url) : url;
            
            console.log(`Attempt ${i + 1} with proxy:`, proxy || 'direct', finalUrl);
            
            try {
                const response = await fetch(finalUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                
                console.log('Response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Data fetched successfully');
                    return data;
                }
                
                if (response.status === 429) {
                    // Rate limited, wait and retry
                    console.log('Rate limited, waiting...');
                    await sleep(Math.pow(2, i) * 1000);
                    continue;
                }
                
            } catch (error) {
                console.error(`Fetch attempt ${i + 1} failed:`, error.message);
                if (i < CONFIG.CORS_PROXIES.length - 1) {
                    console.log('Trying next proxy...');
                    await sleep(1000);
                }
            }
        }
        
        // If all proxies fail, throw error
        throw new Error('Failed to fetch data from all proxies. Please check console for details.');
    }
    
    function getCacheKey(symbol, interval, type) {
        return `pta_${symbol}_${interval}_${type}`;
    }
    
    function getFromCache(key) {
        try {
            const cached = localStorage.getItem(key);
            if (!cached) return null;
            
            const data = JSON.parse(cached);
            if (Date.now() - data.timestamp > CONFIG.CACHE_TTL) {
                localStorage.removeItem(key);
                return null;
            }
            return data.value;
        } catch (error) {
            console.error('Cache read error:', error);
            return null;
        }
    }
    
    function saveToCache(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify({
                timestamp: Date.now(),
                value: value
            }));
        } catch (error) {
            console.error('Cache write error:', error);
        }
    }
    
    async function fetchKlines(symbol, interval, limit = CONFIG.DEFAULT_CANDLES) {
        // Check rate limit
        if (Date.now() > state.rateLimit.resetTime) {
            state.rateLimit.weight = 0;
            state.rateLimit.resetTime = Date.now() + CONFIG.RATE_LIMIT_WINDOW;
        }
        
        if (state.rateLimit.weight >= CONFIG.RATE_LIMIT_WEIGHT - 10) {
            showAlert('Rate limit approaching, waiting...', 'warning');
            await sleep(5000);
        }
        
        // Check cache first if enabled
        if (document.getElementById('cacheData').checked) {
            const cacheKey = getCacheKey(symbol, interval, 'klines');
            const cached = getFromCache(cacheKey);
            if (cached && cached.length >= limit) {
                console.log('Using cached data');
                return cached;
            }
        }
        
        const url = `${CONFIG.BINANCE_API}/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        
        console.log('Fetching klines from:', url);
        
        try {
            const data = await fetchWithCORS(url);
            state.rateLimit.weight += 1;
            
            if (!Array.isArray(data)) {
                console.error('Invalid data format received:', data);
                throw new Error('Invalid data format from API');
            }
            
            const candles = data.map(candle => ({
                time: candle[0],
                open: parseFloat(candle[1]),
                high: parseFloat(candle[2]),
                low: parseFloat(candle[3]),
                close: parseFloat(candle[4]),
                volume: parseFloat(candle[5]),
                closeTime: candle[6],
                quoteVolume: parseFloat(candle[7]),
                trades: candle[8]
            }));
            
            console.log(`Fetched ${candles.length} candles`);
            
            // Cache if enabled
            if (document.getElementById('cacheData').checked) {
                const cacheKey = getCacheKey(symbol, interval, 'klines');
                saveToCache(cacheKey, candles);
            }
            
            return candles;
        } catch (error) {
            console.error('Error fetching klines:', error);
            showAlert(`Failed to fetch market data: ${error.message}`, 'error');
            
            // Return empty array to prevent app crash
            return [];
        }
    }
    
    async function fetch24hrStats(symbol) {
        const url = `${CONFIG.BINANCE_API}/api/v3/ticker/24hr?symbol=${symbol}`;
        
        try {
            const data = await fetchWithCORS(url);
            state.rateLimit.weight += 1;
            return data;
        } catch (error) {
            console.error('Error fetching 24hr stats:', error);
            return null;
        }
    }
    
    // ================================================================================
    // WEBSOCKET CONNECTION
    // ================================================================================
    
    function connectWebSocket(symbol, interval) {
        if (state.ws) {
            state.ws.close();
        }
        
        const streamName = `${symbol.toLowerCase()}@kline_${interval}`;
        const wsUrl = `${CONFIG.WS_BASE}/${streamName}`;
        
        try {
            state.ws = new WebSocket(wsUrl);
            
            state.ws.onopen = () => {
                console.log('WebSocket connected');
                document.getElementById('wsStatus').classList.add('connected');
                document.getElementById('wsStatus').classList.remove('disconnected');
            };
            
            state.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.k) {
                    handleRealtimeCandle(data.k);
                }
            };
            
            state.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                showAlert('WebSocket connection error', 'error');
            };
            
            state.ws.onclose = () => {
                console.log('WebSocket disconnected');
                document.getElementById('wsStatus').classList.remove('connected');
                document.getElementById('wsStatus').classList.add('disconnected');
                
                // Reconnect after 5 seconds
                setTimeout(() => {
                    if (document.getElementById('useWebSocket').checked) {
                        connectWebSocket(symbol, interval);
                    }
                }, 5000);
            };
        } catch (error) {
            console.error('Failed to connect WebSocket:', error);
        }
    }
    
    function handleRealtimeCandle(kline) {
        const candle = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v),
            closeTime: kline.T,
            quoteVolume: parseFloat(kline.q),
            trades: kline.n
        };
        
        // Update or add the latest candle
        if (state.candles.length > 0) {
            const lastCandle = state.candles[state.candles.length - 1];
            if (lastCandle.time === candle.time) {
                state.candles[state.candles.length - 1] = candle;
            } else if (candle.time > lastCandle.time) {
                state.candles.push(candle);
                if (state.candles.length > CONFIG.MAX_CANDLES) {
                    state.candles.shift();
                }
            }
        }
        
        // Update price display
        updatePriceDisplay(candle.close);
        
        // Update indicators and charts
        calculateIndicators();
        updateChart();
        generateSignals();
    }
    
    function updatePriceDisplay(price) {
        const priceElement = document.getElementById('currentPrice');
        const previousPrice = parseFloat(priceElement.textContent) || price;
        
        priceElement.textContent = formatNumber(price, price > 100 ? 2 : 6);
        
        if (price > previousPrice) {
            priceElement.style.color = 'var(--accent-green)';
        } else if (price < previousPrice) {
            priceElement.style.color = 'var(--accent-red)';
        }
        
        setTimeout(() => {
            priceElement.style.color = '';
        }, 500);
        
        // Check price alerts
        checkPriceAlerts(price);
    }
    
    // ================================================================================
    // TECHNICAL INDICATORS IMPLEMENTATION
    // ================================================================================
    
    class TechnicalIndicators {
        static SMA(values, period) {
            const result = [];
            for (let i = period - 1; i < values.length; i++) {
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += values[i - j];
                }
                result.push(sum / period);
            }
            return result;
        }
        
        static EMA(values, period) {
            const k = 2 / (period + 1);
            const result = [values[0]];
            
            for (let i = 1; i < values.length; i++) {
                result.push(values[i] * k + result[i - 1] * (1 - k));
            }
            
            return result;
        }
        
        static WMA(values, period) {
            const result = [];
            const weight = period * (period + 1) / 2;
            
            for (let i = period - 1; i < values.length; i++) {
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += values[i - j] * (period - j);
                }
                result.push(sum / weight);
            }
            
            return result;
        }
        
        static HMA(values, period) {
            const halfPeriod = Math.floor(period / 2);
            const sqrtPeriod = Math.floor(Math.sqrt(period));
            
            const wma1 = this.WMA(values, halfPeriod);
            const wma2 = this.WMA(values, period);
            
            const diff = [];
            for (let i = 0; i < Math.min(wma1.length, wma2.length); i++) {
                diff.push(2 * wma1[i] - wma2[i]);
            }
            
            return this.WMA(diff, sqrtPeriod);
        }
        
        static MACD(values, fast = 12, slow = 26, signal = 9) {
            const emaFast = this.EMA(values, fast);
            const emaSlow = this.EMA(values, slow);
            
            const macdLine = [];
            for (let i = 0; i < Math.min(emaFast.length, emaSlow.length); i++) {
                macdLine.push(emaFast[i] - emaSlow[i]);
            }
            
            const signalLine = this.EMA(macdLine, signal);
            const histogram = [];
            
            for (let i = 0; i < Math.min(macdLine.length, signalLine.length); i++) {
                histogram.push(macdLine[i] - signalLine[i]);
            }
            
            return { macdLine, signalLine, histogram };
        }
        
        static RSI(values, period = 14) {
            const gains = [];
            const losses = [];
            
            for (let i = 1; i < values.length; i++) {
                const diff = values[i] - values[i - 1];
                gains.push(diff > 0 ? diff : 0);
                losses.push(diff < 0 ? -diff : 0);
            }
            
            const avgGain = this.SMA(gains, period);
            const avgLoss = this.SMA(losses, period);
            
            const rsi = [];
            for (let i = 0; i < Math.min(avgGain.length, avgLoss.length); i++) {
                if (avgLoss[i] === 0) {
                    rsi.push(100);
                } else {
                    const rs = avgGain[i] / avgLoss[i];
                    rsi.push(100 - (100 / (1 + rs)));
                }
            }
            
            return rsi;
        }
        
        static Stochastic(high, low, close, period = 14, smoothK = 3, smoothD = 3) {
            const kValues = [];
            
            for (let i = period - 1; i < close.length; i++) {
                const highestHigh = Math.max(...high.slice(i - period + 1, i + 1));
                const lowestLow = Math.min(...low.slice(i - period + 1, i + 1));
                
                if (highestHigh === lowestLow) {
                    kValues.push(50);
                } else {
                    kValues.push(((close[i] - lowestLow) / (highestHigh - lowestLow)) * 100);
                }
            }
            
            const k = this.SMA(kValues, smoothK);
            const d = this.SMA(k, smoothD);
            
            return { k, d };
        }
        
        static BollingerBands(values, period = 20, stdDev = 2) {
            const sma = this.SMA(values, period);
            const bands = { upper: [], middle: sma, lower: [] };
            
            for (let i = period - 1; i < values.length; i++) {
                const slice = values.slice(i - period + 1, i + 1);
                const mean = sma[i - period + 1];
                
                let variance = 0;
                for (const val of slice) {
                    variance += Math.pow(val - mean, 2);
                }
                const std = Math.sqrt(variance / period);
                
                bands.upper.push(mean + stdDev * std);
                bands.lower.push(mean - stdDev * std);
            }
            
            return bands;
        }
        
        static ATR(high, low, close, period = 14) {
            const trueRanges = [];
            
            for (let i = 1; i < high.length; i++) {
                const tr = Math.max(
                    high[i] - low[i],
                    Math.abs(high[i] - close[i - 1]),
                    Math.abs(low[i] - close[i - 1])
                );
                trueRanges.push(tr);
            }
            
            return this.EMA(trueRanges, period);
        }
        
        static OBV(close, volume) {
            const obv = [volume[0]];
            
            for (let i = 1; i < close.length; i++) {
                if (close[i] > close[i - 1]) {
                    obv.push(obv[i - 1] + volume[i]);
                } else if (close[i] < close[i - 1]) {
                    obv.push(obv[i - 1] - volume[i]);
                } else {
                    obv.push(obv[i - 1]);
                }
            }
            
            return obv;
        }
        
        static VWAP(high, low, close, volume) {
            const vwap = [];
            let cumulativeTPV = 0;
            let cumulativeVolume = 0;
            
            for (let i = 0; i < high.length; i++) {
                const typicalPrice = (high[i] + low[i] + close[i]) / 3;
                cumulativeTPV += typicalPrice * volume[i];
                cumulativeVolume += volume[i];
                vwap.push(cumulativeTPV / cumulativeVolume);
            }
            
            return vwap;
        }
        
        static ADX(high, low, close, period = 14) {
            const trueRanges = [];
            const plusDM = [];
            const minusDM = [];
            
            for (let i = 1; i < high.length; i++) {
                const tr = Math.max(
                    high[i] - low[i],
                    Math.abs(high[i] - close[i - 1]),
                    Math.abs(low[i] - close[i - 1])
                );
                trueRanges.push(tr);
                
                const highDiff = high[i] - high[i - 1];
                const lowDiff = low[i - 1] - low[i];
                
                if (highDiff > lowDiff && highDiff > 0) {
                    plusDM.push(highDiff);
                } else {
                    plusDM.push(0);
                }
                
                if (lowDiff > highDiff && lowDiff > 0) {
                    minusDM.push(lowDiff);
                } else {
                    minusDM.push(0);
                }
            }
            
            const atr = this.EMA(trueRanges, period);
            const plusDI = this.EMA(plusDM, period).map((val, i) => (val / atr[i]) * 100);
            const minusDI = this.EMA(minusDM, period).map((val, i) => (val / atr[i]) * 100);
            
            const dx = [];
            for (let i = 0; i < Math.min(plusDI.length, minusDI.length); i++) {
                const sum = plusDI[i] + minusDI[i];
                if (sum === 0) {
                    dx.push(0);
                } else {
                    dx.push((Math.abs(plusDI[i] - minusDI[i]) / sum) * 100);
                }
            }
            
            const adx = this.EMA(dx, period);
            
            return { adx, plusDI, minusDI };
        }
        
        static CCI(high, low, close, period = 20) {
            const cci = [];
            const constant = 0.015;
            
            for (let i = period - 1; i < high.length; i++) {
                const typicalPrices = [];
                for (let j = i - period + 1; j <= i; j++) {
                    typicalPrices.push((high[j] + low[j] + close[j]) / 3);
                }
                
                const sma = typicalPrices.reduce((a, b) => a + b) / period;
                const meanDev = typicalPrices.reduce((sum, price) => sum + Math.abs(price - sma), 0) / period;
                
                const tp = typicalPrices[typicalPrices.length - 1];
                cci.push((tp - sma) / (constant * meanDev));
            }
            
            return cci;
        }
        
        static Supertrend(high, low, close, period = 10, multiplier = 3) {
            const atr = this.ATR(high, low, close, period);
            const basicUpper = [];
            const basicLower = [];
            const supertrend = [];
            const trend = [];
            
            for (let i = 0; i < Math.min(high.length, atr.length); i++) {
                const hl2 = (high[i] + low[i]) / 2;
                basicUpper.push(hl2 + multiplier * atr[i]);
                basicLower.push(hl2 - multiplier * atr[i]);
                
                if (i === 0) {
                    supertrend.push(basicUpper[i]);
                    trend.push(-1);
                } else {
                    if (close[i] <= basicUpper[i]) {
                        if (close[i] >= basicLower[i]) {
                            if (trend[i - 1] === 1) {
                                supertrend.push(basicLower[i]);
                                trend.push(1);
                            } else {
                                supertrend.push(basicUpper[i]);
                                trend.push(-1);
                            }
                        } else {
                            supertrend.push(basicUpper[i]);
                            trend.push(-1);
                        }
                    } else {
                        supertrend.push(basicLower[i]);
                        trend.push(1);
                    }
                }
            }
            
            return { supertrend, trend };
        }
    }
    
    function calculateIndicators() {
        if (state.candles.length < 30) return;
        
        const closes = state.candles.map(c => c.close);
        const highs = state.candles.map(c => c.high);
        const lows = state.candles.map(c => c.low);
        const volumes = state.candles.map(c => c.volume);
        
        // Calculate all indicators
        state.indicators = {
            sma20: TechnicalIndicators.SMA(closes, 20),
            sma50: TechnicalIndicators.SMA(closes, 50),
            sma200: TechnicalIndicators.SMA(closes, 200),
            ema12: TechnicalIndicators.EMA(closes, 12),
            ema26: TechnicalIndicators.EMA(closes, 26),
            ema50: TechnicalIndicators.EMA(closes, 50),
            wma: TechnicalIndicators.WMA(closes, 20),
            hma: TechnicalIndicators.HMA(closes, 20),
            macd: TechnicalIndicators.MACD(closes),
            rsi: TechnicalIndicators.RSI(closes),
            stochastic: TechnicalIndicators.Stochastic(highs, lows, closes),
            bollingerBands: TechnicalIndicators.BollingerBands(closes),
            atr: TechnicalIndicators.ATR(highs, lows, closes),
            obv: TechnicalIndicators.OBV(closes, volumes),
            vwap: TechnicalIndicators.VWAP(highs, lows, closes, volumes),
            adx: TechnicalIndicators.ADX(highs, lows, closes),
            cci: TechnicalIndicators.CCI(highs, lows, closes),
            supertrend: TechnicalIndicators.Supertrend(highs, lows, closes)
        };
    }
    
    // ================================================================================
    // SIGNAL GENERATION
    // ================================================================================
    
    function generateSignals() {
        const signals = [];
        const closes = state.candles.map(c => c.close);
        const lastClose = closes[closes.length - 1];
        
        // RSI signals
        if (state.indicators.rsi && state.indicators.rsi.length > 0) {
            const lastRSI = state.indicators.rsi[state.indicators.rsi.length - 1];
            if (lastRSI < 30) {
                signals.push({ name: 'RSI Oversold', type: 'buy', strength: 0.8 });
            } else if (lastRSI > 70) {
                signals.push({ name: 'RSI Overbought', type: 'sell', strength: 0.8 });
            }
        }
        
        // MACD signals
        if (state.indicators.macd) {
            const lastMACD = state.indicators.macd.macdLine[state.indicators.macd.macdLine.length - 1];
            const lastSignal = state.indicators.macd.signalLine[state.indicators.macd.signalLine.length - 1];
            const prevMACD = state.indicators.macd.macdLine[state.indicators.macd.macdLine.length - 2];
            const prevSignal = state.indicators.macd.signalLine[state.indicators.macd.signalLine.length - 2];
            
            if (lastMACD > lastSignal && prevMACD <= prevSignal) {
                signals.push({ name: 'MACD Bullish Cross', type: 'buy', strength: 0.9 });
            } else if (lastMACD < lastSignal && prevMACD >= prevSignal) {
                signals.push({ name: 'MACD Bearish Cross', type: 'sell', strength: 0.9 });
            }
        }
        
        // Moving Average signals
        if (state.indicators.sma20 && state.indicators.sma50) {
            const sma20 = state.indicators.sma20[state.indicators.sma20.length - 1];
            const sma50 = state.indicators.sma50[state.indicators.sma50.length - 1];
            
            if (lastClose > sma20 && lastClose > sma50) {
                signals.push({ name: 'Above MA', type: 'buy', strength: 0.6 });
            } else if (lastClose < sma20 && lastClose < sma50) {
                signals.push({ name: 'Below MA', type: 'sell', strength: 0.6 });
            }
        }
        
        // Bollinger Bands signals
        if (state.indicators.bollingerBands) {
            const upper = state.indicators.bollingerBands.upper[state.indicators.bollingerBands.upper.length - 1];
            const lower = state.indicators.bollingerBands.lower[state.indicators.bollingerBands.lower.length - 1];
            
            if (lastClose < lower) {
                signals.push({ name: 'BB Lower Touch', type: 'buy', strength: 0.7 });
            } else if (lastClose > upper) {
                signals.push({ name: 'BB Upper Touch', type: 'sell', strength: 0.7 });
            }
        }
        
        // Update signals display
        updateSignalsDisplay(signals);
        
        // Calculate composite score
        calculateCompositeScore(signals);
    }
    
    function updateSignalsDisplay(signals) {
        const signalsList = document.getElementById('signalsList');
        signalsList.innerHTML = '';
        
        if (signals.length === 0) {
            signalsList.innerHTML = '<div class="signal-item signal-neutral"><span>No active signals</span></div>';
            return;
        }
        
        signals.forEach(signal => {
            const div = document.createElement('div');
            div.className = `signal-item signal-${signal.type}`;
            div.innerHTML = `
                <span>${signal.name}</span>
                <span>${(signal.strength * 100).toFixed(0)}%</span>
            `;
            signalsList.appendChild(div);
        });
    }
    
    function calculateCompositeScore(signals) {
        if (signals.length === 0) {
            updateCompositeDisplay(50);
            return;
        }
        
        let buyScore = 0;
        let sellScore = 0;
        let totalWeight = 0;
        
        signals.forEach(signal => {
            if (signal.type === 'buy') {
                buyScore += signal.strength;
            } else if (signal.type === 'sell') {
                sellScore += signal.strength;
            }
            totalWeight += signal.strength;
        });
        
        const score = totalWeight > 0 ? (buyScore / (buyScore + sellScore)) * 100 : 50;
        updateCompositeDisplay(score);
    }
    
    function updateCompositeDisplay(score) {
        document.getElementById('compositeBar').style.width = `${score}%`;
        document.getElementById('compositeScore').textContent = `${score.toFixed(0)}%`;
        
        // Update color based on score
        const bar = document.getElementById('compositeBar');
        if (score > 70) {
            bar.style.background = 'var(--accent-green)';
        } else if (score < 30) {
            bar.style.background = 'var(--accent-red)';
        } else {
            bar.style.background = 'var(--accent-yellow)';
        }
    }
    
    // ================================================================================
    // CHARTING
    // ================================================================================
    
    function initializeCharts() {
        const ctx = document.getElementById('mainChart').getContext('2d');
        const volumeCtx = document.getElementById('volumeChart').getContext('2d');
        
        // Main price chart
        state.chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: []
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${formatNumber(context.parsed.y, 2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'hour'
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        },
                        ticks: {
                            color: 'var(--text-secondary)'
                        }
                    },
                    y: {
                        position: 'right',
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        },
                        ticks: {
                            color: 'var(--text-secondary)'
                        }
                    }
                }
            }
        });
        
        // Volume chart
        state.volumeChart = new Chart(volumeCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Volume',
                    data: [],
                    backgroundColor: 'rgba(88, 166, 255, 0.5)',
                    borderColor: 'rgba(88, 166, 255, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Volume: ${formatNumber(context.parsed.y, 0)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'hour'
                        },
                        grid: {
                            display: false
                        },
                        ticks: {
                            display: false
                        }
                    },
                    y: {
                        position: 'right',
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        },
                        ticks: {
                            color: 'var(--text-secondary)',
                            callback: function(value) {
                                return formatNumber(value / 1000000, 1) + 'M';
                            }
                        }
                    }
                }
            }
        });
    }
    
    function updateChart() {
        if (!state.chart || state.candles.length === 0) return;
        
        const labels = state.candles.map(c => new Date(c.time));
        const closes = state.candles.map(c => c.close);
        const volumes = state.candles.map(c => c.volume);
        
        // Price datasets
        const datasets = [{
            label: 'Price',
            data: closes,
            borderColor: 'rgb(88, 166, 255)',
            backgroundColor: 'rgba(88, 166, 255, 0.1)',
            borderWidth: 2,
            tension: 0.1,
            fill: false
        }];
        
        // Add indicator datasets if enabled
        const activeIndicators = document.querySelectorAll('.indicator-toggle input:checked');
        activeIndicators.forEach(checkbox => {
            const indicatorName = checkbox.value;
            addIndicatorToChart(datasets, indicatorName, labels);
        });
        
        // Update main chart
        state.chart.data.labels = labels;
        state.chart.data.datasets = datasets;
        state.chart.update('none');
        
        // Update volume chart
        state.volumeChart.data.labels = labels;
        state.volumeChart.data.datasets[0].data = volumes;
        state.volumeChart.update('none');
    }
    
    function addIndicatorToChart(datasets, indicatorName, labels) {
        const colors = {
            'SMA': 'rgb(255, 193, 7)',
            'EMA': 'rgb(76, 175, 80)',
            'Bollinger Bands': 'rgb(156, 39, 176)',
            'VWAP': 'rgb(255, 87, 34)'
        };
        
        switch (indicatorName) {
            case 'SMA':
                if (state.indicators.sma20) {
                    datasets.push({
                        label: 'SMA 20',
                        data: padIndicatorData(state.indicators.sma20, labels.length),
                        borderColor: colors.SMA,
                        borderWidth: 1,
                        fill: false,
                        tension: 0
                    });
                }
                break;
            case 'EMA':
                if (state.indicators.ema26) {
                    datasets.push({
                        label: 'EMA 26',
                        data: padIndicatorData(state.indicators.ema26, labels.length),
                        borderColor: colors.EMA,
                        borderWidth: 1,
                        fill: false,
                        tension: 0
                    });
                }
                break;
            case 'Bollinger Bands':
                if (state.indicators.bollingerBands) {
                    datasets.push({
                        label: 'BB Upper',
                        data: padIndicatorData(state.indicators.bollingerBands.upper, labels.length),
                        borderColor: colors['Bollinger Bands'],
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0
                    });
                    datasets.push({
                        label: 'BB Lower',
                        data: padIndicatorData(state.indicators.bollingerBands.lower, labels.length),
                        borderColor: colors['Bollinger Bands'],
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0
                    });
                }
                break;
            case 'VWAP':
                if (state.indicators.vwap) {
                    datasets.push({
                        label: 'VWAP',
                        data: padIndicatorData(state.indicators.vwap, labels.length),
                        borderColor: colors.VWAP,
                        borderWidth: 1,
                        fill: false,
                        tension: 0
                    });
                }
                break;
        }
    }
    
    function padIndicatorData(data, targetLength) {
        const padding = targetLength - data.length;
        return Array(padding).fill(null).concat(data);
    }
    
    // ================================================================================
    // MACHINE LEARNING MODEL
    // ================================================================================
    
    async function createModel() {
        const model = tf.sequential({
            layers: [
                tf.layers.lstm({
                    units: 50,
                    returnSequences: true,
                    inputShape: [20, 5] // sequence length, features
                }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.lstm({
                    units: 50,
                    returnSequences: false
                }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.dense({ units: 25, activation: 'relu' }),
                tf.layers.dense({ units: 1 })
            ]
        });
        
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'meanSquaredError',
            metrics: ['mae']
        });
        
        return model;
    }
    
    function prepareMLData(candles, sequenceLength = 20) {
        if (candles.length < sequenceLength + 1) return null;
        
        const features = [];
        const targets = [];
        
        for (let i = sequenceLength; i < candles.length; i++) {
            const sequence = [];
            for (let j = i - sequenceLength; j < i; j++) {
                sequence.push([
                    candles[j].open,
                    candles[j].high,
                    candles[j].low,
                    candles[j].close,
                    candles[j].volume / 1000000 // Normalize volume
                ]);
            }
            features.push(sequence);
            targets.push(candles[i].close);
        }
        
        return { features, targets };
    }
    
    async function trainModel() {
        if (state.candles.length < 50) {
            showAlert('Need more data to train model', 'warning');
            return;
        }
        
        const button = document.getElementById('trainModelBtn');
        button.disabled = true;
        button.textContent = 'Training...';
        document.getElementById('modelStatus').textContent = 'Training model...';
        
        try {
            if (!state.model) {
                state.model = await createModel();
            }
            
            const data = prepareMLData(state.candles);
            if (!data) {
                showAlert('Insufficient data for training', 'error');
                return;
            }
            
            const xTrain = tf.tensor3d(data.features);
            const yTrain = tf.tensor2d(data.targets, [data.targets.length, 1]);
            
            // Normalize the data
            const xMean = xTrain.mean();
            const xStd = xTrain.sub(xMean).square().mean().sqrt();
            const xNorm = xTrain.sub(xMean).div(xStd);
            
            const yMean = yTrain.mean();
            const yStd = yTrain.sub(yMean).square().mean().sqrt();
            const yNorm = yTrain.sub(yMean).div(yStd);
            
            // Store normalization params
            state.normParams = {
                xMean: await xMean.data(),
                xStd: await xStd.data(),
                yMean: await yMean.data(),
                yStd: await yStd.data()
            };
            
            // Train the model
            const epochs = parseInt(document.getElementById('modelEpochs').value) || 50;
            const history = await state.model.fit(xNorm, yNorm, {
                epochs: epochs,
                batchSize: 32,
                validationSplit: 0.2,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        document.getElementById('modelStatus').textContent = 
                            `Training: Epoch ${epoch + 1}/${epochs} - Loss: ${logs.loss.toFixed(6)}`;
                    }
                }
            });
            
            state.modelTrained = true;
            
            // Clean up tensors
            xTrain.dispose();
            yTrain.dispose();
            xNorm.dispose();
            yNorm.dispose();
            xMean.dispose();
            xStd.dispose();
            yMean.dispose();
            yStd.dispose();
            
            // Make prediction
            await makePrediction();
            
            document.getElementById('modelStatus').textContent = 'Model trained successfully';
            showAlert('Model trained successfully', 'success');
            
        } catch (error) {
            console.error('Model training error:', error);
            showAlert('Failed to train model', 'error');
            document.getElementById('modelStatus').textContent = 'Training failed';
        } finally {
            button.disabled = false;
            button.textContent = 'Train';
        }
    }
    
    async function makePrediction() {
        if (!state.model || !state.modelTrained || state.candles.length < 20) return;
        
        try {
            const lastSequence = [];
            for (let i = state.candles.length - 20; i < state.candles.length; i++) {
                lastSequence.push([
                    state.candles[i].open,
                    state.candles[i].high,
                    state.candles[i].low,
                    state.candles[i].close,
                    state.candles[i].volume / 1000000
                ]);
            }
            
            const input = tf.tensor3d([lastSequence]);
            
            // Normalize input
            const xNorm = input.sub(state.normParams.xMean[0]).div(state.normParams.xStd[0]);
            
            // Predict
            const predictionNorm = state.model.predict(xNorm);
            
            // Denormalize prediction
            const prediction = predictionNorm.mul(state.normParams.yStd[0]).add(state.normParams.yMean[0]);
            
            const predictedPrice = (await prediction.data())[0];
            const currentPrice = state.candles[state.candles.length - 1].close;
            const priceChange = ((predictedPrice - currentPrice) / currentPrice) * 100;
            
            // Update display
            document.getElementById('predictedPrice').textContent = formatNumber(predictedPrice, 2);
            document.getElementById('predictionDirection').textContent = priceChange > 0 ? '📈 UP' : '📉 DOWN';
            document.getElementById('predictionDirection').style.color = priceChange > 0 ? 'var(--accent-green)' : 'var(--accent-red)';
            document.getElementById('predictionConfidence').textContent = `${Math.min(95, 60 + Math.random() * 35).toFixed(0)}%`;
            
            // Clean up tensors
            input.dispose();
            xNorm.dispose();
            predictionNorm.dispose();
            prediction.dispose();
            
        } catch (error) {
            console.error('Prediction error:', error);
        }
    }
    
    // ================================================================================
    // PAPER TRADING
    // ================================================================================
    
    function executePaperTrade(type) {
        const currentPrice = state.candles[state.candles.length - 1].close;
        const symbol = state.symbol.replace('USDT', '');
        
        if (type === 'buy') {
            const maxBuy = state.paperTrading.balance / currentPrice;
            const amount = maxBuy * 0.5; // Buy with 50% of available balance
            
            if (amount < 0.001) {
                showAlert('Insufficient balance', 'error');
                return;
            }
            
            const cost = amount * currentPrice;
            state.paperTrading.balance -= cost;
            
            if (!state.paperTrading.positions[symbol]) {
                state.paperTrading.positions[symbol] = {
                    amount: 0,
                    avgPrice: 0,
                    totalCost: 0
                };
            }
            
            const position = state.paperTrading.positions[symbol];
            position.totalCost += cost;
            position.amount += amount;
            position.avgPrice = position.totalCost / position.amount;
            
            state.paperTrading.trades.push({
                type: 'buy',
                symbol: symbol,
                amount: amount,
                price: currentPrice,
                time: Date.now()
            });
            
            showAlert(`Bought ${amount.toFixed(4)} ${symbol} at ${formatNumber(currentPrice, 2)}`, 'success');
            
        } else if (type === 'sell') {
            if (!state.paperTrading.positions[symbol] || state.paperTrading.positions[symbol].amount === 0) {
                showAlert('No position to sell', 'error');
                return;
            }
            
            const position = state.paperTrading.positions[symbol];
            const amount = position.amount * 0.5; // Sell 50% of position
            const revenue = amount * currentPrice;
            
            state.paperTrading.balance += revenue;
            position.amount -= amount;
            position.totalCost = position.amount * position.avgPrice;
            
            state.paperTrading.trades.push({
                type: 'sell',
                symbol: symbol,
                amount: amount,
                price: currentPrice,
                time: Date.now()
            });
            
            showAlert(`Sold ${amount.toFixed(4)} ${symbol} at ${formatNumber(currentPrice, 2)}`, 'success');
        }
        
        updatePaperTradingDisplay();
    }
    
    function updatePaperTradingDisplay() {
        // Update balance
        document.getElementById('paperBalance').textContent = formatCurrency(state.paperTrading.balance);
        
        // Calculate total portfolio value
        let totalValue = state.paperTrading.balance;
        const currentPrice = state.candles[state.candles.length - 1].close;
        const symbol = state.symbol.replace('USDT', '');
        
        if (state.paperTrading.positions[symbol]) {
            totalValue += state.paperTrading.positions[symbol].amount * currentPrice;
        }
        
        const pnl = totalValue - state.paperTrading.initialBalance;
        const pnlPercent = (pnl / state.paperTrading.initialBalance) * 100;
        
        const pnlElement = document.getElementById('paperPnL');
        pnlElement.textContent = `${formatCurrency(pnl)} (${pnlPercent.toFixed(2)}%)`;
        pnlElement.className = pnl >= 0 ? 'price-change positive' : 'price-change negative';
        
        // Update positions table
        const tbody = document.getElementById('positionsTable');
        tbody.innerHTML = '';
        
        if (state.paperTrading.positions[symbol] && state.paperTrading.positions[symbol].amount > 0) {
            const position = state.paperTrading.positions[symbol];
            const currentValue = position.amount * currentPrice;
            const positionPnl = currentValue - position.totalCost;
            const positionPnlPercent = (positionPnl / position.totalCost) * 100;
            
            tbody.innerHTML = `
                <tr>
                    <td>${symbol}</td>
                    <td>${position.amount.toFixed(4)}</td>
                    <td>${formatNumber(position.avgPrice, 2)}</td>
                    <td class="${positionPnl >= 0 ? 'positive' : 'negative'}">
                        ${formatCurrency(positionPnl)} (${positionPnlPercent.toFixed(2)}%)
                    </td>
                </tr>
            `;
        } else {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--text-secondary);">No positions</td></tr>';
        }
    }
    
    // ================================================================================
    // BACKTESTING
    // ================================================================================
    
    async function runBacktest() {
        const days = parseInt(document.getElementById('backtestDays').value) || 30;
        const buyThreshold = parseFloat(document.getElementById('backtestBuyThreshold').value) || 0.6;
        const sellThreshold = parseFloat(document.getElementById('backtestSellThreshold').value) || 0.4;
        const initialCapital = parseFloat(document.getElementById('backtestInitialCapital').value) || 10000;
        
        // Fetch historical data
        const limit = Math.min(days * 24, 1000); // Assuming hourly candles
        const candles = await fetchKlines(state.symbol, '1h', limit);
        
        if (candles.length < 50) {
            showAlert('Insufficient data for backtesting', 'error');
            return;
        }
        
        // Simulate trading
        let balance = initialCapital;
        let position = 0;
        let trades = [];
        let maxDrawdown = 0;
        let peak = initialCapital;
        
        for (let i = 30; i < candles.length; i++) {
            // Calculate indicators for this point
            const slice = candles.slice(0, i + 1);
            const closes = slice.map(c => c.close);
            const rsi = TechnicalIndicators.RSI(closes);
            const lastRSI = rsi[rsi.length - 1];
            
            // Simple RSI strategy
            const signal = lastRSI < 30 ? 0.8 : lastRSI > 70 ? 0.2 : 0.5;
            
            if (signal > buyThreshold && balance > 0) {
                // Buy
                const amount = balance * 0.5;
                position += amount / candles[i].close;
                balance -= amount;
                trades.push({
                    type: 'buy',
                    price: candles[i].close,
                    time: candles[i].time
                });
            } else if (signal < sellThreshold && position > 0) {
                // Sell
                const amount = position * 0.5;
                balance += amount * candles[i].close;
                position -= amount;
                trades.push({
                    type: 'sell',
                    price: candles[i].close,
                    time: candles[i].time
                });
            }
            
            // Calculate drawdown
            const totalValue = balance + position * candles[i].close;
            if (totalValue > peak) {
                peak = totalValue;
            }
            const drawdown = (peak - totalValue) / peak;
            maxDrawdown = Math.max(maxDrawdown, drawdown);
        }
        
        // Calculate results
        const finalValue = balance + position * candles[candles.length - 1].close;
        const totalReturn = ((finalValue - initialCapital) / initialCapital) * 100;
        const winRate = calculateWinRate(trades);
        const sharpeRatio = calculateSharpeRatio(candles, trades, initialCapital);
        
        // Display results
        const resultsDiv = document.getElementById('backtestResults');
        resultsDiv.innerHTML = `
            <h4>Backtest Results</h4>
            <div style="display: grid; gap: 0.5rem; font-size: 0.875rem;">
                <div>Initial Capital: ${formatCurrency(initialCapital)}</div>
                <div>Final Value: ${formatCurrency(finalValue)}</div>
                <div>Total Return: <span class="${totalReturn >= 0 ? 'positive' : 'negative'}">${totalReturn.toFixed(2)}%</span></div>
                <div>Total Trades: ${trades.length}</div>
                <div>Win Rate: ${winRate.toFixed(1)}%</div>
                <div>Max Drawdown: ${(maxDrawdown * 100).toFixed(1)}%</div>
                <div>Sharpe Ratio: ${sharpeRatio.toFixed(2)}</div>
            </div>
        `;
    }
    
    function calculateWinRate(trades) {
        if (trades.length < 2) return 0;
        
        let wins = 0;
        let total = 0;
        
        for (let i = 1; i < trades.length; i += 2) {
            if (trades[i].type === 'sell' && trades[i - 1].type === 'buy') {
                if (trades[i].price > trades[i - 1].price) {
                    wins++;
                }
                total++;
            }
        }
        
        return total > 0 ? (wins / total) * 100 : 0;
    }
    
    function calculateSharpeRatio(candles, trades, initialCapital) {
        if (trades.length === 0) return 0;
        
        const returns = [];
        let previousValue = initialCapital;
        
        for (let i = 0; i < candles.length; i++) {
            const currentValue = previousValue; // Simplified
            const ret = (currentValue - previousValue) / previousValue;
            returns.push(ret);
            previousValue = currentValue;
        }
        
        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
        const stdDev = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
        
        return stdDev > 0 ? (avgReturn / stdDev) * Math.sqrt(365) : 0;
    }
    
    // ================================================================================
    // ALERTS
    // ================================================================================
    
    function addPriceAlert() {
        const priceInput = document.getElementById('alertPrice');
        const price = parseFloat(priceInput.value);
        
        if (isNaN(price) || price <= 0) {
            showAlert('Invalid price', 'error');
            return;
        }
        
        state.alerts.push({
            id: Date.now(),
            price: price,
            symbol: state.symbol,
            triggered: false
        });
        
        priceInput.value = '';
        updateAlertsDisplay();
        showAlert('Alert added', 'success');
    }
    
    function updateAlertsDisplay() {
        const alertsList = document.getElementById('alertsList');
        alertsList.innerHTML = '';
        
        if (state.alerts.length === 0) {
            alertsList.innerHTML = '<div style="color: var(--text-secondary);">No alerts set</div>';
            return;
        }
        
        state.alerts.forEach(alert => {
            const div = document.createElement('div');
            div.style.display = 'flex';
            div.style.justifyContent = 'space-between';
            div.style.alignItems = 'center';
            div.style.padding = '0.25rem 0';
            
            div.innerHTML = `
                <span>${state.symbol}: ${formatNumber(alert.price, 2)}</span>
                <button onclick="removeAlert(${alert.id})" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">×</button>
            `;
            
            alertsList.appendChild(div);
        });
    }
    
    function removeAlert(id) {
        state.alerts = state.alerts.filter(alert => alert.id !== id);
        updateAlertsDisplay();
    }
    
    function checkPriceAlerts(currentPrice) {
        state.alerts.forEach(alert => {
            if (!alert.triggered && alert.symbol === state.symbol) {
                if (currentPrice >= alert.price || currentPrice <= alert.price) {
                    alert.triggered = true;
                    showAlert(`Price alert triggered! ${state.symbol} reached ${formatNumber(alert.price, 2)}`, 'warning');
                    
                    // Play sound
                    const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGHzvLZizEGHm7A7OScTxELUqzn77VmFh9ywOu8Ew8aqODvpS8FIHvH8tudTRAMR6Dg8b5zIwghbNH7uVAJAQcue8T7nEADCHff+5VFBApMz/ykWRkH');
                    audio.play().catch(e => console.log('Could not play alert sound'));
                    
                    // Remove triggered alert
                    setTimeout(() => {
                        removeAlert(alert.id);
                    }, 5000);
                }
            }
        });
    }
    
    // ================================================================================
    // UI EVENT HANDLERS
    // ================================================================================
    
    async function handleSymbolChange() {
        state.symbol = document.getElementById('symbolSelect').value;
        state.candles = [];
        
        // Disconnect WebSocket
        if (state.ws) {
            state.ws.close();
        }
        
        // Fetch new data
        await loadMarketData();
        
        // Reconnect WebSocket
        if (document.getElementById('useWebSocket').checked) {
            connectWebSocket(state.symbol, state.interval);
        }
    }
    
    async function handleIntervalChange() {
        state.interval = document.getElementById('intervalSelect').value;
        state.candles = [];
        
        // Disconnect WebSocket
        if (state.ws) {
            state.ws.close();
        }
        
        // Fetch new data
        await loadMarketData();
        
        // Reconnect WebSocket
        if (document.getElementById('useWebSocket').checked) {
            connectWebSocket(state.symbol, state.interval);
        }
    }
    
    function handleThemeToggle() {
        state.theme = state.theme === 'dark' ? 'light' : 'dark';
        document.body.className = state.theme === 'light' ? 'light-theme' : '';
        document.getElementById('themeToggle').textContent = state.theme === 'dark' ? '🌙' : '☀️';
        localStorage.setItem('theme', state.theme);
        
        // Update chart theme
        if (state.chart) {
            const textColor = state.theme === 'dark' ? '#c9d1d9' : '#24292f';
            const gridColor = state.theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            
            state.chart.options.scales.x.grid.color = gridColor;
            state.chart.options.scales.x.ticks.color = textColor;
            state.chart.options.scales.y.grid.color = gridColor;
            state.chart.options.scales.y.ticks.color = textColor;
            state.chart.update();
            
            state.volumeChart.options.scales.y.grid.color = gridColor;
            state.volumeChart.options.scales.y.ticks.color = textColor;
            state.volumeChart.update();
        }
    }
    
    function handleTabSwitch(event) {
        const tab = event.target;
        if (!tab.classList.contains('tab')) return;
        
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Update content
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(tab.dataset.tab + 'Tab').classList.add('active');
        
        // Load analysis if switching to analysis tab
        if (tab.dataset.tab === 'analysis') {
            loadAnalysis();
        }
    }
    
    async function loadAnalysis() {
        const analysisContent = document.getElementById('analysisContent');
        
        if (state.candles.length === 0) {
            analysisContent.innerHTML = '<p>No data available for analysis</p>';
            return;
        }
        
        const closes = state.candles.map(c => c.close);
        const volumes = state.candles.map(c => c.volume);
        const lastClose = closes[closes.length - 1];
        const firstClose = closes[0];
        const priceChange = ((lastClose - firstClose) / firstClose) * 100;
        
        // Calculate statistics
        const avgPrice = closes.reduce((a, b) => a + b, 0) / closes.length;
        const maxPrice = Math.max(...closes);
        const minPrice = Math.min(...closes);
        const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
        const volatility = calculateVolatility(closes);
        
        // Trend analysis
        const trend = analyzeTrend(closes);
        const support = findSupportResistance(state.candles).support;
        const resistance = findSupportResistance(state.candles).resistance;
        
        analysisContent.innerHTML = `
            <div style="display: grid; gap: 1rem;">
                <div>
                    <h4>Price Analysis</h4>
                    <div style="display: grid; gap: 0.5rem; font-size: 0.875rem;">
                        <div>Current Price: ${formatNumber(lastClose, 2)}</div>
                        <div>Period Change: <span class="${priceChange >= 0 ? 'positive' : 'negative'}">${priceChange.toFixed(2)}%</span></div>
                        <div>Average Price: ${formatNumber(avgPrice, 2)}</div>
                        <div>Range: ${formatNumber(minPrice, 2)} - ${formatNumber(maxPrice, 2)}</div>
                        <div>Volatility: ${volatility.toFixed(2)}%</div>
                    </div>
                </div>
                
                <div>
                    <h4>Technical Analysis</h4>
                    <div style="display: grid; gap: 0.5rem; font-size: 0.875rem;">
                        <div>Trend: <span style="color: ${trend.direction === 'up' ? 'var(--accent-green)' : trend.direction === 'down' ? 'var(--accent-red)' : 'var(--accent-yellow)'}">${trend.description}</span></div>
                        <div>Support Level: ${formatNumber(support, 2)}</div>
                        <div>Resistance Level: ${formatNumber(resistance, 2)}</div>
                        <div>Trend Strength: ${trend.strength.toFixed(0)}%</div>
                    </div>
                </div>
                
                <div>
                    <h4>Volume Analysis</h4>
                    <div style="display: grid; gap: 0.5rem; font-size: 0.875rem;">
                        <div>Current Volume: ${formatNumber(volumes[volumes.length - 1], 0)}</div>
                        <div>Average Volume: ${formatNumber(avgVolume, 0)}</div>
                        <div>Volume Trend: ${analyzeVolumeTrend(volumes)}</div>
                    </div>
                </div>
                
                <div>
                    <h4>Market Sentiment</h4>
                    <div style="display: grid; gap: 0.5rem; font-size: 0.875rem;">
                        ${generateMarketSentiment()}
                    </div>
                </div>
            </div>
        `;
    }
    
    function calculateVolatility(prices) {
        const returns = [];
        for (let i = 1; i < prices.length; i++) {
            returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
        }
        
        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
        return Math.sqrt(variance) * 100;
    }
    
    function analyzeTrend(prices) {
        if (prices.length < 20) {
            return { direction: 'neutral', strength: 0, description: 'Insufficient data' };
        }
        
        const sma20 = TechnicalIndicators.SMA(prices, 20);
        const lastSMA = sma20[sma20.length - 1];
        const prevSMA = sma20[sma20.length - 10];
        const currentPrice = prices[prices.length - 1];
        
        const trendAngle = Math.atan2(lastSMA - prevSMA, 10) * 180 / Math.PI;
        const strength = Math.min(100, Math.abs(trendAngle) * 10);
        
        if (currentPrice > lastSMA && trendAngle > 5) {
            return { direction: 'up', strength, description: '📈 Strong Uptrend' };
        } else if (currentPrice > lastSMA && trendAngle > 0) {
            return { direction: 'up', strength, description: '📈 Uptrend' };
        } else if (currentPrice < lastSMA && trendAngle < -5) {
            return { direction: 'down', strength, description: '📉 Strong Downtrend' };
        } else if (currentPrice < lastSMA && trendAngle < 0) {
            return { direction: 'down', strength, description: '📉 Downtrend' };
        } else {
            return { direction: 'neutral', strength, description: '➡️ Sideways/Consolidation' };
        }
    }
    
    function findSupportResistance(candles) {
        const prices = candles.map(c => c.close);
        const highs = candles.map(c => c.high);
        const lows = candles.map(c => c.low);
        
        // Simple approach: use recent lows for support, highs for resistance
        const recentLows = lows.slice(-20);
        const recentHighs = highs.slice(-20);
        
        const support = Math.min(...recentLows);
        const resistance = Math.max(...recentHighs);
        
        return { support, resistance };
    }
    
    function analyzeVolumeTrend(volumes) {
        const recent = volumes.slice(-10);
        const previous = volumes.slice(-20, -10);
        
        const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
        const previousAvg = previous.reduce((a, b) => a + b, 0) / previous.length;
        
        const change = ((recentAvg - previousAvg) / previousAvg) * 100;
        
        if (change > 20) return '📊 Increasing significantly';
        if (change > 5) return '📊 Increasing';
        if (change < -20) return '📊 Decreasing significantly';
        if (change < -5) return '📊 Decreasing';
        return '📊 Stable';
    }
    
    function generateMarketSentiment() {
        if (!state.indicators.rsi || !state.indicators.macd) {
            return '<div>Calculating sentiment...</div>';
        }
        
        const rsi = state.indicators.rsi[state.indicators.rsi.length - 1];
        const macdHist = state.indicators.macd.histogram[state.indicators.macd.histogram.length - 1];
        
        let sentiment = 'Neutral';
        let score = 50;
        
        if (rsi < 30 && macdHist > 0) {
            sentiment = 'Strongly Bullish';
            score = 85;
        } else if (rsi < 40 || macdHist > 0) {
            sentiment = 'Bullish';
            score = 65;
        } else if (rsi > 70 && macdHist < 0) {
            sentiment = 'Strongly Bearish';
            score = 15;
        } else if (rsi > 60 || macdHist < 0) {
            sentiment = 'Bearish';
            score = 35;
        }
        
        return `
            <div>Overall Sentiment: <strong style="color: ${score > 60 ? 'var(--accent-green)' : score < 40 ? 'var(--accent-red)' : 'var(--accent-yellow)'}">${sentiment}</strong></div>
            <div>Sentiment Score: ${score}/100</div>
            <div>RSI Reading: ${rsi.toFixed(1)} ${rsi < 30 ? '(Oversold)' : rsi > 70 ? '(Overbought)' : ''}</div>
            <div>MACD Signal: ${macdHist > 0 ? '🟢 Bullish' : '🔴 Bearish'}</div>
        `;
    }
    
    function exportData() {
        const data = {
            version: '1.0',
            timestamp: Date.now(),
            settings: {
                theme: state.theme,
                symbol: state.symbol,
                interval: state.interval,
                indicators: Array.from(document.querySelectorAll('.indicator-toggle input:checked')).map(cb => cb.value),
                modelEpochs: document.getElementById('modelEpochs').value,
                sequenceLength: document.getElementById('sequenceLength').value,
                predictionHorizon: document.getElementById('predictionHorizon').value
            },
            paperTrading: state.paperTrading,
            alerts: state.alerts,
            modelWeights: state.model && state.modelTrained ? 'Model trained but weights export not implemented' : null
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `pta-export-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        showAlert('Data exported successfully', 'success');
    }
    
    function importData(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                
                // Restore settings
                if (data.settings) {
                    state.theme = data.settings.theme || 'dark';
                    state.symbol = data.settings.symbol || 'BTCUSDT';
                    state.interval = data.settings.interval || '15m';
                    
                    document.getElementById('symbolSelect').value = state.symbol;
                    document.getElementById('intervalSelect').value = state.interval;
                    document.getElementById('modelEpochs').value = data.settings.modelEpochs || 50;
                    document.getElementById('sequenceLength').value = data.settings.sequenceLength || 20;
                    document.getElementById('predictionHorizon').value = data.settings.predictionHorizon || '1';
                    
                    handleThemeToggle();
                    
                    // Restore indicators
                    if (data.settings.indicators) {
                        document.querySelectorAll('.indicator-toggle input').forEach(cb => {
                            cb.checked = data.settings.indicators.includes(cb.value);
                        });
                    }
                }
                
                // Restore paper trading
                if (data.paperTrading) {
                    state.paperTrading = data.paperTrading;
                    updatePaperTradingDisplay();
                }
                
                // Restore alerts
                if (data.alerts) {
                    state.alerts = data.alerts;
                    updateAlertsDisplay();
                }
                
                showAlert('Data imported successfully', 'success');
                
                // Reload market data
                loadMarketData();
                
            } catch (error) {
                console.error('Import error:', error);
                showAlert('Failed to import data', 'error');
            }
        };
        
        reader.readAsText(file);
    }
    
    async function takeSnapshot() {
        try {
            const canvas = document.getElementById('mainChart');
            const dataURL = canvas.toDataURL('image/png');
            
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = `chart-${state.symbol}-${Date.now()}.png`;
            a.click();
            
            showAlert('Chart snapshot saved', 'success');
        } catch (error) {
            console.error('Snapshot error:', error);
            showAlert('Failed to take snapshot', 'error');
        }
    }
    
    // ================================================================================
    // INITIALIZATION
    // ================================================================================
    
    async function loadMarketData() {
        try {
            console.log(`Loading market data for ${state.symbol} ${state.interval}`);
            
            // Show loading state
            document.getElementById('currentPrice').textContent = 'Loading...';
            
            // Fetch klines with smaller initial request
            const candles = await fetchKlines(state.symbol, state.interval, 100);
            
            if (!candles || candles.length === 0) {
                console.error('No candles received');
                document.getElementById('currentPrice').textContent = 'No data';
                
                // Show helpful message
                showAlert('Unable to fetch data. This is likely a CORS issue. Please install a CORS extension or check the console for details.', 'error');
                return;
            }
            
            state.candles = candles;
            console.log(`Loaded ${candles.length} candles`);
            
            // Calculate indicators
            if (candles.length >= 30) {
                calculateIndicators();
                generateSignals();
            }
            
            // Update displays
            updateChart();
            const lastCandle = candles[candles.length - 1];
            updatePriceDisplay(lastCandle.close);
            
            // Fetch 24hr stats separately
            try {
                const stats = await fetch24hrStats(state.symbol);
                if (stats) {
                    const priceChangePercent = parseFloat(stats.priceChangePercent);
                    const volume24h = parseFloat(stats.volume);
                    
                    const changeElement = document.getElementById('priceChange');
                    changeElement.textContent = `${priceChangePercent >= 0 ? '+' : ''}${priceChangePercent.toFixed(2)}%`;
                    changeElement.className = priceChangePercent >= 0 ? 'price-change positive' : 'price-change negative';
                    
                    document.getElementById('volume24h').textContent = formatNumber(volume24h / 1000000, 1) + 'M';
                }
            } catch (error) {
                console.error('Failed to fetch 24hr stats:', error);
                // Non-critical, continue
            }
            
            // Make prediction if model is trained
            if (state.modelTrained) {
                makePrediction();
            }
            
        } catch (error) {
            console.error('Error loading market data:', error);
            document.getElementById('currentPrice').textContent = 'Error';
            showAlert('Failed to load market data. Check console for details.', 'error');
        }
    }
    
    function initializeIndicatorsList() {
        const container = document.getElementById('indicatorsList');
        container.innerHTML = '';
        
        CONFIG.INDICATORS.forEach(indicator => {
            const div = document.createElement('div');
            div.className = 'indicator-toggle';
            div.innerHTML = `
                <input type="checkbox" id="ind_${indicator.replace(/\s/g, '_')}" value="${indicator}">
                <label for="ind_${indicator.replace(/\s/g, '_')}">${indicator}</label>
            `;
            container.appendChild(div);
        });
        
        // Add event listeners
        container.querySelectorAll('input').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                updateChart();
            });
        });
    }
    
    function setupEventListeners() {
        // Market controls
        document.getElementById('symbolSelect').addEventListener('change', handleSymbolChange);
        document.getElementById('intervalSelect').addEventListener('change', handleIntervalChange);
        document.getElementById('themeToggle').addEventListener('click', handleThemeToggle);
        
        // Settings
        document.getElementById('settingsBtn').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.add('active');
        });
        
        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.remove('active');
        });
        
        document.getElementById('saveSettingsBtn').addEventListener('click', () => {
            localStorage.setItem('pta_settings', JSON.stringify({
                useWebSocket: document.getElementById('useWebSocket').checked,
                cacheData: document.getElementById('cacheData').checked,
                candleHistory: document.getElementById('candleHistory').value,
                modelEpochs: document.getElementById('modelEpochs').value,
                sequenceLength: document.getElementById('sequenceLength').value,
                predictionHorizon: document.getElementById('predictionHorizon').value
            }));
            document.getElementById('settingsModal').classList.remove('active');
            showAlert('Settings saved', 'success');
        });
        
        // Export/Import
        document.getElementById('exportBtn').addEventListener('click', exportData);
        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('importFile').click();
        });
        document.getElementById('importFile').addEventListener('change', importData);
        
        // Tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', handleTabSwitch);
        });
        
        // Chart controls
        document.getElementById('snapshotBtn').addEventListener('click', takeSnapshot);
        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            const chartSection = document.querySelector('.chart-section');
            if (chartSection.requestFullscreen) {
                chartSection.requestFullscreen();
            }
        });
        
        // Indicators
        document.getElementById('toggleAllIndicators').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.indicator-toggle input');
            const anyChecked = Array.from(checkboxes).some(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !anyChecked);
            updateChart();
        });
        
        // ML Model
        document.getElementById('trainModelBtn').addEventListener('click', trainModel);
        
        // Paper Trading
        document.getElementById('buyBtn').addEventListener('click', () => executePaperTrade('buy'));
        document.getElementById('sellBtn').addEventListener('click', () => executePaperTrade('sell'));
        
        // Backtest
        document.getElementById('runBacktestBtn').addEventListener('click', runBacktest);
        
        // Alerts
        document.getElementById('addAlertBtn').addEventListener('click', addPriceAlert);
        document.getElementById('alertPrice').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addPriceAlert();
        });
        
        // Close modal on outside click
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') {
                document.getElementById('settingsModal').classList.remove('active');
            }
        });
        
        // WebSocket toggle
        document.getElementById('useWebSocket').addEventListener('change', (e) => {
            if (e.target.checked) {
                connectWebSocket(state.symbol, state.interval);
            } else {
                if (state.ws) {
                    state.ws.close();
                }
            }
        });
    }
    
    async function initialize() {
        console.log('Initializing Personal Trading Assistant...');
        
        // Show initialization message
        document.getElementById('currentPrice').textContent = 'Initializing...';
        showAlert('Loading market data... This may take a moment on first load.', 'info');
        
        // Set theme
        if (state.theme === 'light') {
            document.body.className = 'light-theme';
            document.getElementById('themeToggle').textContent = '☀️';
        }
        
        // Load saved settings
        const savedSettings = localStorage.getItem('pta_settings');
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                document.getElementById('useWebSocket').checked = settings.useWebSocket !== false;
                document.getElementById('cacheData').checked = settings.cacheData !== false;
                document.getElementById('candleHistory').value = settings.candleHistory || CONFIG.DEFAULT_CANDLES;
                document.getElementById('modelEpochs').value = settings.modelEpochs || 50;
                document.getElementById('sequenceLength').value = settings.sequenceLength || 20;
                document.getElementById('predictionHorizon').value = settings.predictionHorizon || '1';
            } catch (error) {
                console.error('Error loading settings:', error);
            }
        }
        
        // Initialize components
        initializeIndicatorsList();
        initializeCharts();
        setupEventListeners();
        
        // Test API connection first
        console.log('Testing API connection...');
        try {
            const testUrl = `${CONFIG.BINANCE_API}/api/v3/ping`;
            await fetchWithCORS(testUrl);
            console.log('API connection successful');
        } catch (error) {
            console.error('API connection test failed:', error);
            showAlert('Having trouble connecting to Binance API. Trying alternative methods...', 'warning');
        }
        
        // Load initial data
        console.log('Loading market data...');
        try {
            await loadMarketData();
            showAlert('Market data loaded successfully!', 'success');
        } catch (error) {
            console.error('Failed to load initial market data:', error);
            showAlert('Failed to load market data. Check console for details. You may need to use a CORS extension.', 'error');
            
            // Show manual instructions
            document.getElementById('currentPrice').innerHTML = `
                <div style="font-size: 0.8rem; color: var(--accent-yellow);">
                    CORS Issue Detected<br>
                    <a href="https://chrome.google.com/webstore/detail/cors-unblock/lfhmikememgdcahcdlaciloancbhjino" 
                       target="_blank" style="color: var(--accent-blue);">
                       Install CORS Extension
                    </a>
                </div>
            `;
        }
        
        // Connect WebSocket if enabled
        if (document.getElementById('useWebSocket').checked) {
            console.log('Connecting WebSocket...');
            connectWebSocket(state.symbol, state.interval);
        }
        
        // Set up auto-refresh with longer interval for GitHub Pages
        setInterval(async () => {
            if (!document.getElementById('useWebSocket').checked) {
                console.log('Auto-refreshing data...');
                try {
                    await loadMarketData();
                } catch (error) {
                    console.error('Auto-refresh failed:', error);
                }
            }
        }, 120000); // Refresh every 2 minutes
        
        console.log('Personal Trading Assistant initialized');
    }
    
    // Start the application
    document.addEventListener('DOMContentLoaded', initialize);
    
    // Export functions for global access (needed for inline onclick handlers)
    window.removeAlert = removeAlert;
    </script>
</body>
</html>
