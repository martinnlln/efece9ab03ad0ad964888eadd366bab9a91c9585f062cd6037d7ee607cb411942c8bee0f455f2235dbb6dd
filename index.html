<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIF Professional Analysis Terminal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0a0e1a;
            color: #fff;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #fff 0%, #64b5f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .panel {
            background: rgba(17, 25, 40, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .panel-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .price-display {
            font-size: 48px;
            font-weight: 700;
            margin: 20px 0;
            display: flex;
            align-items: baseline;
            gap: 15px;
        }

        .price-change {
            font-size: 24px;
            padding: 5px 15px;
            border-radius: 8px;
            font-weight: 600;
        }

        .price-up {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .price-down {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .indicator-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .indicator-card {
            background: rgba(30, 40, 60, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .indicator-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(100, 181, 246, 0.2);
            border-color: rgba(100, 181, 246, 0.3);
        }

        .indicator-name {
            font-size: 11px;
            color: #64b5f6;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .indicator-value {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .indicator-signal {
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 6px;
            display: inline-block;
            font-weight: 600;
        }

        .signal-buy {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .signal-sell {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .signal-neutral {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .trade-setup {
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.1) 0%, rgba(76, 175, 80, 0.05) 100%);
            border: 2px solid rgba(76, 175, 80, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .trade-setup.short {
            background: linear-gradient(135deg, rgba(211, 47, 47, 0.1) 0%, rgba(244, 67, 54, 0.05) 100%);
            border-color: rgba(244, 67, 54, 0.3);
        }

        .trade-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .trade-row:last-child {
            border-bottom: none;
        }

        .trade-label {
            color: #90a4ae;
            font-size: 14px;
        }

        .trade-value {
            font-size: 16px;
            font-weight: 600;
        }

        .confidence-meter {
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin: 15px 0;
            overflow: hidden;
            position: relative;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #f44336 0%, #ffc107 50%, #4caf50 100%);
            border-radius: 15px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
        }

        .confidence-text {
            color: #fff;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .analysis-text {
            background: rgba(30, 40, 60, 0.5);
            border-left: 4px solid #64b5f6;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            line-height: 1.6;
        }

        .alert-box {
            background: linear-gradient(135deg, rgba(255, 152, 0, 0.1) 0%, rgba(255, 193, 7, 0.05) 100%);
            border: 2px solid rgba(255, 193, 7, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .alert-icon {
            font-size: 32px;
        }

        .position-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .position-card {
            background: rgba(30, 40, 60, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
        }

        .position-type {
            font-size: 12px;
            color: #90a4ae;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .position-amount {
            font-size: 24px;
            font-weight: 700;
            color: #4caf50;
        }

        .leverage-badge {
            display: inline-block;
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            margin-top: 8px;
        }

        .risk-levels {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .risk-level {
            flex: 1;
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            opacity: 0.3;
            transition: all 0.3s ease;
        }

        .risk-level.active {
            opacity: 1;
            transform: scale(1.05);
        }

        .risk-low {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.3);
            color: #4caf50;
        }

        .risk-medium {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.3);
            color: #ffc107;
        }

        .risk-high {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.3);
            color: #f44336;
        }

        .risk-extreme {
            background: rgba(156, 39, 176, 0.2);
            border: 1px solid rgba(156, 39, 176, 0.3);
            color: #9c27b0;
        }

        .action-button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 15px;
        }

        .action-buy {
            background: linear-gradient(135deg, #2e7d32 0%, #4caf50 100%);
            color: white;
        }

        .action-sell {
            background: linear-gradient(135deg, #c62828 0%, #f44336 100%);
            color: white;
        }

        .action-wait {
            background: linear-gradient(135deg, #424242 0%, #616161 100%);
            color: white;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .timeframe-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tf-button {
            padding: 8px 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 40, 60, 0.5);
            color: #90a4ae;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tf-button.active {
            background: #64b5f6;
            color: white;
            border-color: #64b5f6;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #64b5f6;
        }

        .full-width {
            grid-column: span 2;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ WIF Professional Trading Analysis Terminal</h1>
    </div>

    <div class="container">
        <!-- Price Panel -->
        <div class="panel">
            <div class="panel-title">
                <span>üí∞</span>
                <span>LIVE PRICE & MARKET DATA</span>
            </div>
            <div class="price-display">
                <span id="currentPrice">$0.0000</span>
                <span id="priceChange" class="price-change">0.00%</span>
            </div>
            <div class="timeframe-selector">
                <button class="tf-button" data-tf="1m">1m</button>
                <button class="tf-button" data-tf="5m">5m</button>
                <button class="tf-button active" data-tf="15m">15m</button>
                <button class="tf-button" data-tf="1h">1h</button>
                <button class="tf-button" data-tf="4h">4h</button>
                <button class="tf-button" data-tf="1d">1D</button>
            </div>
            <div id="marketStats"></div>
        </div>

        <!-- Technical Indicators -->
        <div class="panel">
            <div class="panel-title">
                <span>üìä</span>
                <span>TECHNICAL INDICATORS</span>
            </div>
            <div class="indicator-grid" id="indicators"></div>
        </div>

        <!-- Trading Signal -->
        <div class="panel">
            <div class="panel-title">
                <span>üéØ</span>
                <span>TRADE SETUP</span>
            </div>
            <div id="tradeSetup"></div>
            <div class="confidence-meter">
                <div class="confidence-fill" id="confidenceFill">
                    <span class="confidence-text" id="confidenceText">0%</span>
                </div>
            </div>
            <button id="actionButton" class="action-button action-wait">ANALYZING...</button>
        </div>

        <!-- Position Sizing -->
        <div class="panel">
            <div class="panel-title">
                <span>üíé</span>
                <span>POSITION MANAGEMENT</span>
            </div>
            <div id="positionSizing"></div>
            <div class="risk-levels">
                <div class="risk-level risk-low" id="riskLow">LOW</div>
                <div class="risk-level risk-medium" id="riskMedium">MEDIUM</div>
                <div class="risk-level risk-high" id="riskHigh">HIGH</div>
                <div class="risk-level risk-extreme" id="riskExtreme">EXTREME</div>
            </div>
        </div>

        <!-- AI Analysis -->
        <div class="panel full-width">
            <div class="panel-title">
                <span>üß†</span>
                <span>AI MARKET ANALYSIS</span>
            </div>
            <div id="aiAnalysis"></div>
        </div>

        <!-- Multi-Timeframe Analysis -->
        <div class="panel full-width">
            <div class="panel-title">
                <span>‚è∞</span>
                <span>MULTI-TIMEFRAME CONFLUENCE</span>
            </div>
            <div id="mtfAnalysis"></div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            capital: 30000,
            spotAllocation: 0.40,
            leverageAllocation: 0.35,
            maxLeverage: 5,
            apiEndpoint: 'wss://stream.binance.com:9443/ws/wifusdt@kline_15m',
            updateInterval: 5000,
            
            // Key Levels
            levels: {
                ath: 4.85,
                resistance: [4.85, 3.50, 2.92, 2.49, 2.00, 1.30],
                support: [0.25, 0.35, 0.44, 0.55, 0.85, 0.93],
                fib: {
                    '0.236': 1.51,
                    '0.382': 0.93,
                    '0.5': 2.92,
                    '0.618': 2.49,
                    '0.786': 3.85
                }
            },
            
            // Zone definitions
            zones: {
                blood: { low: 0.25, high: 0.35, name: 'Blood Zone', color: '#ff1744' },
                strong: { low: 0.36, high: 0.44, name: 'Strong Buy Zone', color: '#ff6d00' },
                leverage: { low: 0.42, high: 0.55, name: 'Leverage Zone', color: '#ffd600' },
                accumulation: { low: 0.56, high: 0.85, name: 'Accumulation', color: '#4caf50' },
                distribution: { low: 2.00, high: 3.50, name: 'Distribution', color: '#ff9800' },
                fomo: { low: 3.50, high: 4.85, name: 'FOMO Zone', color: '#f44336' }
            }
        };

        // Market Data Storage
        let marketData = {
            price: 0,
            change24h: 0,
            volume: 0,
            high24h: 0,
            low24h: 0,
            candles: [],
            indicators: {},
            signal: null,
            confidence: 0,
            timeframe: '15m'
        };

        // Technical Indicators Calculator
        class TechnicalAnalysis {
            static calculateRSI(prices, period = 14) {
                if (prices.length < period + 1) return 50;
                
                let gains = 0;
                let losses = 0;
                
                for (let i = 1; i <= period; i++) {
                    const diff = prices[i] - prices[i - 1];
                    if (diff > 0) gains += diff;
                    else losses -= diff;
                }
                
                const avgGain = gains / period;
                const avgLoss = losses / period;
                
                if (avgLoss === 0) return 100;
                
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }

            static calculateMACD(prices, fast = 12, slow = 26, signal = 9) {
                if (prices.length < slow) return { macd: 0, signal: 0, histogram: 0 };
                
                const emaFast = this.calculateEMA(prices, fast);
                const emaSlow = this.calculateEMA(prices, slow);
                const macdLine = emaFast - emaSlow;
                
                return {
                    macd: macdLine,
                    signal: 0, // Simplified
                    histogram: macdLine,
                    trend: macdLine > 0 ? 'BULLISH' : 'BEARISH'
                };
            }

            static calculateEMA(prices, period) {
                if (prices.length === 0) return 0;
                const multiplier = 2 / (period + 1);
                let ema = prices[0];
                
                for (let i = 1; i < prices.length; i++) {
                    ema = (prices[i] - ema) * multiplier + ema;
                }
                
                return ema;
            }

            static calculateBollingerBands(prices, period = 20, multiplier = 2) {
                if (prices.length < period) return { upper: 0, middle: 0, lower: 0 };
                
                const sma = prices.slice(-period).reduce((a, b) => a + b) / period;
                const variance = prices.slice(-period).reduce((sum, price) => {
                    return sum + Math.pow(price - sma, 2);
                }, 0) / period;
                const stdDev = Math.sqrt(variance);
                
                return {
                    upper: sma + (stdDev * multiplier),
                    middle: sma,
                    lower: sma - (stdDev * multiplier),
                    position: prices[prices.length - 1] < sma ? 'BELOW' : 'ABOVE'
                };
            }

            static calculateStochastic(high, low, close, period = 14) {
                if (high.length < period) return { k: 50, d: 50 };
                
                const recentHigh = Math.max(...high.slice(-period));
                const recentLow = Math.min(...low.slice(-period));
                
                const k = ((close[close.length - 1] - recentLow) / (recentHigh - recentLow)) * 100;
                
                return {
                    k: k || 50,
                    d: k || 50, // Simplified
                    signal: k > 80 ? 'OVERBOUGHT' : k < 20 ? 'OVERSOLD' : 'NEUTRAL'
                };
            }

            static calculateATR(high, low, close, period = 14) {
                if (high.length < period) return 0;
                
                let tr = [];
                for (let i = 1; i < high.length; i++) {
                    const highLow = high[i] - low[i];
                    const highClose = Math.abs(high[i] - close[i - 1]);
                    const lowClose = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(highLow, highClose, lowClose));
                }
                
                return tr.slice(-period).reduce((a, b) => a + b) / period;
            }

            static calculateVWAP(high, low, close, volume) {
                if (high.length === 0) return 0;
                
                let cumVolume = 0;
                let cumPV = 0;
                
                for (let i = 0; i < high.length; i++) {
                    const typicalPrice = (high[i] + low[i] + close[i]) / 3;
                    cumPV += typicalPrice * volume[i];
                    cumVolume += volume[i];
                }
                
                return cumVolume > 0 ? cumPV / cumVolume : 0;
            }

            static calculateOBV(close, volume) {
                if (close.length < 2) return 0;
                
                let obv = 0;
                for (let i = 1; i < close.length; i++) {
                    if (close[i] > close[i - 1]) {
                        obv += volume[i];
                    } else if (close[i] < close[i - 1]) {
                        obv -= volume[i];
                    }
                }
                
                return obv;
            }

            static detectPatterns(candles) {
                if (candles.length < 3) return 'No Pattern';
                
                const recent = candles.slice(-3);
                const [prev2, prev, current] = recent;
                
                // Bullish Patterns
                if (current.close > current.open && 
                    prev.close < prev.open && 
                    current.close > prev.open) {
                    return 'Bullish Engulfing';
                }
                
                if (current.close > current.open && 
                    current.open < prev.close && 
                    current.close > prev.open) {
                    return 'Morning Star';
                }
                
                // Bearish Patterns
                if (current.close < current.open && 
                    prev.close > prev.open && 
                    current.close < prev.open) {
                    return 'Bearish Engulfing';
                }
                
                // Doji
                if (Math.abs(current.close - current.open) / current.open < 0.001) {
                    return 'Doji - Indecision';
                }
                
                return 'No Clear Pattern';
            }
        }

        // Signal Generator
        class SignalGenerator {
            static generateSignal(data, indicators) {
                const price = data.price;
                const rsi = indicators.rsi;
                const macd = indicators.macd;
                const bb = indicators.bb;
                const stoch = indicators.stoch;
                
                let bullScore = 0;
                let bearScore = 0;
                let signals = [];
                
                // Zone Analysis
                const currentZone = this.getCurrentZone(price);
                if (currentZone) {
                    if (currentZone.name === 'Blood Zone') {
                        bullScore += 30;
                        signals.push('ü©∏ MAXIMUM FEAR DETECTED');
                    } else if (currentZone.name === 'Strong Buy Zone') {
                        bullScore += 25;
                        signals.push('üí™ STRONG BUY ZONE');
                    } else if (currentZone.name === 'FOMO Zone') {
                        bearScore += 20;
                        signals.push('‚ö†Ô∏è FOMO ZONE - CAUTION');
                    }
                }
                
                // RSI Analysis
                if (rsi < 30) {
                    bullScore += 25;
                    signals.push('üü¢ RSI OVERSOLD');
                } else if (rsi > 70) {
                    bearScore += 25;
                    signals.push('üî¥ RSI OVERBOUGHT');
                }
                
                // MACD Analysis
                if (macd.trend === 'BULLISH') {
                    bullScore += 20;
                    signals.push('üìà MACD BULLISH');
                } else {
                    bearScore += 15;
                    signals.push('üìâ MACD BEARISH');
                }
                
                // Bollinger Bands
                if (price < bb.lower) {
                    bullScore += 20;
                    signals.push('üíé BELOW BOLLINGER LOWER');
                } else if (price > bb.upper) {
                    bearScore += 20;
                    signals.push('üî• ABOVE BOLLINGER UPPER');
                }
                
                // Stochastic
                if (stoch.signal === 'OVERSOLD') {
                    bullScore += 15;
                    signals.push('üéØ STOCH OVERSOLD');
                } else if (stoch.signal === 'OVERBOUGHT') {
                    bearScore += 15;
                    signals.push('‚ö° STOCH OVERBOUGHT');
                }
                
                // Volume Analysis
                const volRatio = data.volume / (indicators.volAvg || 1);
                if (volRatio > 1.5) {
                    signals.push('üöÄ HIGH VOLUME');
                    if (bullScore > bearScore) bullScore += 10;
                    else bearScore += 10;
                }
                
                // Pattern Recognition
                if (indicators.pattern && indicators.pattern.includes('Bullish')) {
                    bullScore += 15;
                    signals.push(`üïØÔ∏è ${indicators.pattern}`);
                } else if (indicators.pattern && indicators.pattern.includes('Bearish')) {
                    bearScore += 15;
                    signals.push(`üïØÔ∏è ${indicators.pattern}`);
                }
                
                // Support/Resistance
                const nearSupport = this.getNearestSupport(price);
                const nearResistance = this.getNearestResistance(price);
                
                if (Math.abs(price - nearSupport) / price < 0.03) {
                    bullScore += 15;
                    signals.push(`üìç NEAR SUPPORT $${nearSupport.toFixed(3)}`);
                }
                
                if (Math.abs(price - nearResistance) / price < 0.03) {
                    bearScore += 10;
                    signals.push(`üìç NEAR RESISTANCE $${nearResistance.toFixed(3)}`);
                }
                
                // Final Signal
                const confidence = Math.abs(bullScore - bearScore);
                let signal = 'WAIT';
                let action = 'WAIT';
                
                if (bullScore > bearScore && bullScore >= 50) {
                    signal = 'LONG';
                    if (bullScore >= 80) {
                        action = 'STRONG BUY';
                    } else if (bullScore >= 60) {
                        action = 'BUY';
                    } else {
                        action = 'SCALE IN';
                    }
                } else if (bearScore > bullScore && bearScore >= 50) {
                    signal = 'SHORT';
                    if (bearScore >= 80) {
                        action = 'STRONG SELL';
                    } else if (bearScore >= 60) {
                        action = 'SELL';
                    } else {
                        action = 'REDUCE';
                    }
                }
                
                return {
                    signal,
                    action,
                    bullScore,
                    bearScore,
                    confidence: Math.min(confidence, 100),
                    signals,
                    zone: currentZone,
                    nearSupport,
                    nearResistance
                };
            }
            
            static getCurrentZone(price) {
                for (const [key, zone] of Object.entries(CONFIG.zones)) {
                    if (price >= zone.low && price <= zone.high) {
                        return zone;
                    }
                }
                return null;
            }
            
            static getNearestSupport(price) {
                const supports = CONFIG.levels.support.filter(s => s < price);
                return supports.length > 0 ? Math.max(...supports) : CONFIG.levels.support[0];
            }
            
            static getNearestResistance(price) {
                const resistances = CONFIG.levels.resistance.filter(r => r > price);
                return resistances.length > 0 ? Math.min(...resistances) : CONFIG.levels.resistance[CONFIG.levels.resistance.length - 1];
            }
        }

        // Position Calculator
        class PositionCalculator {
            static calculate(price, signal, confidence) {
                const spotCapital = CONFIG.capital * CONFIG.spotAllocation;
                const levCapital = CONFIG.capital * CONFIG.leverageAllocation;
                
                let spotSize = 0;
                let levSize = 0;
                let leverage = 1;
                let stopLoss = 0;
                let takeProfit = [];
                
                if (signal.signal === 'LONG') {
                    // Calculate position sizes based on zone and confidence
                    if (signal.zone && signal.zone.name === 'Blood Zone') {
                        spotSize = spotCapital * 0.60; // Deploy 60% of spot
                        leverage = 0; // No leverage in extreme fear
                    } else if (signal.zone && signal.zone.name === 'Strong Buy Zone') {
                        spotSize = spotCapital * 0.40; // 40% spot
                        leverage = 0; // Still no leverage
                    } else if (signal.zone && signal.zone.name === 'Leverage Zone') {
                        spotSize = spotCapital * 0.20; // 20% spot
                        levSize = levCapital * 0.35; // 35% of leverage capital
                        leverage = price < 0.50 ? 3 : price < 0.60 ? 3 : 5;
                    } else {
                        // Normal conditions
                        const confidenceRatio = confidence / 100;
                        spotSize = spotCapital * 0.15 * confidenceRatio;
                        
                        if (confidence >= 70) {
                            levSize = levCapital * 0.25 * confidenceRatio;
                            leverage = Math.min(3 + Math.floor((confidence - 70) / 10), CONFIG.maxLeverage);
                        }
                    }
                    
                    // Stop Loss Calculation
                    const atrStop = 0.10; // 10% for spot
                    stopLoss = price * (1 - (leverage > 1 ? atrStop / leverage : atrStop));
                    
                    // Take Profit Levels
                    takeProfit = [
                        { level: price * 1.15, percent: 25, name: 'TP1' },
                        { level: price * 1.35, percent: 25, name: 'TP2' },
                        { level: price * 1.60, percent: 25, name: 'TP3' },
                        { level: price * 2.00, percent: 25, name: 'TP4' }
                    ];
                    
                    // Adjust TPs based on resistance levels
                    const nextResistance = signal.nearResistance;
                    if (nextResistance && nextResistance < takeProfit[0].level) {
                        takeProfit[0].level = nextResistance * 0.98;
                    }
                }
                
                return {
                    spotSize,
                    levSize,
                    leverage,
                    totalPosition: spotSize + (levSize * leverage),
                    stopLoss,
                    takeProfit,
                    riskAmount: (spotSize + levSize) * 0.10,
                    tokens: {
                        spot: spotSize / price,
                        leveraged: (levSize * leverage) / price,
                        total: (spotSize / price) + ((levSize * leverage) / price)
                    }
                };
            }
        }

        // Multi-Timeframe Analysis
        class MultiTimeframeAnalysis {
            static analyze() {
                // Simulated MTF analysis (in real implementation, fetch multiple timeframes)
                const timeframes = ['1m', '5m', '15m', '1h', '4h', '1D'];
                const mtfSignals = [];
                
                timeframes.forEach(tf => {
                    // Simulate different timeframe signals
                    const random = Math.random();
                    let signal = 'NEUTRAL';
                    let strength = Math.floor(Math.random() * 100);
                    
                    if (random < 0.4) signal = 'BULLISH';
                    else if (random > 0.6) signal = 'BEARISH';
                    
                    mtfSignals.push({
                        timeframe: tf,
                        signal,
                        strength,
                        trend: signal
                    });
                });
                
                // Calculate confluence
                const bullishCount = mtfSignals.filter(s => s.signal === 'BULLISH').length;
                const bearishCount = mtfSignals.filter(s => s.signal === 'BEARISH').length;
                
                let confluence = 'MIXED';
                if (bullishCount >= 4) confluence = 'STRONG BULLISH';
                else if (bearishCount >= 4) confluence = 'STRONG BEARISH';
                else if (bullishCount >= 3) confluence = 'BULLISH';
                else if (bearishCount >= 3) confluence = 'BEARISH';
                
                return {
                    signals: mtfSignals,
                    confluence,
                    strength: Math.max(bullishCount, bearishCount) / timeframes.length * 100
                };
            }
        }

        // UI Updater
        class UIManager {
            static updatePrice(price, change) {
                document.getElementById('currentPrice').textContent = `$${price.toFixed(4)}`;
                const changeEl = document.getElementById('priceChange');
                changeEl.textContent = `${change > 0 ? '+' : ''}${change.toFixed(2)}%`;
                changeEl.className = `price-change ${change >= 0 ? 'price-up' : 'price-down'}`;
            }
            
            static updateIndicators(indicators) {
                const container = document.getElementById('indicators');
                container.innerHTML = '';
                
                const indicatorData = [
                    {
                        name: 'RSI',
                        value: indicators.rsi?.toFixed(1) || '50.0',
                        signal: indicators.rsi < 30 ? 'BUY' : indicators.rsi > 70 ? 'SELL' : 'NEUTRAL'
                    },
                    {
                        name: 'MACD',
                        value: indicators.macd?.trend || 'NEUTRAL',
                        signal: indicators.macd?.trend === 'BULLISH' ? 'BUY' : 'SELL'
                    },
                    {
                        name: 'Stochastic',
                        value: indicators.stoch?.k?.toFixed(1) || '50.0',
                        signal: indicators.stoch?.signal === 'OVERSOLD' ? 'BUY' : 
                                indicators.stoch?.signal === 'OVERBOUGHT' ? 'SELL' : 'NEUTRAL'
                    },
                    {
                        name: 'Bollinger',
                        value: indicators.bb?.position || 'MIDDLE',
                        signal: indicators.bb?.position === 'BELOW' ? 'BUY' : 
                               indicators.bb?.position === 'ABOVE' ? 'SELL' : 'NEUTRAL'
                    },
                    {
                        name: 'Volume',
                        value: `${indicators.volRatio?.toFixed(2) || '1.00'}x`,
                        signal: indicators.volRatio > 1.5 ? 'HIGH' : 
                               indicators.volRatio < 0.5 ? 'LOW' : 'NORMAL'
                    },
                    {
                        name: 'Pattern',
                        value: indicators.pattern || 'None',
                        signal: indicators.pattern?.includes('Bullish') ? 'BUY' : 
                               indicators.pattern?.includes('Bearish') ? 'SELL' : 'NEUTRAL'
                    }
                ];
                
                indicatorData.forEach(ind => {
                    const card = document.createElement('div');
                    card.className = 'indicator-card';
                    card.innerHTML = `
                        <div class="indicator-name">${ind.name}</div>
                        <div class="indicator-value">${ind.value}</div>
                        <div class="indicator-signal signal-${ind.signal.toLowerCase().replace(' ', '-')}">${ind.signal}</div>
                    `;
                    container.appendChild(card);
                });
            }
            
            static updateTradeSetup(signal, position) {
                const container = document.getElementById('tradeSetup');
                
                if (signal.signal === 'WAIT') {
                    container.innerHTML = `
                        <div class="alert-box">
                            <div class="alert-icon">‚è∏Ô∏è</div>
                            <div>
                                <strong>WAIT FOR BETTER SETUP</strong><br>
                                No high-conviction trade opportunity at current levels.
                                Watch support at $${signal.nearSupport?.toFixed(3) || '0.000'}
                            </div>
                        </div>
                    `;
                } else {
                    const isLong = signal.signal === 'LONG';
                    container.innerHTML = `
                        <div class="trade-setup ${isLong ? '' : 'short'}">
                            <div class="trade-row">
                                <span class="trade-label">Direction</span>
                                <span class="trade-value">${isLong ? 'üü¢ LONG' : 'üî¥ SHORT'}</span>
                            </div>
                            <div class="trade-row">
                                <span class="trade-label">Entry Zone</span>
                                <span class="trade-value">$${marketData.price.toFixed(4)}</span>
                            </div>
                            <div class="trade-row">
                                <span class="trade-label">Stop Loss</span>
                                <span class="trade-value">$${position.stopLoss.toFixed(4)}</span>
                            </div>
                            <div class="trade-row">
                                <span class="trade-label">Take Profit 1</span>
                                <span class="trade-value">$${position.takeProfit[0]?.level.toFixed(4) || '0.0000'}</span>
                            </div>
                            <div class="trade-row">
                                <span class="trade-label">Risk/Reward</span>
                                <span class="trade-value">1:${((position.takeProfit[0]?.level - marketData.price) / (marketData.price - position.stopLoss)).toFixed(1)}</span>
                            </div>
                        </div>
                    `;
                }
                
                // Update confidence meter
                document.getElementById('confidenceFill').style.width = `${signal.confidence}%`;
                document.getElementById('confidenceText').textContent = `${signal.confidence}%`;
                
                // Update action button
                const button = document.getElementById('actionButton');
                if (signal.signal === 'LONG') {
                    button.className = 'action-button action-buy pulse';
                    button.textContent = signal.action;
                } else if (signal.signal === 'SHORT') {
                    button.className = 'action-button action-sell';
                    button.textContent = signal.action;
                } else {
                    button.className = 'action-button action-wait';
                    button.textContent = 'WAIT FOR SETUP';
                }
            }
            
            static updatePosition(position, signal) {
                const container = document.getElementById('positionSizing');
                
                if (signal.signal === 'WAIT') {
                    container.innerHTML = `
                        <div class="analysis-text">
                            üí° <strong>No position recommended</strong><br>
                            Capital ready: $${CONFIG.capital.toLocaleString()}<br>
                            Waiting for optimal entry conditions...
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="position-grid">
                            <div class="position-card">
                                <div class="position-type">Spot Position</div>
                                <div class="position-amount">$${position.spotSize.toFixed(0)}</div>
                                <div>${(position.tokens.spot).toFixed(2)} WIF</div>
                            </div>
                            <div class="position-card">
                                <div class="position-type">Leverage Position</div>
                                <div class="position-amount">$${(position.levSize * position.leverage).toFixed(0)}</div>
                                <div class="leverage-badge">${position.leverage}x LEVERAGE</div>
                                <div>${(position.tokens.leveraged).toFixed(2)} WIF</div>
                            </div>
                        </div>
                        <div class="analysis-text" style="margin-top: 15px;">
                            üìä <strong>Position Summary</strong><br>
                            Total Exposure: $${position.totalPosition.toFixed(0)}<br>
                            Risk Amount: $${position.riskAmount.toFixed(0)}<br>
                            Total Tokens: ${position.tokens.total.toFixed(2)} WIF
                        </div>
                    `;
                }
                
                // Update risk levels
                document.querySelectorAll('.risk-level').forEach(el => el.classList.remove('active'));
                if (signal.confidence >= 80) {
                    document.getElementById('riskExtreme').classList.add('active');
                } else if (signal.confidence >= 60) {
                    document.getElementById('riskHigh').classList.add('active');
                } else if (signal.confidence >= 40) {
                    document.getElementById('riskMedium').classList.add('active');
                } else {
                    document.getElementById('riskLow').classList.add('active');
                }
            }
            
            static updateAIAnalysis(signal, mtf) {
                const container = document.getElementById('aiAnalysis');
                
                let analysis = `<div class="analysis-text">`;
                
                // Market Context
                analysis += `<strong>üìç Market Context:</strong><br>`;
                if (signal.zone) {
                    analysis += `Currently in ${signal.zone.name} (${signal.zone.low} - ${signal.zone.high})<br>`;
                }
                analysis += `Next Support: $${signal.nearSupport?.toFixed(3) || 'N/A'} | `;
                analysis += `Next Resistance: $${signal.nearResistance?.toFixed(3) || 'N/A'}<br><br>`;
                
                // Signal Analysis
                analysis += `<strong>üéØ Signal Analysis:</strong><br>`;
                signal.signals.forEach(s => {
                    analysis += `${s}<br>`;
                });
                analysis += `<br>`;
                
                // Multi-Timeframe
                analysis += `<strong>‚è∞ Timeframe Confluence:</strong> ${mtf.confluence} (${mtf.strength.toFixed(0)}% strength)<br><br>`;
                
                // Recommendation
                analysis += `<strong>üí° Recommendation:</strong><br>`;
                if (signal.signal === 'LONG') {
                    analysis += `Strong buy signal detected. `;
                    if (signal.zone && signal.zone.name === 'Blood Zone') {
                        analysis += `MAXIMUM OPPORTUNITY - Deploy heavy spot position. This is peak fear territory. `;
                    } else if (signal.confidence >= 70) {
                        analysis += `High conviction setup. Consider using leverage with tight risk management. `;
                    } else {
                        analysis += `Moderate setup. Start with small position and scale in on dips. `;
                    }
                } else if (signal.signal === 'SHORT') {
                    analysis += `Warning signals present. Consider reducing exposure or taking profits. `;
                } else {
                    analysis += `Market conditions unclear. Patience is key. Wait for better risk/reward setup. `;
                }
                
                analysis += `</div>`;
                container.innerHTML = analysis;
            }
            
            static updateMTFAnalysis(mtf) {
                const container = document.getElementById('mtfAnalysis');
                
                let html = '<div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px;">';
                
                mtf.signals.forEach(signal => {
                    const color = signal.signal === 'BULLISH' ? '#4caf50' : 
                                 signal.signal === 'BEARISH' ? '#f44336' : '#ffc107';
                    
                    html += `
                        <div style="text-align: center; padding: 10px; background: rgba(30, 40, 60, 0.5); border-radius: 8px; border: 1px solid ${color}40;">
                            <div style="font-size: 12px; color: #90a4ae; margin-bottom: 5px;">${signal.timeframe}</div>
                            <div style="font-size: 14px; color: ${color}; font-weight: 600;">${signal.signal}</div>
                            <div style="font-size: 11px; color: #64b5f6;">${signal.strength}%</div>
                        </div>
                    `;
                });
                
                html += '</div>';
                html += `
                    <div class="analysis-text" style="margin-top: 15px; text-align: center;">
                        <strong>Overall Confluence:</strong> ${mtf.confluence} (${mtf.strength.toFixed(0)}% alignment)
                    </div>
                `;
                
                container.innerHTML = html;
            }
        }

        // Main Analysis Loop
        function analyzeMarket() {
            // Simulate market data (replace with real API)
            marketData.price = 2.45 + (Math.random() - 0.5) * 0.1;
            marketData.change24h = (Math.random() - 0.5) * 20;
            marketData.volume = 1000000 + Math.random() * 500000;
            
            // Generate candles (simulated)
            const candles = [];
            for (let i = 0; i < 50; i++) {
                const open = marketData.price + (Math.random() - 0.5) * 0.05;
                const close = open + (Math.random() - 0.5) * 0.03;
                candles.push({
                    open,
                    high: Math.max(open, close) + Math.random() * 0.02,
                    low: Math.min(open, close) - Math.random() * 0.02,
                    close,
                    volume: Math.random() * 100000
                });
            }
            marketData.candles = candles;
            
            // Calculate indicators
            const prices = candles.map(c => c.close);
            const highs = candles.map(c => c.high);
            const lows = candles.map(c => c.low);
            const volumes = candles.map(c => c.volume);
            
            marketData.indicators = {
                rsi: TechnicalAnalysis.calculateRSI(prices),
                macd: TechnicalAnalysis.calculateMACD(prices),
                bb: TechnicalAnalysis.calculateBollingerBands(prices),
                stoch: TechnicalAnalysis.calculateStochastic(highs, lows, prices),
                atr: TechnicalAnalysis.calculateATR(highs, lows, prices),
                vwap: TechnicalAnalysis.calculateVWAP(highs, lows, prices, volumes),
                obv: TechnicalAnalysis.calculateOBV(prices, volumes),
                pattern: TechnicalAnalysis.detectPatterns(candles),
                ema20: TechnicalAnalysis.calculateEMA(prices, 20),
                ema50: TechnicalAnalysis.calculateEMA(prices, 50),
                volAvg: volumes.reduce((a, b) => a + b) / volumes.length,
                volRatio: volumes[volumes.length - 1] / (volumes.reduce((a, b) => a + b) / volumes.length)
            };
            
            // Generate signals
            const signal = SignalGenerator.generateSignal(marketData, marketData.indicators);
            marketData.signal = signal;
            
            // Calculate position
            const position = PositionCalculator.calculate(marketData.price, signal, signal.confidence);
            
            // Multi-timeframe analysis
            const mtf = MultiTimeframeAnalysis.analyze();
            
            // Update UI
            UIManager.updatePrice(marketData.price, marketData.change24h);
            UIManager.updateIndicators(marketData.indicators);
            UIManager.updateTradeSetup(signal, position);
            UIManager.updatePosition(position, signal);
            UIManager.updateAIAnalysis(signal, mtf);
            UIManager.updateMTFAnalysis(mtf);
        }

        // Timeframe selector
        document.querySelectorAll('.tf-button').forEach(button => {
            button.addEventListener('click', (e) => {
                document.querySelectorAll('.tf-button').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                marketData.timeframe = e.target.dataset.tf;
                analyzeMarket();
            });
        });

        // Initialize
        analyzeMarket();
        setInterval(analyzeMarket, CONFIG.updateInterval);

        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                analyzeMarket();
            }
        });
    </script>
</body>
</html>
