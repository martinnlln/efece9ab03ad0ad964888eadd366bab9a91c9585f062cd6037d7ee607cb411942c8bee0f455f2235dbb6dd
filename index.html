<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Personal Trading Assistant</title>
    <!-- README -->
    <!--
    Personal Trading Assistant (PTA)
    --------------------------------
    This is a self-contained browser-based trading assistant using Binance public data.
    
    How to run locally:
    - Save as index.html
    - Run: python -m http.server 8000
    - Open http://localhost:8000
    
    CORS issues:
    - Binance API may block direct browser requests due to CORS.
    - Solution: Use a proxy. Example Express.js proxy (install express, node-fetch):
      const express = require('express');
      const fetch = require('node-fetch');
      const app = express();
      app.use((req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*');
        next();
      });
      app.get('/proxy/*', async (req, res) => {
        const url = 'https://api.binance.com' + req.url.replace('/proxy', '');
        try {
          const response = await fetch(url);
          const data = await response.json();
          res.json(data);
        } catch (e) {
          res.status(500).send(e.message);
        }
      });
      app.listen(3000);
    - Then in code, replace 'https://api.binance.com' with 'http://localhost:3000/proxy'
    
    For private API/trading:
    - Do not store keys in client. Use server proxy with dotenv for keys.
    - Example: add headers with API key in proxy.
    
    Binance rate limits: 1200/min. Be polite.
    
    Warnings: Not financial advice. Models are demo. No real trading.
    
    Debug: Set debug=true in JS for sim data.
    -->
    <style>
        :root {
            --bg: #fff;
            --text: #000;
            --accent: #007bff;
        }
        .dark {
            --bg: #222;
            --text: #fff;
            --accent: #0d6efd;
        }
        body {
            background: var(--bg);
            color: var(--text);
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #chart {
            height: 400px;
        }
        #sidebar {
            width: 300px;
            padding: 10px;
        }
        #main {
            display: flex;
            flex: 1;
        }
        @media (max-width: 600px) {
            #main {
                flex-direction: column;
            }
            #sidebar {
                width: auto;
            }
        }
        button, select {
            background: var(--accent);
            color: white;
            border: none;
            padding: 5px;
            cursor: pointer;
        }
        .tooltip {
            position: relative;
        }
        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            background: #333;
            color: #fff;
            padding: 5px;
            border-radius: 5px;
            white-space: nowrap;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/technicalindicators@3.0.0/dist/browser.esm.js"></script>
</head>
<body>
    <div id="top-bar">
        <select id="symbol"></select>
        <select id="interval">
            <option value="1m">1m</option>
            <option value="5m">5m</option>
            <option value="15m">15m</option>
            <option value="1h">1h</option>
            <option value="4h">4h</option>
            <option value="1d">1d</option>
        </select>
        <div id="price">Price: --</div>
        <div id="change">Change: --</div>
        <div id="volume">Volume: --</div>
        <button id="theme">Dark</button>
        <button id="easy">Easy</button>
    </div>
    <div id="main">
        <div id="chart"></div>
        <div id="sidebar">
            <h3>Indicators</h3>
            <div id="ind-toggles"></div>
            <h3>Signals</h3>
            <div id="signals"></div>
            <h3>Prediction</h3>
            <button id="train">Train Model</button>
            <button id="predict">Predict</button>
            <div id="pred-out"></div>
            <h3>Backtest</h3>
            <button id="backtest">Run</button>
            <div id="bt-out"></div>
            <h3>Paper Trade</h3>
            <div id="pt-ledger"></div>
            <button id="buy-sim">Buy</button>
            <button id="sell-sim">Sell</button>
            <h3>Alerts</h3>
            <input id="alert-price" placeholder="Price alert">
            <button id="set-alert">Set</button>
            <h3>Export/Import</h3>
            <button id="export">Export</button>
            <input type="file" id="import">
        </div>
    </div>
    <div id="tutorial" style="position:fixed;top:0;left:0;background:rgba(0,0,0,0.5);color:white;padding:20px;display:none;">
        Welcome! Select symbol, interval. Toggle indicators. Train/predict model. Simulate trades.
        <button onclick="this.parentElement.style.display='none'">Close</button>
    </div>
    <script>
        const TI = technicalindicators;
        const symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'WIFUSDT', 'AVAXUSDT', 'BRETTUSDT', 'PYTHUSDT', 'ADAUSDT', 'LINKUSDT']; // FARCOIN not found, fallback in fetch
        const intervals = ['1m','5m','15m','1h','4h','1d'];
        const indicators = ['SMA5','SMA10','SMA20','SMA50','SMA100','SMA200','EMA','WMA','HMA','MACD','RSI','Stoch','BB','ATR','OBV','VWAP','Ichimoku','ADX','CCI','Supertrend','Keltner','EMARibbon','HA','Pivot','VP'];
        let chart, data = [], model, ws, alerts = [];
        let isDark = false, easyMode = true;
        let historyLength = 1000, TTL = 300000; // 5min
        let position = 0, pnl = 0, trades = [];

        // Init UI
        symbols.forEach(s => document.getElementById('symbol').innerHTML += `<option>${s}</option>`);
        document.getElementById('interval').value = '1h';
        document.getElementById('symbol').value = 'BTCUSDT';
        indicators.forEach(ind => {
            const div = document.createElement('div');
            div.innerHTML = `<input type="checkbox" id="${ind}" data-tooltip="${ind} info"><label for="${ind}">${ind}</label>`;
            document.getElementById('ind-toggles').appendChild(div);
        });
        document.getElementById('theme').onclick = () => {
            isDark = !isDark;
            document.body.classList.toggle('dark');
            document.getElementById('theme').textContent = isDark ? 'Light' : 'Dark';
            updateChart();
        };
        document.getElementById('easy').onclick = () => {
            easyMode = !easyMode;
            document.getElementById('easy').textContent = easyMode ? 'Expert' : 'Easy';
            // Hide/show advanced
            document.querySelectorAll('#sidebar > *:not(:first-child)').forEach(el => el.style.display = easyMode ? 'none' : 'block');
        };
        document.getElementById('tutorial').style.display = 'block';

        // Chart init
        chart = new ApexCharts(document.getElementById('chart'), {
            series: [{name: 'Candles', data: []}],
            chart: {type: 'candlestick', height: 400, animations: {enabled: false}},
            xaxis: {type: 'datetime'},
            theme: {mode: 'light'}
        });
        chart.render();

        // Fetch data
        async function loadData() {
            const sym = document.getElementById('symbol').value;
            const int = document.getElementById('interval').value;
            const key = `${sym}_${int}`;
            const cached = localStorage.getItem(key);
            if (cached) {
                const {data: cdata, time} = JSON.parse(cached);
                if (Date.now() - time < TTL) {
                    data = cdata;
                    updateChart();
                    updateInfo();
                    return;
                }
            }
            try {
                const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${sym}&interval=${int}&limit=${historyLength}`);
                if (!res.ok) {
                    if (res.status === 400) alert('Symbol not found on Binance');
                    return;
                }
                const raw = await res.json();
                data = raw.map(c => ({x: c[0], y: [parseFloat(c[1]), parseFloat(c[2]), parseFloat(c[3]), parseFloat(c[4])], volume: parseFloat(c[5])}));
                localStorage.setItem(key, JSON.stringify({data, time: Date.now()}));
                updateChart();
                updateInfo();
            } catch (e) {
                console.error(e);
            }
        }

        // WebSocket
        function connectWS() {
            if (ws) ws.close();
            const sym = document.getElementById('symbol').value.toLowerCase();
            const int = document.getElementById('interval').value;
            ws = new WebSocket(`wss://stream.binance.com:9443/ws/${sym}@kline_${int}`);
            ws.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                if (msg.k) {
                    const candle = {x: msg.k.t, y: [msg.k.o, msg.k.h, msg.k.l, msg.k.c], volume: msg.k.v};
                    if (data[data.length-1].x === candle.x) {
                        data[data.length-1] = candle;
                    } else {
                        data.push(candle);
                    }
                    updateChart();
                    updateInfo();
                    checkAlerts(parseFloat(msg.k.c));
                }
            };
        }

        // Update chart
        function updateChart() {
            let series = [{name: 'Candles', type: 'candlestick', data: data}];
            const closes = data.map(d => d.y[3]);
            const highs = data.map(d => d.y[1]);
            const lows = data.map(d => d.y[2]);
            const opens = data.map(d => d.y[0]);
            const volumes = data.map(d => d.volume);
            let ha = {open: opens, high: highs, low: lows, close: closes};
            if (document.getElementById('HA').checked) {
                ha = heikinAshi(opens, highs, lows, closes);
                series[0].data = data.map((d,i) => ({x: d.x, y: [ha.open[i], ha.high[i], ha.low[i], ha.close[i]]}));
            }
            const indCloses = ha.close; // use HA if enabled
            indicators.forEach(ind => {
                if (document.getElementById(ind).checked) {
                    let line;
                    switch (ind) {
                        case 'SMA5': line = addMA(series, TI.SMA.calculate({values: indCloses, period:5}), 'SMA5'); break;
                        case 'SMA10': line = addMA(series, TI.SMA.calculate({values: indCloses, period:10}), 'SMA10'); break;
                        // ... similar for others
                        case 'EMA': line = addMA(series, TI.EMA.calculate({values: indCloses, period:20}), 'EMA'); break;
                        case 'WMA': line = addMA(series, TI.WMA.calculate({values: indCloses, period:20}), 'WMA'); break;
                        case 'HMA': line = addMA(series, hullMA(indCloses, 20), 'HMA'); break;
                        case 'MACD': {
                            const macd = TI.MACD.calculate({values: indCloses, fastPeriod:12, slowPeriod:26, signalPeriod:9});
                            series.push({name: 'MACD', type: 'line', data: macd.map((m,i) => ({x: data[data.length - macd.length + i].x, y: m.MACD}))});
                            series.push({name: 'Signal', type: 'line', data: macd.map((m,i) => ({x: data[data.length - macd.length + i].x, y: m.signal}))});
                            series.push({name: 'Hist', type: 'bar', data: macd.map((m,i) => ({x: data[data.length - macd.length + i].x, y: m.histogram}))});
                            break;
                        }
                        case 'RSI': line = addMA(series, TI.RSI.calculate({values: indCloses, period:14}), 'RSI', true); break;
                        case 'Stoch': {
                            const stoch = TI.Stochastic.calculate({high: ha.high, low: ha.low, close: indCloses, period:14, signalPeriod:3});
                            series.push({name: '%K', type: 'line', data: stoch.map((s,i) => ({x: data[data.length - stoch.length + i].x, y: s.k}))});
                            series.push({name: '%D', type: 'line', data: stoch.map((s,i) => ({x: data[data.length - stoch.length + i].x, y: s.d}))});
                            break;
                        }
                        case 'BB': {
                            const bb = TI.BollingerBands.calculate({values: indCloses, period:20, stdDev:2});
                            series.push({name: 'Upper', type: 'line', data: bb.map((b,i) => ({x: data[data.length - bb.length + i].x, y: b.upper}))});
                            series.push({name: 'Middle', type: 'line', data: bb.map((b,i) => ({x: data[data.length - bb.length + i].x, y: b.middle}))});
                            series.push({name: 'Lower', type: 'line', data: bb.map((b,i) => ({x: data[data.length - bb.length + i].x, y: b.lower}))});
                            break;
                        }
                        case 'ATR': line = addMA(series, TI.ATR.calculate({high: ha.high, low: ha.low, close: indCloses, period:14}), 'ATR', true); break;
                        case 'OBV': line = addMA(series, TI.OBV.calculate({close: indCloses, volume: volumes.slice(-indCloses.length)}), 'OBV', true); break;
                        case 'VWAP': line = addMA(series, TI.VWAP.calculate({high: ha.high, low: ha.low, close: indCloses, volume: volumes.slice(-indCloses.length)}), 'VWAP'); break;
                        case 'Ichimoku': {
                            const ich = TI.Ichimoku.calculate({high: ha.high, low: ha.low, conversionPeriod:9, basePeriod:26, spanPeriod:52, displacement:26});
                            series.push({name: 'Tenkan', type: 'line', data: ich.map((ic,i) => ({x: data[data.length - ich.length + i].x, y: ic.conversion}))});
                            series.push({name: 'Kijun', type: 'line', data: ich.map((ic,i) => ({x: data[data.length - ich.length + i].x, y: ic.base}))});
                            series.push({name: 'SpanA', type: 'line', data: ich.map((ic,i) => ({x: data[data.length - ich.length + i].x, y: ic.spanA}))});
                            series.push({name: 'SpanB', type: 'line', data: ich.map((ic,i) => ({x: data[data.length - ich.length + i].x, y: ic.spanB}))});
                            series.push({name: 'Chikou', type: 'line', data: ich.map((ic,i) => ({x: data[data.length - ich.length + i].x, y: ic.lag}))});
                            break;
                        }
                        case 'ADX': line = addMA(series, TI.ADX.calculate({high: ha.high, low: ha.low, close: indCloses, period:14}).map(a => a.adx), 'ADX', true); break;
                        case 'CCI': line = addMA(series, TI.CCI.calculate({high: ha.high, low: ha.low, close: indCloses, period:20}), 'CCI', true); break;
                        case 'Supertrend': line = addMA(series, supertrend(ha.high, ha.low, indCloses), 'Supertrend'); break;
                        case 'Keltner': {
                            const kc = keltnerChannels(indCloses, ha.high, ha.low);
                            series.push({name: 'KC Upper', type: 'line', data: kc.upper.map((u,i) => ({x: data[data.length - kc.upper.length + i].x, y: u}))});
                            series.push({name: 'KC Middle', type: 'line', data: kc.middle.map((m,i) => ({x: data[data.length - kc.middle.length + i].x, y: m}))});
                            series.push({name: 'KC Lower', type: 'line', data: kc.lower.map((l,i) => ({x: data[data.length - kc.lower.length + i].x, y: l}))});
                            break;
                        }
                        case 'EMARibbon': {
                            [8,13,21,34,55,89].forEach(p => {
                                addMA(series, TI.EMA.calculate({values: indCloses, period:p}), `EMA${p}`);
                            });
                            break;
                        }
                        case 'Pivot': {
                            // Daily pivots, assume data is daily for simplicity
                            const pivots = pivotPoints(highs, lows, closes);
                            // Add horizontal lines, but Apex annotations
                            chart.addXaxisAnnotation({y: pivots.pp, label: {text: 'PP'}}); // approx
                            // etc, simplified
                            break;
                        }
                        case 'VP': {
                            const vp = TI.VolumeProfile.calculate({high: highs, low: lows, close: closes, volume: volumes, bins:10});
                            // Add as separate series bar
                            series.push({name: 'VP', type: 'bar', data: vp.map((v,i) => ({x: i, y: v.volume})) , xaxis: {type: 'category'}}); // separate pane?
                            break;
                        }
                    }
                }
            });
            chart.updateOptions({theme: {mode: isDark ? 'dark' : 'light'}});
            chart.updateSeries(series);
            updateSignals();
        }

        function addMA(series, values, name, separate=false) {
            const maData = values.map((v,i) => ({x: data[data.length - values.length + i].x, y: v}));
            series.push({name, type: 'line', data: maData});
        }

        // Custom indicators
        function heikinAshi(open, high, low, close) {
            let haClose = [], haOpen = [], haHigh = [], haLow = [];
            for (let i = 0; i < close.length; i++) {
                haClose[i] = (open[i] + high[i] + low[i] + close[i]) / 4;
                haOpen[i] = i === 0 ? (open[0] + close[0]) / 2 : (haOpen[i - 1] + haClose[i - 1]) / 2;
                haHigh[i] = Math.max(high[i], haOpen[i], haClose[i]);
                haLow[i] = Math.min(low[i], haOpen[i], haClose[i]);
            }
            return { open: haOpen, high: haHigh, low: haLow, close: haClose };
        }

        function hullMA(prices, period = 20) {
            const halfP = Math.floor(period / 2);
            const sqrtP = Math.floor(Math.sqrt(period));
            const wmaHalf = TI.WMA.calculate({values: prices, period: halfP});
            const wmaFull = TI.WMA.calculate({values: prices, period});
            const diffLen = prices.length - Math.max(halfP, period) + 1;
            const diff = [];
            for (let i = 0; i < diffLen; i++) {
                diff[i] = 2 * wmaHalf[wmaHalf.length - diffLen + i] - wmaFull[wmaFull.length - diffLen + i];
            }
            return TI.WMA.calculate({values: diff, period: sqrtP});
        }

        function supertrend(high, low, close, period = 10, mult = 3) {
            const atr = TI.ATR.calculate({high, low, close, period});
            const len = atr.length;
            const hl2 = high.slice(-len).map((h,i) => (h + low[high.length - len + i]) / 2);
            let upper = hl2.map((v,i) => v + mult * atr[i]);
            let lower = hl2.map((v,i) => v - mult * atr[i]);
            let trend = new Array(len).fill(0);
            let dir = 1;
            for (let i = 0; i < len; i++) {
                let curr = dir > 0 ? lower[i] : upper[i];
                if (i > 0) {
                    curr = dir > 0 ? Math.max(curr, trend[i-1]) : Math.min(curr, trend[i-1]);
                }
                if (dir > 0 && close[close.length - len + i - 1] < curr) {
                    dir = -1;
                    curr = upper[i];
                } else if (dir < 0 && close[close.length - len + i - 1] > curr) {
                    dir = 1;
                    curr = lower[i];
                }
                trend[i] = curr;
            }
            return trend;
        }

        function keltnerChannels(close, high, low, period=20, mult=2) {
            const ema = TI.EMA.calculate({values: close, period});
            const atr = TI.ATR.calculate({high, low, close, period});
            const len = Math.min(ema.length, atr.length);
            return {
                upper: ema.slice(-len).map((e,i) => e + mult * atr[atr.length - len + i]),
                middle: ema.slice(-len),
                lower: ema.slice(-len).map((e,i) => e - mult * atr[atr.length - len + i])
            };
        }

        function pivotPoints(high, low, close) {
            // Last day
            const last = close.length - 1;
            const pp = (high[last] + low[last] + close[last]) / 3;
            return {pp, r1: pp * 2 - low[last], s1: pp * 2 - high[last]}; // simplified
        }

        // Update info
        function updateInfo() {
            if (!data.length) return;
            const last = data[data.length-1].y[3];
            const prev = data[data.length-2]?.y[3] || last;
            const change = ((last - prev) / prev * 100).toFixed(2);
            const vol = data.reduce((s,d) => s + d.volume, 0).toFixed(0);
            document.getElementById('price').textContent = `Price: ${last}`;
            document.getElementById('change').textContent = `Change: ${change}%`;
            document.getElementById('volume').textContent = `Vol: ${vol}`;
        }

        // Signals
        function updateSignals() {
            const closes = data.map(d => d.y[3]);
            const lastClose = closes[closes.length-1];
            let signals = [];
            let score = 0;
            // Example signals
            const rsi = TI.RSI.calculate({values: closes, period:14})[0];
            if (rsi < 30) { signals.push('RSI Oversold: Buy'); score += 1; }
            if (rsi > 70) { signals.push('RSI Overbought: Sell'); score -= 1; }
            const macd = TI.MACD.calculate({values: closes, fastPeriod:12, slowPeriod:26, signalPeriod:9})[0];
            if (macd.MACD > macd.signal) { signals.push('MACD Bull Cross: Buy'); score += 1; }
            if (macd.MACD < macd.signal) { signals.push('MACD Bear Cross: Sell'); score -= 1; }
            // Add more...
            document.getElementById('signals').innerHTML = signals.join('<br>') + `<br>Score: ${score > 0 ? 'Buy' : score < 0 ? 'Sell' : 'Neutral'}`;
        }

        // Model
        async function trainModel() {
            const closes = data.map(d => d.y[3]);
            const timesteps = 20;
            const features = 1; // simple close
            const xsArr = [], ysArr = [];
            for (let i = timesteps; i < closes.length; i++) {
                xsArr.push(closes.slice(i-timesteps, i));
                ysArr.push(closes[i]);
            }
            const min = Math.min(...closes), max = Math.max(...closes);
            const norm = v => (v - min) / (max - min);
            const xs = tf.tensor3d(xsArr.map(arr => arr.map(norm)).map(arr => [arr]));
            const ys = tf.tensor1d(ysArr.map(norm));
            model = tf.sequential();
            model.add(tf.layers.lstm({units: 50, inputShape: [timesteps, features]}));
            model.add(tf.layers.dense({units: 1}));
            model.compile({optimizer: 'adam', loss: 'meanSquaredError'});
            await model.fit(xs, ys, {epochs: 10});
            alert('Model trained');
        }

        async function predict() {
            if (!model) return alert('Train first');
            const closes = data.map(d => d.y[3]);
            const last = closes.slice(-20).map(v => [v]); // norm later
            const min = Math.min(...closes), max = Math.max(...closes);
            const normLast = last.map(([v]) => [(v - min)/(max - min)]);
            const pred = model.predict(tf.tensor3d([normLast]));
            const predVal = (await pred.data())[0] * (max - min) + min;
            document.getElementById('pred-out').textContent = `Next: ${predVal.toFixed(2)}`;
        }

        // Backtest
        function backtest() {
            const closes = data.map(d => d.y[3]);
            let pos = 0, capital = 1000, buys = 0, sells = 0;
            for (let i = 50; i < closes.length; i++) {
                const slice = closes.slice(0,i);
                const rsi = TI.RSI.calculate({values: slice, period:14})[0];
                const score = (rsi < 30 ? 1 : rsi > 70 ? -1 : 0); // simple
                if (score > 0 && pos === 0) { pos = capital / closes[i]; buys++; capital = 0; }
                if (score < 0 && pos > 0) { capital = pos * closes[i]; pos = 0; sells++; }
            }
            if (pos > 0) capital = pos * closes[closes.length-1];
            const ret = ((capital - 1000)/1000 * 100).toFixed(2);
            document.getElementById('bt-out').textContent = `Return: ${ret}%`;
        }

        // Paper trade
        document.getElementById('buy-sim').onclick = () => {
            if (position === 0) {
                position = 1000 / data[data.length-1].y[3];
                trades.push(`Buy at ${data[data.length-1].y[3]}`);
            }
            updateLedger();
        };
        document.getElementById('sell-sim').onclick = () => {
            if (position > 0) {
                pnl += position * data[data.length-1].y[3] - 1000;
                trades.push(`Sell at ${data[data.length-1].y[3]}, PNL: ${pnl}`);
                position = 0;
            }
            updateLedger();
        };
        function updateLedger() {
            document.getElementById('pt-ledger').innerHTML = trades.join('<br>') + `<br>Current PNL: ${pnl}`;
        }

        // Alerts
        document.getElementById('set-alert').onclick = () => {
            alerts.push(parseFloat(document.getElementById('alert-price').value));
        };
        function checkAlerts(price) {
            alerts = alerts.filter(a => {
                if (price > a) {
                    alert(`Price alert: ${a}`);
                    return false;
                }
                return true;
            });
        }

        // Export/Import
        document.getElementById('export').onclick = () => {
            const state = {data, trades, pnl};
            const blob = new Blob([JSON.stringify(state)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pta.json';
            a.click();
        };
        document.getElementById('import').onchange = (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (ev) => {
                const state = JSON.parse(ev.target.result);
                data = state.data;
                trades = state.trades;
                pnl = state.pnl;
                updateChart();
                updateLedger();
            };
            reader.readAsText(file);
        };

        // Events
        document.getElementById('symbol').onchange = () => { loadData(); connectWS(); };
        document.getElementById('interval').onchange = () => { loadData(); connectWS(); };
        document.querySelectorAll('#ind-toggles input').forEach(inp => inp.onchange = updateChart);
        document.getElementById('train').onclick = trainModel;
        document.getElementById('predict').onclick = predict;
        document.getElementById('backtest').onclick = backtest;

        // Initial load
        loadData();
        connectWS();
    </script>
</body>
</html>
