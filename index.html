<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUANTUM PRO - Institutional Trading System</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --bg-tertiary: #1f2937;
            --bg-elevated: #2d3748;
            --accent-primary: #00f5ff;
            --accent-success: #10b981;
            --accent-danger: #ef4444;
            --accent-warning: #f59e0b;
            --accent-purple: #8b5cf6;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --text-tertiary: #6b7280;
            --border-primary: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(0, 245, 255, 0.3);
            --shadow-glow: 0 0 30px rgba(0, 245, 255, 0.15);
            --shadow-heavy: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        #root {
            width: 100%;
            min-height: 100vh;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-elevated);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-tertiary);
        }

        /* Layout */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 12px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            width: 42px;
            height: 42px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-purple));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: var(--shadow-glow);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .logo-text h1 {
            font-size: 18px;
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px;
        }

        .logo-subtitle {
            font-size: 10px;
            color: var(--text-tertiary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-danger);
            animation: blink 2s infinite;
        }

        .status-dot.connected {
            background: var(--accent-success);
            animation: none;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .nav-tabs {
            display: flex;
            gap: 4px;
        }

        .nav-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .nav-tab:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-tab.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .grid-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        @media (max-width: 1200px) {
            .grid-layout {
                grid-template-columns: 1fr;
            }
        }

        /* Cards */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 20px;
            box-shadow: var(--shadow-heavy);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .card-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-badge {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
        }

        .card-badge.success {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-success);
        }

        .card-badge.danger {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-danger);
        }

        .card-badge.warning {
            background: rgba(245, 158, 11, 0.15);
            color: var(--accent-warning);
        }

        /* Signal Panel */
        .signal-panel {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.1), rgba(139, 92, 246, 0.1));
            border: 2px solid var(--border-accent);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .signal-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
            animation: shine 3s linear infinite;
        }

        @keyframes shine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .signal-header {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            margin-bottom: 16px;
        }

        .signal-icon {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-purple));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            flex-shrink: 0;
        }

        .signal-info {
            flex: 1;
        }

        .signal-title {
            font-size: 18px;
            font-weight: 800;
            margin-bottom: 4px;
        }

        .signal-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .signal-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 700;
            margin-top: 8px;
        }

        .signal-status.bullish {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-success);
        }

        .signal-status.bearish {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-danger);
        }

        .signal-status.neutral {
            background: rgba(156, 163, 175, 0.15);
            color: var(--text-secondary);
        }

        .signal-message {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-primary);
            margin: 16px 0;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 3px solid var(--accent-primary);
        }

        .signal-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 16px;
        }

        .signal-metric {
            text-align: center;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .signal-metric-label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .signal-metric-value {
            font-size: 20px;
            font-weight: 800;
            font-family: 'Courier New', monospace;
        }

        /* Trade Setup Card */
        .trade-setup {
            background: var(--bg-secondary);
            border: 2px solid var(--border-primary);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .trade-setup.active {
            border-color: var(--accent-success);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.05), transparent);
        }

        .setup-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-primary);
        }

        .setup-title {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-tertiary);
            letter-spacing: 1px;
        }

        .setup-confidence {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .confidence-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 800;
            font-family: 'Courier New', monospace;
        }

        .confidence-badge.high {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-success);
        }

        .confidence-badge.medium {
            background: rgba(245, 158, 11, 0.15);
            color: var(--accent-warning);
        }

        .confidence-badge.low {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-danger);
        }

        .setup-action {
            font-size: 24px;
            font-weight: 900;
            margin-bottom: 16px;
        }

        .setup-action.long {
            color: var(--accent-success);
        }

        .setup-action.short {
            color: var(--accent-danger);
        }

        .setup-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .setup-detail {
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .setup-detail-label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .setup-detail-value {
            font-size: 16px;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }

        .setup-timer {
            margin-top: 16px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            text-align: center;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .setup-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 16px;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            background: #00d4e6;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 245, 255, 0.3);
        }

        .btn-success {
            background: var(--accent-success);
            color: white;
        }

        .btn-success:hover {
            background: #0d9668;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: var(--accent-danger);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-primary);
        }

        .btn-secondary:hover {
            background: var(--bg-elevated);
        }

        /* Position Manager */
        .positions-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .position-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            padding: 16px;
        }

        .position-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .position-symbol {
            font-size: 16px;
            font-weight: 700;
        }

        .position-side {
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
        }

        .position-side.long {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-success);
        }

        .position-side.short {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-danger);
        }

        .position-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            font-size: 12px;
        }

        .position-info-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .position-info-label {
            color: var(--text-tertiary);
            font-size: 10px;
        }

        .position-info-value {
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .position-pnl {
            margin-top: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .pnl-label {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .pnl-value {
            font-size: 18px;
            font-weight: 800;
            font-family: 'Courier New', monospace;
        }

        .pnl-value.profit {
            color: var(--accent-success);
        }

        .pnl-value.loss {
            color: var(--accent-danger);
        }

        /* Performance Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--bg-tertiary);
            border-radius: 10px;
            padding: 16px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 900;
            font-family: 'Courier New', monospace;
        }

        .stat-value.positive {
            color: var(--accent-success);
        }

        .stat-value.negative {
            color: var(--accent-danger);
        }

        .stat-change {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* Market Data */
        .market-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .market-card {
            background: var(--bg-tertiary);
            border-radius: 10px;
            padding: 12px;
        }

        .market-label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .market-value {
            font-size: 18px;
            font-weight: 800;
            font-family: 'Courier New', monospace;
        }

        /* Chart Container */
        .chart-wrapper {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 20px;
            height: 400px;
            margin-bottom: 20px;
        }

        .chart-canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Symbol Search */
        .symbol-search {
            position: relative;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 14px;
            font-family: 'Inter', sans-serif;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 4px;
            z-index: 100;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-primary);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .search-result-item:hover {
            background: var(--bg-tertiary);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-symbol {
            font-weight: 600;
        }

        .search-change {
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .search-change.positive {
            color: var(--accent-success);
        }

        .search-change.negative {
            color: var(--accent-danger);
        }

        /* Alert System */
        .alert-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .alert {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-left: 4px solid var(--accent-primary);
            border-radius: 10px;
            padding: 16px;
            box-shadow: var(--shadow-heavy);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert.success {
            border-left-color: var(--accent-success);
        }

        .alert.danger {
            border-left-color: var(--accent-danger);
        }

        .alert.warning {
            border-left-color: var(--accent-warning);
        }

        .alert-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .alert-title {
            font-size: 13px;
            font-weight: 700;
        }

        .alert-close {
            background: none;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            padding: 0;
            font-size: 18px;
        }

        .alert-message {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 14, 26, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 10000;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid var(--bg-tertiary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .loading-subtext {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
        }

        .empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .empty-message {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Utilities */
        .text-center { text-align: center; }
        .text-success { color: var(--accent-success); }
        .text-danger { color: var(--accent-danger); }
        .text-warning { color: var(--accent-warning); }
        .mt-2 { margin-top: 16px; }
        .mb-2 { margin-bottom: 16px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // ==================== CONFIGURATION ====================
        const CONFIG = {
            SIGNAL_HOLD_TIME: 300000, // 5 minutes
            SIGNAL_CONFIRMATION_THRESHOLD: 3,
            MAX_RISK_PER_TRADE: 0.02, // 2%
            MAX_TOTAL_RISK: 0.06, // 6%
            MIN_CONFIDENCE_FOR_ALERT: 70,
            RSI_OVERSOLD: 30,
            RSI_OVERBOUGHT: 70,
            LARGE_ORDER_THRESHOLD: 10000,
            DEFAULT_ACCOUNT_SIZE: 10000
        };

        // ==================== DATA STORAGE & STATE ====================
        class TradingEngine {
            constructor() {
                this.ws = null;
                this.wsDepth = null;
                this.currentSymbol = 'WIFUSDT';
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                
                // Market Data
                this.orderBook = { bids: [], asks: [] };
                this.cumulativeDelta = 0;
                this.deltaHistory = [];
                this.priceHistory = [];
                this.volumeHistory = [];
                this.timestamps = [];
                this.buyVolume = 0;
                this.sellVolume = 0;
                this.lastPrice = 0;
                this.startPrice = 0;
                this.volumeByPrice = {};
                this.largeOrders = 0;
                
                // Indicators
                this.rsiValues = [];
                this.emaShort = [];
                this.emaLong = [];
                
                // Signals
                this.currentSignal = null;
                this.signalStartTime = 0;
                this.signalConfirmations = 0;
                this.validatedSignals = [];
                this.signalHistory = [];
                
                // Positions
                this.positions = [];
                this.closedTrades = [];
                
                // Performance
                this.accountSize = CONFIG.DEFAULT_ACCOUNT_SIZE;
                this.startingBalance = CONFIG.DEFAULT_ACCOUNT_SIZE;
            }

            // Connect WebSocket
            connect(symbol) {
                this.currentSymbol = symbol || this.currentSymbol;
                const sym = this.currentSymbol.toLowerCase();
                
                if (this.ws) {
                    this.ws.onclose = null;
                    this.ws.close();
                }
                if (this.wsDepth) {
                    this.wsDepth.onclose = null;
                    this.wsDepth.close();
                }

                this.resetData();
                
                // Trades WebSocket
                this.ws = new WebSocket(`wss://stream.binance.com:9443/ws/${sym}@trade`);
                this.ws.onopen = () => {
                    console.log('âœ… Connected to', this.currentSymbol);
                    this.reconnectAttempts = 0;
                };
                this.ws.onmessage = (e) => this.handleTrade(JSON.parse(e.data));
                this.ws.onerror = (e) => console.error('WS Error:', e);
                this.ws.onclose = () => this.attemptReconnect();

                // Depth WebSocket
                this.wsDepth = new WebSocket(`wss://stream.binance.com:9443/ws/${sym}@depth20@100ms`);
                this.wsDepth.onmessage = (e) => this.handleDepth(JSON.parse(e.data));
            }

            attemptReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    console.error('Max reconnection attempts reached');
                    return;
                }
                this.reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
                setTimeout(() => this.connect(), delay);
            }

            resetData() {
                this.cumulativeDelta = 0;
                this.deltaHistory = [];
                this.priceHistory = [];
                this.volumeHistory = [];
                this.timestamps = [];
                this.buyVolume = 0;
                this.sellVolume = 0;
                this.volumeByPrice = {};
                this.largeOrders = 0;
                this.rsiValues = [];
                this.emaShort = [];
                this.emaLong = [];
                this.lastPrice = 0;
                this.startPrice = 0;
            }

            // Handle Trade Data
            handleTrade(data) {
                const price = parseFloat(data.p);
                const quantity = parseFloat(data.q);
                const isBuyerMaker = data.m;
                const value = price * quantity;
                
                if (this.lastPrice === 0) {
                    this.lastPrice = price;
                    this.startPrice = price;
                }
                this.lastPrice = price;

                // Calculate delta
                const delta = isBuyerMaker ? -quantity : quantity;
                this.cumulativeDelta += delta;

                // Track volume
                if (isBuyerMaker) {
                    this.sellVolume += value;
                } else {
                    this.buyVolume += value;
                }

                // Large orders
                if (value >= CONFIG.LARGE_ORDER_THRESHOLD) {
                    this.largeOrders++;
                }

                // Volume profile
                const priceLevel = (Math.round(price * 10000) / 10000).toFixed(4);
                if (!this.volumeByPrice[priceLevel]) {
                    this.volumeByPrice[priceLevel] = 0;
                }
                this.volumeByPrice[priceLevel] += value;

                // History
                const now = new Date();
                this.timestamps.push(now.toLocaleTimeString().slice(0, 8));
                this.deltaHistory.push(this.cumulativeDelta);
                this.priceHistory.push(price);
                this.volumeHistory.push(value);

                // Keep last 200 data points
                if (this.timestamps.length > 200) {
                    this.timestamps.shift();
                    this.deltaHistory.shift();
                    this.priceHistory.shift();
                    this.volumeHistory.shift();
                }

                // Calculate indicators
                this.calculateRSI();
                this.calculateEMA();
            }

            // Handle Depth Data
            handleDepth(data) {
                this.orderBook.bids = data.bids.slice(0, 10);
                this.orderBook.asks = data.asks.slice(0, 10);
            }

            // Calculate RSI
            calculateRSI(period = 14) {
                if (this.priceHistory.length < period + 1) return null;

                const changes = [];
                for (let i = 1; i < this.priceHistory.length; i++) {
                    changes.push(this.priceHistory[i] - this.priceHistory[i - 1]);
                }

                const gains = changes.map(c => c > 0 ? c : 0);
                const losses = changes.map(c => c < 0 ? -c : 0);

                const avgGain = gains.slice(-period).reduce((a, b) => a + b, 0) / period;
                const avgLoss = losses.slice(-period).reduce((a, b) => a + b, 0) / period;

                if (avgLoss === 0) return 100;

                const rs = avgGain / avgLoss;
                const rsi = 100 - (100 / (1 + rs));
                
                this.rsiValues.push(rsi);
                if (this.rsiValues.length > 50) this.rsiValues.shift();

                return rsi;
            }

            // Calculate EMA
            calculateEMA() {
                if (this.priceHistory.length < 2) return;

                const shortPeriod = 20;
                const longPeriod = 50;

                const calculateSingleEMA = (prices, period) => {
                    const k = 2 / (period + 1);
                    let ema = prices[0];
                    for (let i = 1; i < prices.length; i++) {
                        ema = (prices[i] * k) + (ema * (1 - k));
                    }
                    return ema;
                };

                if (this.priceHistory.length >= shortPeriod) {
                    const emaS = calculateSingleEMA(this.priceHistory.slice(-shortPeriod), shortPeriod);
                    this.emaShort.push(emaS);
                    if (this.emaShort.length > 50) this.emaShort.shift();
                }

                if (this.priceHistory.length >= longPeriod) {
                    const emaL = calculateSingleEMA(this.priceHistory.slice(-longPeriod), longPeriod);
                    this.emaLong.push(emaL);
                    if (this.emaLong.length > 50) this.emaLong.shift();
                }
            }

            // Get Order Book Imbalance
            getOrderBookImbalance() {
                if (this.orderBook.bids.length === 0 || this.orderBook.asks.length === 0) {
                    return 50;
                }

                const bidVolume = this.orderBook.bids.reduce((sum, [p, q]) => 
                    sum + parseFloat(q) * parseFloat(p), 0);
                const askVolume = this.orderBook.asks.reduce((sum, [p, q]) => 
                    sum + parseFloat(q) * parseFloat(p), 0);
                
                const totalVolume = bidVolume + askVolume;
                return (bidVolume / totalVolume * 100);
            }

            // Analyze Market & Generate Signals
            analyzeMarket() {
                if (this.deltaHistory.length < 20 || this.priceHistory.length < 20) {
                    return null;
                }

                let score = 0;
                let signals = [];
                let direction = 'NEUTRAL';

                // 1. Divergence Detection (40 points)
                const recentDelta = this.deltaHistory.slice(-10);
                const recentPrice = this.priceHistory.slice(-10);
                const deltaTrend = recentDelta[recentDelta.length - 1] - recentDelta[0];
                const priceTrend = recentPrice[recentPrice.length - 1] - recentPrice[0];

                if (deltaTrend > 50 && priceTrend < -0.001) {
                    score += 40;
                    signals.push('bullish_divergence');
                    direction = 'LONG';
                } else if (deltaTrend < -50 && priceTrend > 0.001) {
                    score += 40;
                    signals.push('bearish_divergence');
                    direction = 'SHORT';
                }

                // 2. RSI (20 points)
                if (this.rsiValues.length > 0) {
                    const rsi = this.rsiValues[this.rsiValues.length - 1];
                    if (rsi < CONFIG.RSI_OVERSOLD) {
                        score += 20;
                        signals.push('rsi_oversold');
                        if (direction === 'NEUTRAL') direction = 'LONG';
                    } else if (rsi > CONFIG.RSI_OVERBOUGHT) {
                        score += 20;
                        signals.push('rsi_overbought');
                        if (direction === 'NEUTRAL') direction = 'SHORT';
                    }
                }

                // 3. Order Book Imbalance (20 points)
                const imbalance = this.getOrderBookImbalance();
                if (imbalance > 65) {
                    score += 20;
                    signals.push('strong_bids');
                    if (direction === 'NEUTRAL') direction = 'LONG';
                } else if (imbalance < 35) {
                    score += 20;
                    signals.push('weak_bids');
                    if (direction === 'NEUTRAL') direction = 'SHORT';
                }

                // 4. Large Orders (10 points)
                if (this.largeOrders > 10) {
                    score += 10;
                    signals.push('institutional_activity');
                }

                // 5. Volume (10 points)
                const avgVol = this.volumeHistory.reduce((a, b) => a + b, 0) / this.volumeHistory.length;
                const recentVol = this.volumeHistory.slice(-10).reduce((a, b) => a + b, 0) / 10;
                if (recentVol > avgVol * 1.5) {
                    score += 10;
                    signals.push('high_volume');
                }

                // Signal validation with confirmation
                const newSignal = {
                    direction,
                    confidence: score,
                    signals,
                    price: this.lastPrice,
                    timestamp: Date.now()
                };

                return this.validateSignal(newSignal);
            }

            // Validate Signal with Confirmation
            validateSignal(newSignal) {
                // Check if signal is same as current
                if (this.currentSignal && 
                    this.currentSignal.direction === newSignal.direction &&
                    this.currentSignal.confidence >= CONFIG.MIN_CONFIDENCE_FOR_ALERT) {
                    
                    this.signalConfirmations++;
                    
                    // Check hold time
                    const holdTime = Date.now() - this.signalStartTime;
                    
                    if (this.signalConfirmations >= CONFIG.SIGNAL_CONFIRMATION_THRESHOLD &&
                        holdTime >= CONFIG.SIGNAL_HOLD_TIME) {
                        
                        // Signal is validated!
                        const validatedSignal = {
                            ...this.currentSignal,
                            validated: true,
                            confirmations: this.signalConfirmations,
                            holdTime: holdTime
                        };
                        
                        this.validatedSignals.push(validatedSignal);
                        return validatedSignal;
                    }
                } else {
                    // New signal
                    this.currentSignal = newSignal;
                    this.signalStartTime = Date.now();
                    this.signalConfirmations = 1;
                }

                return this.currentSignal;
            }

            // Calculate Position Size
            calculatePositionSize(entry, stopLoss) {
                const riskAmount = this.accountSize * CONFIG.MAX_RISK_PER_TRADE;
                const riskPerUnit = Math.abs(entry - stopLoss);
                return riskAmount / riskPerUnit;
            }

            // Check if can take trade
            canTakeTrade() {
                const totalRisk = this.positions.reduce((sum, p) => sum + p.riskAmount, 0);
                return totalRisk < (this.accountSize * CONFIG.MAX_TOTAL_RISK);
            }

            // Open Position
            openPosition(signal) {
                if (!this.canTakeTrade()) {
                    return { success: false, message: 'Max risk limit reached' };
                }

                const stopDistance = this.lastPrice * 0.015; // 1.5%
                const targetDistance = this.lastPrice * 0.03; // 3%
                
                const entry = this.lastPrice;
                const stopLoss = signal.direction === 'LONG' ? 
                    entry - stopDistance : entry + stopDistance;
                const takeProfit = signal.direction === 'LONG' ?
                    entry + targetDistance : entry - targetDistance;
                
                const size = this.calculatePositionSize(entry, stopLoss);
                const riskAmount = this.accountSize * CONFIG.MAX_RISK_PER_TRADE;

                const position = {
                    id: Date.now(),
                    symbol: this.currentSymbol,
                    side: signal.direction,
                    entry,
                    stopLoss,
                    takeProfit,
                    size,
                    riskAmount,
                    confidence: signal.confidence,
                    openTime: Date.now(),
                    status: 'open'
                };

                this.positions.push(position);
                return { success: true, position };
            }

            // Close Position
            closePosition(positionId, exitPrice) {
                const position = this.positions.find(p => p.id === positionId);
                if (!position) return { success: false };

                const pnl = position.side === 'LONG' ?
                    (exitPrice - position.entry) * position.size :
                    (position.entry - exitPrice) * position.size;

                const pnlPercent = (pnl / this.accountSize) * 100;

                const closedTrade = {
                    ...position,
                    exitPrice,
                    pnl,
                    pnlPercent,
                    closeTime: Date.now(),
                    status: 'closed'
                };

                this.closedTrades.push(closedTrade);
                this.positions = this.positions.filter(p => p.id !== positionId);
                this.accountSize += pnl;

                return { success: true, trade: closedTrade };
            }

            // Get Performance Stats
            getPerformanceStats() {
                const totalTrades = this.closedTrades.length;
                const winningTrades = this.closedTrades.filter(t => t.pnl > 0);
                const losingTrades = this.closedTrades.filter(t => t.pnl <= 0);
                
                const winRate = totalTrades > 0 ? (winningTrades.length / totalTrades) * 100 : 0;
                const avgWin = winningTrades.length > 0 ? 
                    winningTrades.reduce((sum, t) => sum + t.pnl, 0) / winningTrades.length : 0;
                const avgLoss = losingTrades.length > 0 ?
                    Math.abs(losingTrades.reduce((sum, t) => sum + t.pnl, 0) / losingTrades.length) : 0;
                
                const totalPnL = this.accountSize - this.startingBalance;
                const totalPnLPercent = ((this.accountSize - this.startingBalance) / this.startingBalance) * 100;

                return {
                    totalTrades,
                    winRate,
                    avgWin,
                    avgLoss,
                    totalPnL,
                    totalPnLPercent,
                    currentBalance: this.accountSize
                };
            }
        }

        // Initialize Engine
        const engine = new TradingEngine();

        // ==================== MAIN APP COMPONENT ====================
        function App() {
            const [activeTab, setActiveTab] = useState('trading');
            const [connected, setConnected] = useState(false);
            const [loading, setLoading] = useState(true);
            const [allSymbols, setAllSymbols] = useState([]);
            const [currentSymbol, setCurrentSymbol] = useState('WIFUSDT');
            const [marketData, setMarketData] = useState({
                price: 0,
                change: 0,
                volume: 0,
                delta: 0
            });
            const [signal, setSignal] = useState(null);
            const [positions, setPositions] = useState([]);
            const [performance, setPerformance] = useState({
                totalTrades: 0,
                winRate: 0,
                totalPnL: 0,
                totalPnLPercent: 0
            });
            const [alerts, setAlerts] = useState([]);
            const [chartData, setChartData] = useState({ labels: [], data: [] });

            // Initialize
            useEffect(() => {
                async function init() {
                    try {
                        // Fetch symbols
                        const response = await fetch('https://api.binance.com/api/v3/ticker/24hr');
                        const data = await response.json();
                        
                        const symbols = data
                            .filter(s => s.symbol.endsWith('USDT'))
                            .map(s => ({
                                symbol: s.symbol,
                                price: parseFloat(s.lastPrice),
                                change: parseFloat(s.priceChangePercent)
                            }))
                            .sort((a, b) => Math.abs(b.change) - Math.abs(a.change));
                        
                        setAllSymbols(symbols);
                        
                        // Connect to engine
                        engine.connect(currentSymbol);
                        setConnected(true);
                        
                        setTimeout(() => setLoading(false), 2000);
                    } catch (error) {
                        console.error('Init error:', error);
                        addAlert('danger', 'Connection Error', 'Failed to initialize system');
                        setLoading(false);
                    }
                }

                init();
            }, []);

            // Update loop
            useEffect(() => {
                const interval = setInterval(() => {
                    if (!connected) return;

                    // Update market data
                    setMarketData({
                        price: engine.lastPrice,
                        change: engine.startPrice ? 
                            ((engine.lastPrice - engine.startPrice) / engine.startPrice * 100) : 0,
                        volume: engine.buyVolume + engine.sellVolume,
                        delta: engine.cumulativeDelta
                    });

                    // Analyze and get signal
                    const currentSignal = engine.analyzeMarket();
                    if (currentSignal) {
                        setSignal(currentSignal);
                        
                        // Check if validated signal
                        if (currentSignal.validated && currentSignal.confidence >= CONFIG.MIN_CONFIDENCE_FOR_ALERT) {
                            addAlert('success', 'ðŸš¨ HIGH CONFIDENCE SETUP', 
                                `${currentSignal.direction} signal detected with ${currentSignal.confidence}% confidence`);
                        }
                    }

                    // Update chart
                    setChartData({
                        labels: engine.timestamps,
                        data: engine.deltaHistory
                    });

                    // Update positions
                    setPositions([...engine.positions]);

                    // Update performance
                    setPerformance(engine.getPerformanceStats());

                }, 1000);

                return () => clearInterval(interval);
            }, [connected]);

            // Add Alert
            const addAlert = (type, title, message) => {
                const alert = {
                    id: Date.now(),
                    type,
                    title,
                    message,
                    timestamp: Date.now()
                };
                setAlerts(prev => [alert, ...prev]);
                
                // Auto remove after 5 seconds
                setTimeout(() => {
                    setAlerts(prev => prev.filter(a => a.id !== alert.id));
                }, 5000);

                // Browser notification for high priority
                if (type === 'success' && document.hidden) {
                    if ('Notification' in window && Notification.permission === 'granted') {
                        new Notification(title, { body: message });
                    }
                }
            };

            // Remove Alert
            const removeAlert = (id) => {
                setAlerts(prev => prev.filter(a => a.id !== id));
            };

            // Change Symbol
            const changeSymbol = (symbol) => {
                setCurrentSymbol(symbol);
                engine.connect(symbol);
                addAlert('success', 'Symbol Changed', `Now tracking ${symbol}`);
            };

            // Execute Trade
            const executeTrade = () => {
                if (!signal || signal.confidence < CONFIG.MIN_CONFIDENCE_FOR_ALERT) {
                    addAlert('warning', 'Cannot Execute', 'Signal confidence too low');
                    return;
                }

                const result = engine.openPosition(signal);
                if (result.success) {
                    addAlert('success', 'Position Opened', 
                        `${signal.direction} position opened at $${engine.lastPrice.toFixed(6)}`);
                    setPositions([...engine.positions]);
                } else {
                    addAlert('danger', 'Trade Failed', result.message);
                }
            };

            // Close Position
            const closePosition = (positionId) => {
                const result = engine.closePosition(positionId, engine.lastPrice);
                if (result.success) {
                    addAlert(result.trade.pnl > 0 ? 'success' : 'danger', 
                        'Position Closed',
                        `P&L: $${result.trade.pnl.toFixed(2)} (${result.trade.pnlPercent.toFixed(2)}%)`);
                    setPositions([...engine.positions]);
                    setPerformance(engine.getPerformanceStats());
                }
            };

            // Request Notification Permission
            useEffect(() => {
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission();
                }
            }, []);

            if (loading) {
                return <LoadingScreen />;
            }

            return (
                <div className="app-container">
                    <Header 
                        activeTab={activeTab}
                        setActiveTab={setActiveTab}
                        connected={connected}
                        currentSymbol={currentSymbol}
                    />
                    
                    <div className="main-content">
                        {activeTab === 'trading' && (
                            <TradingView 
                                signal={signal}
                                marketData={marketData}
                                chartData={chartData}
                                allSymbols={allSymbols}
                                currentSymbol={currentSymbol}
                                changeSymbol={changeSymbol}
                                executeTrade={executeTrade}
                                positions={positions}
                                closePosition={closePosition}
                            />
                        )}
                        
                        {activeTab === 'performance' && (
                            <PerformanceView 
                                performance={performance}
                                trades={engine.closedTrades}
                            />
                        )}
                        
                        {activeTab === 'positions' && (
                            <PositionsView 
                                positions={positions}
                                closePosition={closePosition}
                                marketPrice={marketData.price}
                            />
                        )}
                    </div>

                    <AlertPanel alerts={alerts} removeAlert={removeAlert} />
                </div>
            );
        }

        // ==================== COMPONENTS ====================

        function LoadingScreen() {
            return (
                <div className="loading-overlay">
                    <div className="loader"></div>
                    <div className="loading-text">Initializing QUANTUM PRO</div>
                    <div className="loading-subtext">Loading market data & ML models...</div>
                </div>
            );
        }

        function Header({ activeTab, setActiveTab, connected, currentSymbol }) {
            return (
                <div className="header">
                    <div className="logo-section">
                        <div className="logo">
                            <div className="logo-icon">ðŸ§ </div>
                            <div className="logo-text">
                                <h1>QUANTUM PRO</h1>
                                <div className="logo-subtitle">Institutional Trading System</div>
                            </div>
                        </div>
                    </div>

                    <div className="header-actions">
                        <nav className="nav-tabs">
                            <button 
                                className={`nav-tab ${activeTab === 'trading' ? 'active' : ''}`}
                                onClick={() => setActiveTab('trading')}
                            >
                                Trading
                            </button>
                            <button 
                                className={`nav-tab ${activeTab === 'positions' ? 'active' : ''}`}
                                onClick={() => setActiveTab('positions')}
                            >
                                Positions
                            </button>
                            <button 
                                className={`nav-tab ${activeTab === 'performance' ? 'active' : ''}`}
                                onClick={() => setActiveTab('performance')}
                            >
                                Performance
                            </button>
                        </nav>

                        <div className="status-indicator">
                            <div className={`status-dot ${connected ? 'connected' : ''}`}></div>
                            <span>{connected ? 'LIVE' : 'OFFLINE'}</span>
                        </div>
                    </div>
                </div>
            );
        }

        function TradingView({ signal, marketData, chartData, allSymbols, currentSymbol, changeSymbol, executeTrade, positions, closePosition }) {
            return (
                <div className="grid-layout">
                    <div>
                        <SymbolSearch 
                            symbols={allSymbols}
                            currentSymbol={currentSymbol}
                            onSelect={changeSymbol}
                        />

                        <SignalPanel signal={signal} marketData={marketData} />

                        {signal && signal.validated && signal.confidence >= CONFIG.MIN_CONFIDENCE_FOR_ALERT && (
                            <TradeSetup 
                                signal={signal}
                                marketData={marketData}
                                onExecute={executeTrade}
                            />
                        )}

                        <MarketDataGrid marketData={marketData} />
                        
                        <ChartWidget data={chartData} />
                    </div>

                    <div>
                        <PositionsSidebar 
                            positions={positions}
                            closePosition={closePosition}
                            marketPrice={marketData.price}
                        />
                    </div>
                </div>
            );
        }

        function SymbolSearch({ symbols, currentSymbol, onSelect }) {
            const [search, setSearch] = useState('');
            const [showResults, setShowResults] = useState(false);

            const filtered = symbols.filter(s => 
                s.symbol.includes(search.toUpperCase())
            ).slice(0, 10);

            return (
                <div className="symbol-search">
                    <input 
                        type="text"
                        className="search-input"
                        placeholder={`Search symbols... (Current: ${currentSymbol})`}
                        value={search}
                        onChange={(e) => {
                            setSearch(e.target.value);
                            setShowResults(e.target.value.length > 0);
                        }}
                        onFocus={() => search && setShowResults(true)}
                        onBlur={() => setTimeout(() => setShowResults(false), 200)}
                    />
                    
                    {showResults && filtered.length > 0 && (
                        <div className="search-results active">
                            {filtered.map(s => (
                                <div 
                                    key={s.symbol}
                                    className="search-result-item"
                                    onClick={() => {
                                        onSelect(s.symbol);
                                        setSearch('');
                                        setShowResults(false);
                                    }}
                                >
                                    <span className="search-symbol">{s.symbol}</span>
                                    <span className={`search-change ${s.change >= 0 ? 'positive' : 'negative'}`}>
                                        {s.change >= 0 ? '+' : ''}{s.change.toFixed(2)}%
                                    </span>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        }

        function SignalPanel({ signal, marketData }) {
            if (!signal) {
                return (
                    <div className="signal-panel">
                        <div className="signal-header">
                            <div className="signal-icon">ðŸ¤–</div>
                            <div className="signal-info">
                                <div className="signal-title">QUANTUM AI Assistant</div>
                                <div className="signal-subtitle">Analyzing market conditions...</div>
                                <div className="signal-status neutral">
                                    INITIALIZING
                                </div>
                            </div>
                        </div>
                        <div className="signal-message">
                            Collecting market data and calculating indicators. Please wait for signal validation...
                        </div>
                    </div>
                );
            }

            const holdTime = Date.now() - (signal.timestamp || Date.now());
            const holdMinutes = Math.floor(holdTime / 60000);
            const isValidated = signal.validated && signal.confidence >= CONFIG.MIN_CONFIDENCE_FOR_ALERT;

            let statusClass = 'neutral';
            let statusText = 'ANALYZING';
            let message = 'Monitoring market for setup confirmation...';

            if (isValidated) {
                statusClass = signal.direction === 'LONG' ? 'bullish' : 
                              signal.direction === 'SHORT' ? 'bearish' : 'neutral';
                statusText = `${signal.direction} SIGNAL VALIDATED`;
                message = `ðŸŽ¯ HIGH PROBABILITY ${signal.direction} SETUP DETECTED!\n\n` +
                         `Confidence: ${signal.confidence}%\n` +
                         `Signals: ${signal.signals.join(', ').replace(/_/g, ' ')}\n\n` +
                         `âœ… Signal held for ${holdMinutes} minutes with ${signal.confirmations} confirmations.\n` +
                         `This is a validated setup ready for execution!`;
            } else if (signal.confidence >= 40) {
                statusClass = 'warning';
                statusText = 'SETUP FORMING';
                message = `Potential ${signal.direction} setup forming (${signal.confidence}% confidence).\n` +
                         `Waiting for confirmation... (${holdMinutes}/${Math.floor(CONFIG.SIGNAL_HOLD_TIME/60000)} min)`;
            }

            return (
                <div className="signal-panel">
                    <div className="signal-header">
                        <div className="signal-icon">ðŸ¤–</div>
                        <div className="signal-info">
                            <div className="signal-title">QUANTUM AI Assistant</div>
                            <div className="signal-subtitle">Real-time Market Analysis</div>
                            <div className={`signal-status ${statusClass}`}>
                                {statusText}
                            </div>
                        </div>
                    </div>
                    <div className="signal-message">
                        {message}
                    </div>
                    <div className="signal-metrics">
                        <div className="signal-metric">
                            <div className="signal-metric-label">Confidence</div>
                            <div className={`signal-metric-value ${
                                signal.confidence >= 70 ? 'text-success' : 
                                signal.confidence >= 40 ? 'text-warning' : 'text-danger'
                            }`}>
                                {signal.confidence}%
                            </div>
                        </div>
                        <div className="signal-metric">
                            <div className="signal-metric-label">Direction</div>
                            <div className={`signal-metric-value ${
                                signal.direction === 'LONG' ? 'text-success' : 
                                signal.direction === 'SHORT' ? 'text-danger' : ''
                            }`}>
                                {signal.direction}
                            </div>
                        </div>
                        <div className="signal-metric">
                            <div className="signal-metric-label">Hold Time</div>
                            <div className="signal-metric-value">
                                {holdMinutes}m
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        function TradeSetup({ signal, marketData, onExecute }) {
            const [showConfirm, setShowConfirm] = useState(false);

            const stopDistance = marketData.price * 0.015;
            const targetDistance = marketData.price * 0.03;
            
            const entry = marketData.price;
            const stopLoss = signal.direction === 'LONG' ? 
                entry - stopDistance : entry + stopDistance;
            const takeProfit = signal.direction === 'LONG' ?
                entry + targetDistance : entry - targetDistance;

            const holdTime = Date.now() - signal.timestamp;
            const holdMinutes = Math.floor(holdTime / 60000);

            return (
                <div className="trade-setup active">
                    <div className="setup-header">
                        <div className="setup-title">VALIDATED TRADE SETUP</div>
                        <div className="setup-confidence">
                            <div className="confidence-badge high">
                                {signal.confidence}%
                            </div>
                        </div>
                    </div>

                    <div className={`setup-action ${signal.direction.toLowerCase()}`}>
                        {signal.direction === 'LONG' ? 'ðŸŸ¢' : 'ðŸ”´'} RECOMMENDED {signal.direction}
                    </div>

                    <div className="setup-details">
                        <div className="setup-detail">
                            <div className="setup-detail-label">Entry Price</div>
                            <div className="setup-detail-value">
                                ${entry.toFixed(entry < 1 ? 6 : 2)}
                            </div>
                        </div>
                        <div className="setup-detail">
                            <div className="setup-detail-label">Stop Loss</div>
                            <div className="setup-detail-value">
                                ${stopLoss.toFixed(entry < 1 ? 6 : 2)}
                            </div>
                        </div>
                        <div className="setup-detail">
                            <div className="setup-detail-label">Take Profit</div>
                            <div className="setup-detail-value">
                                ${takeProfit.toFixed(entry < 1 ? 6 : 2)}
                            </div>
                        </div>
                        <div className="setup-detail">
                            <div className="setup-detail-label">Risk:Reward</div>
                            <div className="setup-detail-value">1:2</div>
                        </div>
                    </div>

                    <div className="setup-timer">
                        â±ï¸ Signal held for {holdMinutes} minutes | {signal.confirmations} confirmations
                    </div>

                    <div className="setup-actions">
                        <button 
                            className={signal.direction === 'LONG' ? 'btn btn-success' : 'btn btn-danger'}
                            onClick={onExecute}
                        >
                            âš¡ EXECUTE TRADE
                        </button>
                        <button className="btn btn-secondary">
                            ðŸ“‹ COPY ORDER
                        </button>
                    </div>
                </div>
            );
        }

        function MarketDataGrid({ marketData }) {
            return (
                <div className="market-grid">
                    <div className="market-card">
                        <div className="market-label">Price</div>
                        <div className="market-value">
                            ${marketData.price.toFixed(marketData.price < 1 ? 6 : 2)}
                        </div>
                    </div>
                    <div className="market-card">
                        <div className="market-label">24h Change</div>
                        <div className={`market-value ${marketData.change >= 0 ? 'text-success' : 'text-danger'}`}>
                            {marketData.change >= 0 ? '+' : ''}{marketData.change.toFixed(2)}%
                        </div>
                    </div>
                    <div className="market-card">
                        <div className="market-label">Cum. Delta</div>
                        <div className={`market-value ${
                            marketData.delta > 0 ? 'text-success' : 
                            marketData.delta < 0 ? 'text-danger' : ''
                        }`}>
                            {marketData.delta.toFixed(2)}
                        </div>
                    </div>
                    <div className="market-card">
                        <div className="market-label">Volume</div>
                        <div className="market-value">
                            ${(marketData.volume / 1000).toFixed(1)}K
                        </div>
                    </div>
                </div>
            );
        }

        function ChartWidget({ data }) {
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            useEffect(() => {
                if (!chartRef.current) return;

                const ctx = chartRef.current.getContext('2d');

                if (chartInstance.current) {
                    chartInstance.current.destroy();
                }

                chartInstance.current = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.labels,
                        datasets: [{
                            label: 'Cumulative Delta',
                            data: data.data,
                            borderColor: '#00f5ff',
                            backgroundColor: 'rgba(0, 245, 255, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: '#111827',
                                titleColor: '#00f5ff',
                                bodyColor: '#f9fafb',
                                padding: 12,
                                displayColors: false
                            }
                        },
                        scales: {
                            x: { display: false },
                            y: {
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: {
                                    color: '#9ca3af',
                                    font: { size: 10, family: 'Courier New' }
                                }
                            }
                        }
                    }
                });

                return () => {
                    if (chartInstance.current) {
                        chartInstance.current.destroy();
                    }
                };
            }, [data]);

            return (
                <div className="chart-wrapper">
                    <canvas ref={chartRef} className="chart-canvas"></canvas>
                </div>
            );
        }

        function PositionsSidebar({ positions, closePosition, marketPrice }) {
            return (
                <div className="card">
                    <div className="card-header">
                        <div className="card-title">
                            <span>ðŸ’¼</span>
                            Open Positions
                        </div>
                        <div className={`card-badge ${positions.length > 0 ? 'success' : ''}`}>
                            {positions.length}
                        </div>
                    </div>

                    <div className="positions-list">
                        {positions.length === 0 ? (
                            <div className="empty-state">
                                <div className="empty-icon">ðŸ“Š</div>
                                <div className="empty-title">No Open Positions</div>
                                <div className="empty-message">
                                    Waiting for validated signals to open positions
                                </div>
                            </div>
                        ) : (
                            positions.map(position => (
                                <PositionCard 
                                    key={position.id}
                                    position={position}
                                    marketPrice={marketPrice}
                                    onClose={() => closePosition(position.id)}
                                />
                            ))
                        )}
                    </div>
                </div>
            );
        }

        function PositionCard({ position, marketPrice, onClose }) {
            const pnl = position.side === 'LONG' ?
                (marketPrice - position.entry) * position.size :
                (position.entry - marketPrice) * position.size;
            
            const pnlPercent = (pnl / (position.entry * position.size)) * 100;

            return (
                <div className="position-card">
                    <div className="position-header">
                        <div className="position-symbol">{position.symbol}</div>
                        <div className={`position-side ${position.side.toLowerCase()}`}>
                            {position.side}
                        </div>
                    </div>

                    <div className="position-info">
                        <div className="position-info-item">
                            <div className="position-info-label">Entry</div>
                            <div className="position-info-value">
                                ${position.entry.toFixed(6)}
                            </div>
                        </div>
                        <div className="position-info-item">
                            <div className="position-info-label">Current</div>
                            <div className="position-info-value">
                                ${marketPrice.toFixed(6)}
                            </div>
                        </div>
                        <div className="position-info-item">
                            <div className="position-info-label">Size</div>
                            <div className="position-info-value">
                                {position.size.toFixed(2)}
                            </div>
                        </div>
                    </div>

                    <div className="position-pnl">
                        <div className="pnl-label">Unrealized P&L</div>
                        <div className={`pnl-value ${pnl >= 0 ? 'profit' : 'loss'}`}>
                            {pnl >= 0 ? '+' : ''}${pnl.toFixed(2)} ({pnlPercent.toFixed(2)}%)
                        </div>
                    </div>

                    <button className="btn btn-secondary mt-2" onClick={onClose}>
                        Close Position
                    </button>
                </div>
            );
        }

        function PerformanceView({ performance, trades }) {
            return (
                <div>
                    <div className="stats-grid">
                        <div className="stat-card">
                            <div className="stat-label">Total P&L</div>
                            <div className={`stat-value ${performance.totalPnL >= 0 ? 'positive' : 'negative'}`}>
                                {performance.totalPnL >= 0 ? '+' : ''}${performance.totalPnL.toFixed(2)}
                            </div>
                            <div className="stat-change">
                                {performance.totalPnLPercent >= 0 ? '+' : ''}{performance.totalPnLPercent.toFixed(2)}%
                            </div>
                        </div>

                        <div className="stat-card">
                            <div className="stat-label">Win Rate</div>
                            <div className={`stat-value ${performance.winRate >= 50 ? 'positive' : 'negative'}`}>
                                {performance.winRate.toFixed(1)}%
                            </div>
                            <div className="stat-change">{performance.totalTrades} trades</div>
                        </div>

                        <div className="stat-card">
                            <div className="stat-label">Avg Win</div>
                            <div className="stat-value positive">
                                ${performance.avgWin.toFixed(2)}
                            </div>
                        </div>

                        <div className="stat-card">
                            <div className="stat-label">Avg Loss</div>
                            <div className="stat-value negative">
                                ${performance.avgLoss.toFixed(2)}
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <div className="card-header">
                            <div className="card-title">
                                <span>ðŸ“œ</span>
                                Trade History
                            </div>
                            <div className="card-badge">{trades.length}</div>
                        </div>

                        {trades.length === 0 ? (
                            <div className="empty-state">
                                <div className="empty-icon">ðŸ“ˆ</div>
                                <div className="empty-title">No Trade History</div>
                                <div className="empty-message">
                                    Your closed trades will appear here
                                </div>
                            </div>
                        ) : (
                            <div style={{ maxHeight: '600px', overflowY: 'auto' }}>
                                {trades.slice().reverse().map(trade => (
                                    <div key={trade.id} className="position-card" style={{ marginBottom: '12px' }}>
                                        <div className="position-header">
                                            <div className="position-symbol">{trade.symbol}</div>
                                            <div className={`position-side ${trade.side.toLowerCase()}`}>
                                                {trade.side}
                                            </div>
                                        </div>

                                        <div className="position-info">
                                            <div className="position-info-item">
                                                <div className="position-info-label">Entry</div>
                                                <div className="position-info-value">${trade.entry.toFixed(6)}</div>
                                            </div>
                                            <div className="position-info-item">
                                                <div className="position-info-label">Exit</div>
                                                <div className="position-info-value">${trade.exitPrice.toFixed(6)}</div>
                                            </div>
                                            <div className="position-info-item">
                                                <div className="position-info-label">Confidence</div>
                                                <div className="position-info-value">{trade.confidence}%</div>
                                            </div>
                                        </div>

                                        <div className="position-pnl">
                                            <div className="pnl-label">Realized P&L</div>
                                            <div className={`pnl-value ${trade.pnl >= 0 ? 'profit' : 'loss'}`}>
                                                {trade.pnl >= 0 ? '+' : ''}${trade.pnl.toFixed(2)} ({trade.pnlPercent.toFixed(2)}%)
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function PositionsView({ positions, closePosition, marketPrice }) {
            return (
                <div>
                    <div className="card">
                        <div className="card-header">
                            <div className="card-title">
                                <span>ðŸ’¼</span>
                                All Open Positions
                            </div>
                            <div className={`card-badge ${positions.length > 0 ? 'success' : ''}`}>
                                {positions.length}
                            </div>
                        </div>

                        {positions.length === 0 ? (
                            <div className="empty-state">
                                <div className="empty-icon">ðŸ“Š</div>
                                <div className="empty-title">No Open Positions</div>
                                <div className="empty-message">
                                    Execute validated signals from the Trading tab
                                </div>
                            </div>
                        ) : (
                            <div className="positions-list">
                                {positions.map(position => (
                                    <PositionCard 
                                        key={position.id}
                                        position={position}
                                        marketPrice={marketPrice}
                                        onClose={() => closePosition(position.id)}
                                    />
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function AlertPanel({ alerts, removeAlert }) {
            if (alerts.length === 0) return null;

            return (
                <div className="alert-panel">
                    {alerts.map(alert => (
                        <div key={alert.id} className={`alert ${alert.type}`}>
                            <div className="alert-header">
                                <div className="alert-title">{alert.title}</div>
                                <button className="alert-close" onClick={() => removeAlert(alert.id)}>
                                    Ã—
                                </button>
                            </div>
                            <div className="alert-message">{alert.message}</div>
                        </div>
                    ))}
                </div>
            );
        }

        // ==================== RENDER ====================
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
