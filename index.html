<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Personal Trading Assistant</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/technicalindicators@3.1.0/dist/browser.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>

    <style>
        /* --- GLOBAL STYLES & THEMES --- */
        :root {
            --bg-color: #131722;
            --primary-text: #d1d4dc;
            --secondary-text: #8c8f96;
            --border-color: #2a2e39;
            --card-bg: #1e222d;
            --accent-color: #2962ff;
            --accent-hover: #1e4ac9;
            --green: #26a69a;
            --red: #ef5350;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        [data-theme="light"] {
            --bg-color: #ffffff;
            --primary-text: #131722;
            --secondary-text: #5d606b;
            --border-color: #e0e3eb;
            --card-bg: #f7f8fa;
            --green: #008773;
            --red: #d7373f;
        }

        *, *::before, *::after { box-sizing: border-box; }
        
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--primary-text);
            margin: 0;
            padding: 0;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* --- LAYOUT --- */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .chart-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .sidebar {
            width: 340px;
            background-color: var(--card-bg);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: width 0.3s ease;
        }
        
        /* --- HEADER --- */
        .app-header {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .app-header h1 {
            font-size: 18px;
            margin: 0;
            margin-right: 16px;
        }
        
        .header-controls select, .header-controls button {
            background-color: var(--card-bg);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .price-info {
            display: flex;
            align-items: center;
            margin-left: auto;
            font-size: 16px;
            gap: 16px;
        }
        .price-info .last-price { font-weight: bold; }
        .price-info .change.positive { color: var(--green); }
        .price-info .change.negative { color: var(--red); }

        /* --- CHART AREA --- */
        #chart {
            width: 100%;
            height: 100%;
            flex: 1;
        }
        
        #chart-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            font-size: 18px;
            color: var(--secondary-text);
            display: none;
        }

        .indicator-toolbar {
            padding: 4px 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .indicator-toolbar button {
             background-color: transparent;
             color: var(--secondary-text);
             border: 1px solid var(--border-color);
             padding: 4px 8px;
             font-size: 12px;
             border-radius: 16px;
             cursor: pointer;
        }
        .indicator-toolbar button.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        /* --- SIDEBAR --- */
        .sidebar-section {
            border-bottom: 1px solid var(--border-color);
            padding: 16px;
        }
        .sidebar-section h3 {
            font-size: 16px;
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--primary-text);
        }
        
        .composite-score-display { text-align: center; }
        .score-value {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .score-label {
            font-size: 18px;
            font-weight: 500;
        }
        .score-label.buy { color: var(--green); }
        .score-label.sell { color: var(--red); }
        .score-label.neutral { color: var(--secondary-text); }
        
        .signal-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 13px;
            max-height: 150px;
            overflow-y: auto;
        }
        .signal-list li {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }
        .signal-list .signal-name { color: var(--secondary-text); }
        
        .ml-controls .control-group { margin-bottom: 12px; }
        .ml-controls label { display: block; margin-bottom: 4px; color: var(--secondary-text); }
        .ml-controls input, .ml-controls select {
            width: 100%;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--primary-text);
            padding: 6px;
            border-radius: 4px;
        }
        
        .ml-actions button {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 8px;
        }
        .ml-actions button:hover { background-color: var(--accent-hover); }
        .ml-actions button:disabled { background-color: var(--border-color); cursor: not-allowed; }
        
        #ml-status { margin-top: 8px; font-style: italic; color: var(--secondary-text); text-align: center; }
        
        /* --- BOTTOM PANEL --- */
        .bottom-panel {
            height: 250px;
            border-top: 1px solid var(--border-color);
            background-color: var(--card-bg);
            display: flex;
            flex-direction: column;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-button {
            padding: 10px 16px;
            cursor: pointer;
            background: transparent;
            border: none;
            color: var(--secondary-text);
            font-size: 14px;
            border-bottom: 2px solid transparent;
        }
        .tab-button.active {
            color: var(--primary-text);
            border-bottom: 2px solid var(--accent-color);
        }
        
        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        .tab-content.active { display: block; }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        th { color: var(--secondary-text); }
        
        /* --- UTILITY & RESPONSIVE --- */
        .hidden { display: none !important; }
        
        @media (max-width: 768px) {
            .main-container { flex-direction: column; }
            .sidebar {
                width: 100%;
                height: 40vh;
                border-left: none;
                border-top: 1px solid var(--border-color);
            }
            .price-info { display: none; }
            .app-header h1 { font-size: 16px; }
            .app-header { padding: 8px; gap: 8px;}
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s, bottom 0.5s;
        }

        .toast.show {
            opacity: 1;
            bottom: 30px;
        }
        
        .toast.error { background-color: var(--red); }
        .toast.success { background-color: var(--green); }

    </style>
</head>
<body>

    <header class="app-header">
        <h1>PTA</h1>
        <div class="header-controls">
            <select id="symbol-selector"></select>
            <select id="interval-selector">
                <option value="1m">1m</option>
                <option value="5m">5m</option>
                <option value="15m" selected>15m</option>
                <option value="1h">1h</option>
                <option value="4h">4h</option>
                <option value="1d">1d</option>
            </select>
        </div>
        <div class="price-info">
            <span id="last-price">-.--</span>
            <span id="price-change" class="change">-.--%</span>
        </div>
        <button id="theme-toggle" style="margin-left: auto;">‚òÄÔ∏è/üåô</button>
    </header>

    <div class="main-container">
        <div class="chart-container">
            <div class="indicator-toolbar">
                </div>
            <div id="chart"></div>
            <div id="chart-loader">Loading chart data...</div>
        </div>

        <aside class="sidebar">
            <div class="sidebar-section">
                <h3>Composite Signal</h3>
                <div id="composite-score" class="composite-score-display">
                    <div class="score-value">0.00</div>
                    <div class="score-label neutral">Neutral</div>
                </div>
                <h4 style="margin-top: 20px; margin-bottom: 8px;">Active Signals</h4>
                <ul id="signal-list" class="signal-list">
                    <li>No active signals</li>
                </ul>
            </div>
            
            <div class="sidebar-section">
                <h3>ML Prediction</h3>
                <div class="ml-controls">
                    <div class="control-group">
                        <label for="ml-horizon">Prediction Horizon (candles)</label>
                        <input type="number" id="ml-horizon" value="5" min="1" max="20">
                    </div>
                    <div class="control-group">
                        <label for="ml-epochs">Training Epochs</label>
                        <input type="number" id="ml-epochs" value="10" min="1" max="50">
                    </div>
                </div>
                <div class="ml-actions">
                    <button id="train-model-btn">Train Model</button>
                </div>
                <div id="ml-status">Model not trained.</div>
            </div>
            
             <div class="sidebar-section">
                <h3>Paper Trading</h3>
                 <div class="paper-trade-controls" style="display: flex; gap: 8px;">
                     <input type="number" id="trade-amount" value="1000" placeholder="Amount (USDT)" style="flex: 1; background: var(--bg-color); border: 1px solid var(--border-color); color: var(--primary-text); padding: 6px; border-radius: 4px;">
                     <button id="paper-buy" style="flex: 1; padding: 8px; background-color: var(--green); color: white; border: none; border-radius: 4px; cursor: pointer;">Buy</button>
                     <button id="paper-sell" style="flex: 1; padding: 8px; background-color: var(--red); color: white; border: none; border-radius: 4px; cursor: pointer;">Sell</button>
                 </div>
            </div>

        </aside>
    </div>

    <div class="bottom-panel">
        <div class="tabs">
            <button class="tab-button active" data-tab="positions">Positions</button>
            <button class="tab-button" data-tab="history">History</button>
            <button class="tab-button" data-tab="backtest">Backtest</button>
        </div>
        <div id="positions" class="tab-content active">
             <table>
                <thead><tr><th>Symbol</th><th>Side</th><th>Amount (USDT)</th><th>Entry Price</th><th>Current Price</th><th>P&L</th><th>Actions</th></tr></thead>
                <tbody id="positions-table-body"></tbody>
            </table>
        </div>
        <div id="history" class="tab-content">
            <table>
                <thead><tr><th>Time</th><th>Symbol</th><th>Side</th><th>Amount (USDT)</th><th>Price</th></tr></thead>
                <tbody id="history-table-body"></tbody>
            </table>
        </div>
        <div id="backtest" class="tab-content">
             <div class="backtest-controls" style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
                <span>Buy when Score ></span>
                <input type="number" id="backtest-buy-threshold" value="0.6" step="0.1" style="width: 80px; background: var(--bg-color); border: 1px solid var(--border-color); color: var(--primary-text); padding: 4px;">
                <span>Sell when Score <</span>
                <input type="number" id="backtest-sell-threshold" value="-0.6" step="0.1" style="width: 80px; background: var(--bg-color); border: 1px solid var(--border-color); color: var(--primary-text); padding: 4px;">
                <button id="run-backtest-btn" style="padding: 6px 12px; background-color: var(--accent-color); color: white; border: none; border-radius: 4px; cursor: pointer;">Run Backtest</button>
            </div>
            <div id="backtest-results">Run a backtest to see results.</div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

<script>
// ========================================================================================================
// # JAVASCRIPT APPLICATION LOGIC
// # This script contains the entire functionality for the Personal Trading Assistant.
// # It is structured into logical modules using an IIFE (Immediately Invoked Function Expression)
// # to encapsulate the code and avoid polluting the global namespace.
// ========================================================================================================

(function() {
    'use strict';

    // --- GLOBAL CONFIGURATION & STATE ---
    const config = {
        binanceApiUrl: 'https://api.binance.com/api/v3',
        binanceWsUrl: 'wss://stream.binance.com:9443/ws',
        symbols: ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'WIFUSDT', 'AVAXUSDT', 'PYTHUSDT', 'ADAUSDT', 'MATICUSDT', 'BRETTUSDT', 'FARCOINUSDT'],
        intervals: ['1m', '5m', '15m', '1h', '4h', '1d'],
        candleLimit: 1000,
        cacheTTL: 5 * 60 * 1000, // 5 minutes
        defaultIndicators: [
            { name: 'EMA', params: { period: 20 }, type: 'overlay', color: '#ff6d00' },
            { name: 'EMA', params: { period: 50 }, type: 'overlay', color: '#2962ff' },
        ]
    };

    const state = {
        currentSymbol: null,
        currentInterval: null,
        klineData: [],
        chart: null,
        candleSeries: null,
        indicatorSeries: {},
        ws: null,
        activeIndicators: new Set(),
        mlModel: null,
        isTraining: false,
        paperTrades: {
            positions: [],
            history: [],
        },
    };
    
    // Technical Indicator definitions
    const INDICATOR_DEFS = {
        'SMA': { params: [{ name: 'period', default: 20 }], type: 'overlay' },
        'EMA': { params: [{ name: 'period', default: 20 }], type: 'overlay' },
        'Bollinger Bands': { params: [{ name: 'period', default: 20 }, { name: 'stdDev', default: 2 }], type: 'overlay' },
        'MACD': { params: [{ name: 'fastPeriod', default: 12 }, { name: 'slowPeriod', default: 26 }, { name: 'signalPeriod', default: 9 }], type: 'pane' },
        'RSI': { params: [{ name: 'period', default: 14 }], type: 'pane' },
        'Stochastic': { params: [{ name: 'period', default: 14 }, { name: 'signalPeriod', default: 3 }], type: 'pane' },
    };


    // --- DOM ELEMENT REFERENCES ---
    const dom = {
        symbolSelector: document.getElementById('symbol-selector'),
        intervalSelector: document.getElementById('interval-selector'),
        lastPrice: document.getElementById('last-price'),
        priceChange: document.getElementById('price-change'),
        chartContainer: document.getElementById('chart'),
        chartLoader: document.getElementById('chart-loader'),
        indicatorToolbar: document.querySelector('.indicator-toolbar'),
        compositeScoreValue: document.querySelector('.composite-score-display .score-value'),
        compositeScoreLabel: document.querySelector('.composite-score-display .score-label'),
        signalList: document.getElementById('signal-list'),
        trainModelBtn: document.getElementById('train-model-btn'),
        mlStatus: document.getElementById('ml-status'),
        mlHorizon: document.getElementById('ml-horizon'),
        mlEpochs: document.getElementById('ml-epochs'),
        themeToggle: document.getElementById('theme-toggle'),
        tabs: document.querySelectorAll('.tab-button'),
        tabContents: document.querySelectorAll('.tab-content'),
        paperBuyBtn: document.getElementById('paper-buy'),
        paperSellBtn: document.getElementById('paper-sell'),
        tradeAmountInput: document.getElementById('trade-amount'),
        positionsTableBody: document.getElementById('positions-table-body'),
        historyTableBody: document.getElementById('history-table-body'),
        runBacktestBtn: document.getElementById('run-backtest-btn'),
        backtestResults: document.getElementById('backtest-results'),
        backtestBuyThreshold: document.getElementById('backtest-buy-threshold'),
        backtestSellThreshold: document.getElementById('backtest-sell-threshold'),
        toast: document.getElementById('toast'),
    };

    // ========================================================================================================
    // # MODULE: API Handler
    // # Handles fetching data from Binance REST API and WebSocket. Includes caching and error handling.
    // ========================================================================================================
    const API = {
        async fetchKlines(symbol, interval) {
            const cacheKey = `kline_${symbol}_${interval}`;
            const cached = localStorage.getItem(cacheKey);
            if (cached) {
                const { timestamp, data } = JSON.parse(cached);
                if (Date.now() - timestamp < config.cacheTTL) {
                    console.log('Using cached kline data.');
                    return data;
                }
            }
            
            try {
                const url = `${config.binanceApiUrl}/klines?symbol=${symbol}&interval=${interval}&limit=${config.candleLimit}`;
                const response = await fetch(url);
                if (!response.ok) {
                    const errorData = await response.json();
                    if(errorData.code === -1121) { // Invalid symbol
                        throw new Error(`Symbol ${symbol} not found on Binance.`);
                    }
                    throw new Error(`API Error: ${response.statusText} (${response.status})`);
                }
                const data = await response.json();
                const formattedData = data.map(d => ({
                    time: d[0] / 1000,
                    open: parseFloat(d[1]),
                    high: parseFloat(d[2]),
                    low: parseFloat(d[3]),
                    close: parseFloat(d[4]),
                    volume: parseFloat(d[5]),
                }));
                
                localStorage.setItem(cacheKey, JSON.stringify({ timestamp: Date.now(), data: formattedData }));
                return formattedData;
            } catch (error) {
                console.error('Failed to fetch klines:', error);
                UI.showToast(error.message, 'error');
                return null;
            }
        },

        connectWebSocket() {
            if (state.ws) {
                state.ws.close();
            }
            const url = `${config.binanceWsUrl}/${state.currentSymbol.toLowerCase()}@kline_${state.currentInterval}`;
            state.ws = new WebSocket(url);

            state.ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                const candle = msg.k;
                const formattedCandle = {
                    time: candle.t / 1000,
                    open: parseFloat(candle.o),
                    high: parseFloat(candle.h),
                    low: parseFloat(candle.l),
                    close: parseFloat(candle.c),
                    volume: parseFloat(candle.v),
                };
                
                // Update chart, indicators, and UI in real-time
                ChartManager.updateRealtime(formattedCandle);
                UI.updateHeaderPrice(formattedCandle.close, state.klineData[state.klineData.length - 2]?.close);
                
                // If it's a new candle, run analysis, otherwise just update last candle
                if(candle.x) { // is closed candle
                    state.klineData.push(formattedCandle);
                    if(state.klineData.length > config.candleLimit) state.klineData.shift();
                    runFullAnalysis();
                } else {
                     // Live update of current candle
                     state.klineData[state.klineData.length - 1] = formattedCandle;
                     runLightAnalysis(); // Less intensive update
                }
                PaperTrading.updateOpenPositions();
            };

            state.ws.onerror = (error) => {
                console.error('WebSocket Error:', error);
            };
        }
    };
    
    // ========================================================================================================
    // # MODULE: UI Manager
    // # Handles all DOM manipulations, event listeners, and visual feedback.
    // ========================================================================================================
    const UI = {
        init() {
            // Populate selectors
            config.symbols.forEach(symbol => {
                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = symbol;
                dom.symbolSelector.appendChild(option);
            });

            // Populate indicator toolbar
            Object.keys(INDICATOR_DEFS).forEach(name => {
                const button = document.createElement('button');
                button.textContent = name;
                button.dataset.indicator = name;
                dom.indicatorToolbar.appendChild(button);
                button.addEventListener('click', () => this.toggleIndicator(name));
            });

            // Event Listeners
            dom.symbolSelector.addEventListener('change', (e) => Main.changeAsset(e.target.value, state.currentInterval));
            dom.intervalSelector.addEventListener('change', (e) => Main.changeAsset(state.currentSymbol, e.target.value));
            dom.trainModelBtn.addEventListener('click', () => ML.trainModel());
            dom.themeToggle.addEventListener('click', this.toggleTheme);
            dom.tabs.forEach(tab => tab.addEventListener('click', () => this.switchTab(tab.dataset.tab)));
            dom.paperBuyBtn.addEventListener('click', () => PaperTrading.executeTrade('buy'));
            dom.paperSellBtn.addEventListener('click', () => PaperTrading.executeTrade('sell'));
            dom.runBacktestBtn.addEventListener('click', Backtester.run);
            
            // Set initial theme
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
        },
        
        showLoader(isLoading) {
            dom.chartLoader.style.display = isLoading ? 'block' : 'none';
        },
        
        updateHeaderPrice(price, prevClose) {
            const currentPrice = state.klineData.length > 0 ? state.klineData[state.klineData.length-1].close : 0;
            const openPrice = state.klineData.length > 0 ? state.klineData[0].close : 0;
            
            dom.lastPrice.textContent = price.toFixed(price > 100 ? 2 : 4);
            const change = prevClose ? ((price - prevClose) / prevClose) * 100 : 0;
            dom.priceChange.textContent = `${change.toFixed(2)}%`;
            dom.priceChange.className = `change ${change >= 0 ? 'positive' : 'negative'}`;
            document.title = `${price.toFixed(2)} | ${state.currentSymbol} | PTA`;
        },
        
        updateCompositeScore(score, signals) {
            dom.compositeScoreValue.textContent = score.toFixed(2);
            let label, className;
            if (score > 0.5) { label = 'Strong Buy'; className = 'buy'; }
            else if (score > 0.1) { label = 'Buy'; className = 'buy'; }
            else if (score < -0.5) { label = 'Strong Sell'; className = 'sell'; }
            else if (score < -0.1) { label = 'Sell'; className = 'sell'; }
            else { label = 'Neutral'; className = 'neutral'; }
            dom.compositeScoreLabel.textContent = label;
            dom.compositeScoreLabel.className = `score-label ${className}`;
            
            dom.signalList.innerHTML = '';
            if (signals.length > 0) {
                signals.forEach(s => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="signal-name">${s.name}</span><span class="signal-value ${s.type}">${s.type.toUpperCase()}</span>`;
                    dom.signalList.appendChild(li);
                });
            } else {
                dom.signalList.innerHTML = '<li>No active signals</li>';
            }
        },

        toggleIndicator(name) {
            const button = dom.indicatorToolbar.querySelector(`[data-indicator="${name}"]`);
            if (state.activeIndicators.has(name)) {
                state.activeIndicators.delete(name);
                button.classList.remove('active');
                ChartManager.removeIndicator(name);
            } else {
                state.activeIndicators.add(name);
                button.classList.add('active');
                const data = IndicatorCalculator.calculate(name, state.klineData);
                ChartManager.addIndicator(name, data);
            }
        },
        
        toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            ChartManager.applyTheme(newTheme);
        },

        switchTab(tabId) {
            dom.tabContents.forEach(content => content.classList.remove('active'));
            dom.tabs.forEach(tab => tab.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');
        },

        showToast(message, type = 'info') { // type: info, success, error
            dom.toast.textContent = message;
            dom.toast.className = `toast show ${type}`;
            setTimeout(() => {
                dom.toast.className = 'toast';
            }, 3000);
        }
    };

    // ========================================================================================================
    // # MODULE: Chart Manager
    // # Manages the Lightweight Charts instance, including series for candles and indicators.
    // ========================================================================================================
    const ChartManager = {
        init() {
            const theme = localStorage.getItem('theme') || 'dark';
            const chartOptions = {
                width: dom.chartContainer.clientWidth,
                height: dom.chartContainer.clientHeight,
                layout: {
                    background: { color: 'transparent' },
                    textColor: theme === 'dark' ? '#d1d4dc' : '#131722',
                },
                grid: {
                    vertLines: { color: theme === 'dark' ? '#2a2e39' : '#e0e3eb' },
                    horzLines: { color: theme === 'dark' ? '#2a2e39' : '#e0e3eb' },
                },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                rightPriceScale: {
                    borderColor: theme === 'dark' ? '#2a2e39' : '#e0e3eb',
                },
                timeScale: {
                    borderColor: theme === 'dark' ? '#2a2e39' : '#e0e3eb',
                    timeVisible: true,
                    secondsVisible: false,
                },
            };
            state.chart = LightweightCharts.createChart(dom.chartContainer, chartOptions);
            state.candleSeries = state.chart.addCandlestickSeries({
                upColor: '#26a69a', wickUpColor: '#26a69a',
                downColor: '#ef5350', wickDownColor: '#ef5350',
                borderVisible: false,
            });

            new ResizeObserver(this.resize).observe(dom.chartContainer);
        },
        
        resize() {
            if (state.chart && dom.chartContainer.clientWidth > 0) {
                state.chart.resize(dom.chartContainer.clientWidth, dom.chartContainer.clientHeight);
            }
        },

        setData(data) {
            state.candleSeries.setData(data);
            state.chart.timeScale().fitContent();
        },
        
        updateRealtime(candle) {
            state.candleSeries.update(candle);
        },
        
        applyTheme(theme) {
            state.chart.applyOptions({
                layout: {
                    textColor: theme === 'dark' ? '#d1d4dc' : '#131722',
                },
                grid: {
                    vertLines: { color: theme === 'dark' ? '#2a2e39' : '#e0e3eb' },
                    horzLines: { color: theme === 'dark' ? '#2a2e39' : '#e0e3eb' },
                },
            });
        },

        addIndicator(name, data) {
            this.removeIndicator(name);
            const def = INDICATOR_DEFS[name];
            if (!def) return;
            
            state.indicatorSeries[name] = {};

            if (def.type === 'overlay') {
                if(name === 'Bollinger Bands') {
                    state.indicatorSeries[name].upper = state.chart.addLineSeries({ color: 'rgba(76, 175, 80, 0.5)', lineWidth: 1, priceLineVisible: false });
                    state.indicatorSeries[name].middle = state.chart.addLineSeries({ color: 'rgba(255, 205, 210, 0.5)', lineWidth: 1, priceLineVisible: false });
                    state.indicatorSeries[name].lower = state.chart.addLineSeries({ color: 'rgba(76, 175, 80, 0.5)', lineWidth: 1, priceLineVisible: false });
                    state.indicatorSeries[name].upper.setData(data.map(d => ({time: d.time, value: d.upper})));
                    state.indicatorSeries[name].middle.setData(data.map(d => ({time: d.time, value: d.middle})));
                    state.indicatorSeries[name].lower.setData(data.map(d => ({time: d.time, value: d.lower})));
                } else {
                    state.indicatorSeries[name].main = state.chart.addLineSeries({ color: '#2962ff', lineWidth: 2 });
                    state.indicatorSeries[name].main.setData(data);
                }
            } else if (def.type === 'pane') {
                 const pane = state.chart.addHistogramSeries({
                    priceFormat: { type: 'volume' },
                    priceScaleId: name,
                });
                pane.setData(data);
                state.indicatorSeries[name].pane = pane;
            }
        },

        removeIndicator(name) {
            if (state.indicatorSeries[name]) {
                Object.values(state.indicatorSeries[name]).forEach(series => state.chart.removeSeries(series));
                delete state.indicatorSeries[name];
            }
        },

        showPredictions(predictions) {
            // Visualize predictions on chart
            // For simplicity, let's just log them for now
            console.log("ML Predictions:", predictions);
            UI.showToast(`Model predicted next price: ${predictions[0].value.toFixed(2)}`, 'info');
        }
    };

    // ========================================================================================================
    // # MODULE: Indicator Calculator
    // # Uses the technicalindicators library to compute values for various indicators.
    // ========================================================================================================
    const IndicatorCalculator = {
        calculateAll(data) {
            const indicators = {};
            const closePrices = data.map(d => d.close);
            const highPrices = data.map(d => d.high);
            const lowPrices = data.map(d => d.low);
            const volumes = data.map(d => d.volume);
            
            // Calculate a few key indicators for the signal engine
            indicators.rsi14 = technicalindicators.rsi({ period: 14, values: closePrices });
            indicators.macd12_26_9 = technicalindicators.macd({
                values: closePrices,
                fastPeriod: 12,
                slowPeriod: 26,
                signalPeriod: 9,
                SimpleMAOscillator: false,
                SimpleMASignal: false
            });
            indicators.ema20 = technicalindicators.ema({ period: 20, values: closePrices });
            indicators.ema50 = technicalindicators.ema({ period: 50, values: closePrices });
            
            return indicators;
        },

        calculate(name, data) {
            const closes = data.map(d => d.close);
            const def = INDICATOR_DEFS[name];
            if (!def) return [];

            let result;
            if(name === 'SMA' || name === 'EMA') {
                const period = def.params[0].default;
                result = technicalindicators[name.toLowerCase()]({period, values: closes});
            }
            if(name === 'Bollinger Bands') {
                result = technicalindicators.bollingerbands({period: 20, stdDev: 2, values: closes});
            }
            // Add more indicator calculations here...

            // Format for chart
            if(Array.isArray(result) && typeof result[0] === 'number') {
                return data.slice(data.length - result.length).map((d, i) => ({ time: d.time, value: result[i] }));
            }
             if(Array.isArray(result) && typeof result[0] === 'object') {
                return data.slice(data.length - result.length).map((d, i) => ({ time: d.time, ...result[i] }));
            }
            
            return [];
        }
    };
    
    // ========================================================================================================
    // # MODULE: Signal Engine
    // # Generates buy/sell signals based on indicator values and computes a composite score.
    // ========================================================================================================
    const SignalEngine = {
        getCompositeScore(data, indicators) {
            if (indicators.rsi14.length === 0) return { score: 0, signals: [] };

            let score = 0;
            const signals = [];
            const lastCandle = data[data.length - 1];
            const prevCandle = data[data.length - 2];

            // RSI
            const lastRSI = indicators.rsi14[indicators.rsi14.length - 1];
            if (lastRSI < 30) { score += 1; signals.push({ name: 'RSI(14)', type: 'buy' }); }
            if (lastRSI > 70) { score -= 1; signals.push({ name: 'RSI(14)', type: 'sell' }); }

            // MACD
            const lastMACD = indicators.macd12_26_9[indicators.macd12_26_9.length - 1];
            const prevMACD = indicators.macd12_26_9[indicators.macd12_26_9.length - 2];
            if (prevMACD.MACD < prevMACD.signal && lastMACD.MACD > lastMACD.signal) {
                score += 1.5; signals.push({ name: 'MACD Cross', type: 'buy' });
            }
            if (prevMACD.MACD > prevMACD.signal && lastMACD.MACD < lastMACD.signal) {
                score -= 1.5; signals.push({ name: 'MACD Cross', type: 'sell' });
            }

            // EMA Cross
            const lastEMA20 = indicators.ema20[indicators.ema20.length - 1];
            const lastEMA50 = indicators.ema50[indicators.ema50.length - 1];
            if (lastCandle.close > lastEMA50) { score += 0.5; signals.push({ name: 'Price > EMA(50)', type: 'buy'}); }
            if (lastCandle.close < lastEMA50) { score -= 0.5; signals.push({ name: 'Price < EMA(50)', type: 'sell'}); }
            if (lastEMA20 > lastEMA50) { score += 0.5; }
            if (lastEMA20 < lastEMA50) { score -= 0.5; }

            // Normalize score
            const maxScore = 4.5; // Sum of max absolute weights
            const normalizedScore = Math.max(-1, Math.min(1, score / maxScore));
            
            return { score: normalizedScore, signals };
        }
    };

    // ========================================================================================================
    // # MODULE: Machine Learning
    // # Handles in-browser model training and prediction with TensorFlow.js.
    // ========================================================================================================
    const ML = {
        async trainModel() {
            if (state.isTraining) {
                UI.showToast('Training is already in progress.', 'info');
                return;
            }
            state.isTraining = true;
            dom.trainModelBtn.disabled = true;
            dom.mlStatus.textContent = 'Preparing data...';

            try {
                // Feature engineering
                const features = state.klineData.map(d => [
                    d.open, d.high, d.low, d.close, d.volume
                ]).slice(50); // Remove early data points where indicators are not stable
                
                if(features.length < 100) {
                    throw new Error("Not enough historical data to train the model. Need at least 100 candles.");
                }

                // Normalize data
                const { normalized, min, max } = this.normalize(features);

                const sequenceLength = 60;
                const horizon = parseInt(dom.mlHorizon.value, 10);
                const { X, y } = this.createSequences(normalized, sequenceLength, horizon);
                
                if(!X || X.length === 0) {
                    throw new Error("Could not create training sequences from the available data.");
                }

                const X_tensor = tf.tensor3d(X, [X.length, sequenceLength, 5]);
                const y_tensor = tf.tensor2d(y, [y.length, 1]);

                // Define model
                state.mlModel = tf.sequential();
                state.mlModel.add(tf.layers.lstm({ units: 50, returnSequences: true, inputShape: [sequenceLength, 5] }));
                state.mlModel.add(tf.layers.dropout(0.2));
                state.mlModel.add(tf.layers.lstm({ units: 50 }));
                state.mlModel.add(tf.layers.dropout(0.2));
                state.mlModel.add(tf.layers.dense({ units: 1 }));

                state.mlModel.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

                // Train model
                const epochs = parseInt(dom.mlEpochs.value, 10);
                dom.mlStatus.textContent = `Training... Epoch 1/${epochs}`;
                await state.mlModel.fit(X_tensor, y_tensor, {
                    epochs: epochs,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            dom.mlStatus.textContent = `Training... Epoch ${epoch + 1}/${epochs} | Loss: ${logs.loss.toFixed(4)}`;
                        }
                    }
                });
                
                // Store normalization stats
                state.mlModel.normalizationStats = { min, max };
                
                UI.showToast('Model training complete!', 'success');
                dom.mlStatus.textContent = 'Model trained. Ready to predict.';
                await this.predict();
            } catch (error) {
                console.error("ML Training Error:", error);
                UI.showToast(error.message, 'error');
                dom.mlStatus.textContent = `Error: ${error.message}`;
            } finally {
                state.isTraining = false;
                dom.trainModelBtn.disabled = false;
            }
        },

        async predict() {
            if (!state.mlModel) {
                UI.showToast('Train a model first before predicting.', 'error');
                return;
            }
            
            const horizon = parseInt(dom.mlHorizon.value, 10);
            const sequenceLength = 60;
            const lastSequenceRaw = state.klineData.slice(-sequenceLength).map(d => [d.open, d.high, d.low, d.close, d.volume]);

            const { min, max } = state.mlModel.normalizationStats;
            const lastSequenceNormalized = lastSequenceRaw.map(row => 
                row.map((val, i) => (val - min[i]) / (max[i] - min[i]))
            );

            const inputTensor = tf.tensor3d([lastSequenceNormalized]);
            const predictionTensor = state.mlModel.predict(inputTensor);
            const predictionNormalized = await predictionTensor.data();
            
            // Denormalize prediction (we care about the close price, index 3)
            const predictedClose = predictionNormalized[0] * (max[3] - min[3]) + min[3];

            // For multi-step, this needs a loop and feeding predictions back in
            // For simplicity, we show a single prediction for now.
            const lastTime = state.klineData[state.klineData.length - 1].time;
            const intervalSeconds = this.getIntervalSeconds(state.currentInterval);
            const predictionTime = lastTime + (horizon * intervalSeconds);
            
            const predictionData = [{ time: predictionTime, value: predictedClose }];
            
            ChartManager.showPredictions(predictionData);
        },
        
        // Helper functions for ML
        normalize(data) {
            const arr = tf.tensor2d(data);
            const min = arr.min(0);
            const max = arr.max(0);
            const normalized = arr.sub(min).div(max.sub(min));
            return { normalized: normalized.arraySync(), min: min.arraySync(), max: max.arraySync() };
        },
        
        createSequences(data, seqLength, horizon) {
            const X = [];
            const y = [];
            for (let i = 0; i < data.length - seqLength - horizon + 1; i++) {
                X.push(data.slice(i, i + seqLength));
                y.push(data[i + seqLength + horizon - 1][3]); // Predicting the 'close' price
            }
            return { X, y };
        },

        getIntervalSeconds(interval) {
            const unit = interval.slice(-1);
            const value = parseInt(interval.slice(0, -1));
            if (unit === 'm') return value * 60;
            if (unit === 'h') return value * 60 * 60;
            if (unit === 'd') return value * 24 * 60 * 60;
            return 0;
        }
    };
    
    // ========================================================================================================
    // # MODULE: Paper Trading
    // # Simulates trading based on user actions, tracks positions and history.
    // ========================================================================================================
    const PaperTrading = {
        init() {
            const savedTrades = localStorage.getItem('paperTrades');
            if (savedTrades) {
                state.paperTrades = JSON.parse(savedTrades);
            }
            this.renderTables();
        },

        executeTrade(side) {
            const amount = parseFloat(dom.tradeAmountInput.value);
            if (isNaN(amount) || amount <= 0) {
                UI.showToast('Please enter a valid trade amount.', 'error');
                return;
            }
            
            const currentPrice = state.klineData[state.klineData.length - 1].close;
            const quantity = amount / currentPrice;

            if (side === 'buy') {
                const position = {
                    id: Date.now(),
                    symbol: state.currentSymbol,
                    side: 'long',
                    amount,
                    quantity,
                    entryPrice: currentPrice,
                };
                state.paperTrades.positions.push(position);
            } else { // sell
                 const position = {
                    id: Date.now(),
                    symbol: state.currentSymbol,
                    side: 'short',
                    amount,
                    quantity,
                    entryPrice: currentPrice,
                };
                state.paperTrades.positions.push(position);
            }
            
            const historyEntry = {
                time: new Date().toISOString(),
                symbol: state.currentSymbol,
                side,
                amount,
                price: currentPrice
            };
            state.paperTrades.history.unshift(historyEntry);
            
            this.saveAndRender();
            UI.showToast(`${side.toUpperCase()} order for ${amount} USDT filled.`, 'success');
        },

        closePosition(positionId) {
            const index = state.paperTrades.positions.findIndex(p => p.id === positionId);
            if(index === -1) return;

            const position = state.paperTrades.positions[index];
            state.paperTrades.positions.splice(index, 1);
            
            const currentPrice = state.klineData.find(k => k.symbol === position.symbol)?.close || state.klineData[state.klineData.length-1].close;
            const historyEntry = {
                time: new Date().toISOString(),
                symbol: position.symbol,
                side: `close ${position.side}`,
                amount: position.amount,
                price: currentPrice
            };
            state.paperTrades.history.unshift(historyEntry);
            this.saveAndRender();
        },

        updateOpenPositions() {
             const currentPrice = state.klineData[state.klineData.length - 1].close;
             if(state.paperTrades.positions.length > 0) {
                 this.renderTables(currentPrice);
             }
        },

        renderTables(currentPrice) {
            // Positions
            dom.positionsTableBody.innerHTML = '';
            state.paperTrades.positions.forEach(pos => {
                const price = (pos.symbol === state.currentSymbol) ? currentPrice : pos.entryPrice; // Simplified
                let pnl = 0;
                if (pos.side === 'long') {
                    pnl = (price - pos.entryPrice) * pos.quantity;
                } else {
                    pnl = (pos.entryPrice - price) * pos.quantity;
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${pos.symbol}</td>
                    <td>${pos.side}</td>
                    <td>${pos.amount.toFixed(2)}</td>
                    <td>${pos.entryPrice.toFixed(4)}</td>
                    <td>${price ? price.toFixed(4) : '-'}</td>
                    <td style="color: ${pnl >= 0 ? 'var(--green)' : 'var(--red)'}">${pnl.toFixed(2)} (${(pnl/pos.amount*100).toFixed(2)}%)</td>
                    <td><button class="close-pos-btn" data-id="${pos.id}">Close</button></td>
                `;
                dom.positionsTableBody.appendChild(row);
            });
            
            document.querySelectorAll('.close-pos-btn').forEach(btn => {
                btn.addEventListener('click', (e) => this.closePosition(parseInt(e.target.dataset.id, 10)));
            });

            // History
            dom.historyTableBody.innerHTML = '';
            state.paperTrades.history.slice(0, 100).forEach(trade => { // Limit history display
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${new Date(trade.time).toLocaleString()}</td>
                    <td>${trade.symbol}</td>
                    <td>${trade.side}</td>
                    <td>${trade.amount.toFixed(2)}</td>
                    <td>${trade.price.toFixed(4)}</td>
                `;
                dom.historyTableBody.appendChild(row);
            });
        },

        saveAndRender() {
            localStorage.setItem('paperTrades', JSON.stringify(state.paperTrades));
            this.renderTables(state.klineData[state.klineData.length-1].close);
        }
    };
    
    // ========================================================================================================
    // # MODULE: Backtester
    // # Runs a simple strategy over historical data and provides performance metrics.
    // ========================================================================================================
    const Backtester = {
        run() {
            const buyThreshold = parseFloat(dom.backtestBuyThreshold.value);
            const sellThreshold = parseFloat(dom.backtestSellThreshold.value);

            let inPosition = false;
            let entryPrice = 0;
            let trades = [];
            let balance = 10000;
            const initialBalance = balance;

            for (let i = 50; i < state.klineData.length; i++) {
                const historicalData = state.klineData.slice(0, i + 1);
                const indicators = IndicatorCalculator.calculateAll(historicalData);
                const { score } = SignalEngine.getCompositeScore(historicalData, indicators);

                if (!inPosition && score > buyThreshold) {
                    inPosition = true;
                    entryPrice = historicalData[historicalData.length - 1].close;
                } else if (inPosition && score < sellThreshold) {
                    inPosition = false;
                    const exitPrice = historicalData[historicalData.length - 1].close;
                    const pnl = (exitPrice - entryPrice) / entryPrice;
                    trades.push(pnl);
                    balance *= (1 + pnl);
                }
            }

            this.displayResults(trades, balance, initialBalance);
        },

        displayResults(trades, finalBalance, initialBalance) {
            const totalTrades = trades.length;
            if (totalTrades === 0) {
                dom.backtestResults.innerHTML = '<p>No trades were executed with the current settings.</p>';
                return;
            }

            const wins = trades.filter(t => t > 0).length;
            const winRate = (wins / totalTrades * 100).toFixed(2);
            const totalReturn = ((finalBalance - initialBalance) / initialBalance * 100).toFixed(2);
            
            dom.backtestResults.innerHTML = `
                <h4>Backtest Results</h4>
                <p>Total Trades: <strong>${totalTrades}</strong></p>
                <p>Win Rate: <strong>${winRate}%</strong></p>
                <p>Total Return: <strong style="color: ${totalReturn >= 0 ? 'var(--green)' : 'var(--red)'}">${totalReturn}%</strong></p>
                <p>Final Balance: <strong>$${finalBalance.toFixed(2)}</strong></p>
            `;
        }
    };

    // ========================================================================================================
    // # MAIN APPLICATION LOGIC & INITIALIZATION
    // ========================================================================================================
    const Main = {
        async init() {
            UI.init();
            ChartManager.init();
            PaperTrading.init();
            
            const initialSymbol = localStorage.getItem('lastSymbol') || 'BTCUSDT';
            const initialInterval = localStorage.getItem('lastInterval') || '15m';
            dom.symbolSelector.value = initialSymbol;
            dom.intervalSelector.value = initialInterval;

            await this.changeAsset(initialSymbol, initialInterval);
        },

        async changeAsset(symbol, interval) {
            UI.showLoader(true);
            state.currentSymbol = symbol;
            state.currentInterval = interval;
            localStorage.setItem('lastSymbol', symbol);
            localStorage.setItem('lastInterval', interval);
            
            document.title = `${symbol} | PTA`;

            const klineData = await API.fetchKlines(symbol, interval);
            
            if (klineData && klineData.length > 0) {
                state.klineData = klineData;
                ChartManager.setData(state.klineData);
                API.connectWebSocket();
                runFullAnalysis();
            } else {
                 state.klineData = [];
                 ChartManager.setData([]);
                 UI.showToast(`Could not load data for ${symbol}. It might not be listed on Binance.`, 'error');
            }

            UI.showLoader(false);
        }
    };

    function runFullAnalysis() {
        if (state.klineData.length < 50) return;
        const indicators = IndicatorCalculator.calculateAll(state.klineData);
        const { score, signals } = SignalEngine.getCompositeScore(state.klineData, indicators);
        UI.updateCompositeScore(score, signals);
        
        // Update any active indicator overlays
        state.activeIndicators.forEach(name => {
             const data = IndicatorCalculator.calculate(name, state.klineData);
             ChartManager.addIndicator(name, data);
        });
    }

    function runLightAnalysis() {
        // A less computationally expensive update for real-time ticks
        if (state.klineData.length < 50) return;
        // Could be optimized to only recalculate last few values of indicators
        runFullAnalysis(); // For simplicity, re-run full analysis
    }

    // --- Let's Go! ---
    document.addEventListener('DOMContentLoaded', () => Main.init());

})();
</script>
</body>
</html>
