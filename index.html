<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Crypto Prediction Model</title>
    
    <script src="https://cdn.jsdelivr.net/npm/tensorflow@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.3/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://unpkg.com/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.min.js"></script>
    <script src="httpshttps://unpkg.com/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>

    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-text: #e0e0e0;
            --secondary-text: #b0b0b0;
            --border-color: #333;
            --accent-color: #00bcd4;
            --success-color: #4caf50;
            --danger-color: #f44336;
            --card-bg: #2c2c2c;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            height: 95vh;
        }
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            height: 100%;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            height: 100%;
        }
        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
        }
        h1, h2, h3 {
            color: var(--primary-text);
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
            margin-top: 0;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        button {
            background-color: var(--accent-color);
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s, transform 0.1s;
        }
        button:hover {
            background-color: #0097a7;
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .log-console {
            flex-grow: 1;
            background-color: #111;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: var(--secondary-text);
            white-space: pre-wrap;
        }
        .log-console .log-entry { margin-bottom: 5px; }
        .log-console .info { color: #87ceeb; }
        .log-console .success { color: var(--success-color); }
        .log-console .error { color: var(--danger-color); }
        .log-console .warn { color: #ffa500; }
        .chart-container {
            position: relative;
            flex-grow: 1;
        }
        #predictionTable {
            width: 100%;
            border-collapse: collapse;
        }
        #predictionTable th, #predictionTable td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        #predictionTable th { color: var(--accent-color); }
        .buy { color: var(--success-color); }
        .sell { color: var(--danger-color); }
        .hold { color: var(--secondary-text); }
    </style>
</head>
<body>

    <div class="container">
        <div class="main-content">
            <div class="card">
                <h1>WIF/USDT Advanced Prediction Model</h1>
                <p>An upgraded client-side system using multi-timeframe data, advanced features, and walk-forward validation for improved time-series forecasting.</p>
            </div>
            <div class="card chart-container">
                <canvas id="candleChart"></canvas>
            </div>
        </div>

        <div class="sidebar">
            <div class="card controls">
                <button id="fetchDataBtn">1. Fetch Market Data</button>
                <button id="trainModelsBtn" disabled>2. Train Models (Walk-Forward)</button>
                <button id="predictNextBtn" disabled>3. Predict Next Candle</button>
            </div>
            <div class="card">
                <h2>Live Prediction</h2>
                <table id="predictionTable">
                    <thead>
                        <tr><th>Model</th><th>Prediction</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>MLP</td><td id="mlpPred">-</td></tr>
                        <tr><td>LSTM</td><td id="lstmPred">-</td></tr>
                        <tr><td><b>Ensemble</b></td><td id="ensemblePred">-</td></tr>
                        <tr><td><b>Signal</b></td><td id="finalSignal">-</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="card" style="flex-grow: 1;">
                <h2>Log Console</h2>
                <div class="log-console" id="logConsole"></div>
            </div>
        </div>
    </div>

<script>
// ===================================================================================
// 0. CONFIGURATION & GLOBAL STATE
// ===================================================================================
const CONFIG = {
    // API & Data
    symbol: 'WIFUSDT',
    interval: '1m',
    limit: 5000, // Increased data depth
    binanceApiUrl: 'https://api.binance.com/api/v3/klines',
    
    // Feature Engineering
    predictionHorizon: 5, // Predict close price 5 minutes from now
    sequenceLength: 60, // Use last 60 minutes of data to predict
    multiTimeframes: [5, 15], // Aggregate 1m data into 5m and 15m
    
    // Model Training
    trainTestSplit: 0.8,
    walkForwardSteps: 100, // How many steps to backtest in walk-forward validation
    retrainFrequency: 20, // Retrain the model every 20 new candles
    epochs: 10,
    batchSize: 32,
    learningRate: 0.001,

    // Signal Generation
    signalThreshold: 0.0015, // 0.15% predicted price change to trigger a signal
    volatilityFilterThreshold: 0.001, // Minimum rolling volatility to consider a signal
};

let rawData = [];
let features = [];
let labels = [];
let chart = null;
let models = { mlp: null, lstm: null };
let modelWeights = { mlp: 0.5, lstm: 0.5 }; // Ensemble weights
let scaler = null;

// UI Elements
const fetchDataBtn = document.getElementById('fetchDataBtn');
const trainModelsBtn = document.getElementById('trainModelsBtn');
const predictNextBtn = document.getElementById('predictNextBtn');
const logConsole = document.getElementById('logConsole');

// ===================================================================================
// 1. LOGGING & UI UTILITIES
// ===================================================================================
function log(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `[${timestamp}] ${message}`;
    logConsole.appendChild(entry);
    logConsole.scrollTop = logConsole.scrollHeight;
}

function setButtonsState(isLoading) {
    fetchDataBtn.disabled = isLoading;
    trainModelsBtn.disabled = isLoading || rawData.length === 0;
    predictNextBtn.disabled = isLoading || !models.mlp || !models.lstm;
}

// ===================================================================================
// 2. DATA FETCHING & PREPARATION
// ===================================================================================
async function fetchData() {
    setButtonsState(true);
    log(`Fetching ${CONFIG.limit} candles for ${CONFIG.symbol}...`);
    try {
        const response = await fetch(`${CONFIG.binanceApiUrl}?symbol=${CONFIG.symbol}&interval=${CONFIG.interval}&limit=${Math.min(CONFIG.limit, 1500)}`);
        if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
        const data = await response.json();
        
        rawData = data.map(d => ({
            time: d[0] / 1000,
            open: parseFloat(d[1]),
            high: parseFloat(d[2]),
            low: parseFloat(d[3]),
            close: parseFloat(d[4]),
            volume: parseFloat(d[5]),
        }));
        
        log(`Successfully fetched ${rawData.length} data points.`, 'success');
        await processData();
        initializeChart();
        setButtonsState(false);

    } catch (error) {
        log(`Failed to fetch data: ${error.message}`, 'error');
        setButtonsState(false);
    }
}

function aggregateTimeframe(data, minutes) {
    const aggregated = [];
    let currentCandle = null;

    for (const candle of data) {
        const candleTime = luxon.DateTime.fromSeconds(candle.time);
        const startOfInterval = candleTime.startOf('minute').minus({ minutes: candleTime.minute % minutes });

        if (!currentCandle || currentCandle.time !== startOfInterval.toSeconds()) {
            if (currentCandle) aggregated.push(currentCandle);
            currentCandle = {
                time: startOfInterval.toSeconds(),
                open: candle.open,
                high: candle.high,
                low: candle.low,
                close: candle.close,
                volume: candle.volume,
            };
        } else {
            currentCandle.high = Math.max(currentCandle.high, candle.high);
            currentCandle.low = Math.min(currentCandle.low, candle.low);
            currentCandle.close = candle.close;
            currentCandle.volume += candle.volume;
        }
    }
    if (currentCandle) aggregated.push(currentCandle);
    return aggregated;
}

// ===================================================================================
// 3. TECHNICAL INDICATORS & FEATURE ENGINEERING
// ===================================================================================
const Indicators = {
    ema: (data, period) => {
        const k = 2 / (period + 1);
        let ema = data.slice(0, period).reduce((sum, d) => sum + d.close, 0) / period;
        const emas = Array(period - 1).fill(null);
        emas.push(ema);
        for (let i = period; i < data.length; i++) {
            ema = (data[i].close * k) + (ema * (1 - k));
            emas.push(ema);
        }
        return emas;
    },
    rsi: (data, period) => {
        const rsis = Array(period).fill(null);
        let gains = 0, losses = 0;
        for (let i = 1; i <= period; i++) {
            const change = data[i].close - data[i-1].close;
            change > 0 ? gains += change : losses -= change;
        }
        let avgGain = gains / period;
        let avgLoss = losses / period;

        for (let i = period + 1; i < data.length; i++) {
            const change = data[i].close - data[i-1].close;
            gains = change > 0 ? change : 0;
            losses = change < 0 ? -change : 0;
            avgGain = (avgGain * (period - 1) + gains) / period;
            avgLoss = (avgLoss * (period - 1) + losses) / period;
            if (avgLoss === 0) {
                rsis.push(100);
            } else {
                const rs = avgGain / avgLoss;
                rsis.push(100 - (100 / (1 + rs)));
            }
        }
        return rsis;
    },
    vwap: (data) => {
        let cumulativeTPV = 0;
        let cumulativeVolume = 0;
        return data.map(d => {
            const typicalPrice = (d.high + d.low + d.close) / 3;
            cumulativeTPV += typicalPrice * d.volume;
            cumulativeVolume += d.volume;
            return cumulativeVolume > 0 ? cumulativeTPV / cumulativeVolume : typicalPrice;
        });
    },
    bollingerBands: (data, period, stdDev) => {
        const bands = Array(period - 1).fill(null);
        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1);
            const closes = slice.map(d => d.close);
            const sma = closes.reduce((a, b) => a + b) / period;
            const std = Math.sqrt(closes.map(c => Math.pow(c - sma, 2)).reduce((a, b) => a + b) / period);
            bands.push({
                middle: sma,
                upper: sma + std * stdDev,
                lower: sma - std * stdDev,
                percentB: (data[i].close - (sma - std * stdDev)) / ((sma + std * stdDev) - (sma - std * stdDev))
            });
        }
        return bands;
    },
};

async function processData() {
    log('Starting feature engineering...');
    const data = [...rawData];

    // 1. Multi-Timeframe Data Aggregation
    const data5m = aggregateTimeframe(data, 5);
    const data15m = aggregateTimeframe(data, 15);
    log(`Aggregated data: ${data5m.length} (5m), ${data15m.length} (15m) candles.`);

    // 2. Calculate Indicators on base timeframe (1m)
    const ema12 = Indicators.ema(data, 12);
    const ema26 = Indicators.ema(data, 26);
    const rsi14 = Indicators.rsi(data, 14);
    const vwap = Indicators.vwap(data);
    const bb20 = Indicators.bollingerBands(data, 20, 2);

    // 3. Create a unified feature set
    let processed = data.map((d, i) => ({
        ...d,
        ema12: ema12[i],
        ema26: ema26[i],
        rsi14: rsi14[i],
        vwap: vwap[i],
        bb_upper: bb20[i]?.upper,
        bb_lower: bb20[i]?.lower,
        bb_percentB: bb20[i]?.percentB,
    }));
    
    // 4. Align and add multi-timeframe features
    // This is a simple alignment. More complex methods could be used.
    function alignData(base, featureData) {
        let featureIndex = 0;
        return base.map(d => {
            while(featureData[featureIndex + 1] && featureData[featureIndex + 1].time <= d.time) {
                featureIndex++;
            }
            return featureData[featureIndex];
        });
    }

    const aligned5m = alignData(processed, aggregateTimeframe(data, 5));
    const aligned15m = alignData(processed, aggregateTimeframe(data, 15));
    const rsi5m = Indicators.rsi(aligned5m, 14);
    const rsi15m = Indicators.rsi(aligned15m, 14);

    // 5. Build the final feature vector for each time step
    const featureSet = [];
    const labelSet = [];
    const minLength = 100; // Ensure we have enough data for lookbacks

    for (let i = minLength; i < processed.length - CONFIG.predictionHorizon; i++) {
        const current = processed[i];
        if ([current.ema12, current.rsi14, current.bb_upper, rsi5m[i], rsi15m[i]].some(v => v === null || v === undefined)) {
            continue; // Skip if any indicator is not ready
        }
        
        // --- Advanced Feature Creation ---
        const featureVector = [
            // Price-based features
            (current.close - current.open) / current.open, // Pct change in candle
            (current.high - current.low) / current.low,   // Volatility in candle
            
            // Returns (Multi-horizon)
            (current.close / processed[i-1].close) - 1,
            (current.close / processed[i-5].close) - 1,
            (current.close / processed[i-15].close) - 1,
            (current.close / processed[i-60].close) - 1,

            // Indicator-based features
            (current.ema12 - current.ema26) / current.ema26, // MACD-like
            current.rsi14 / 100,
            (current.close - current.vwap) / current.vwap, // VWAP distance
            current.bb_percentB, // Position within Bollinger Bands

            // Multi-Timeframe features
            rsi5m[i] / 100,
            rsi15m[i] / 100,

            // Volatility features (Rolling Std Dev of returns)
            tf.moments(processed.slice(i-20, i).map(p => (p.close / p.open) - 1)).variance,
            
            // Simulated Market Microstructure (Order Book Imbalance)
            // A simple proxy: High volume on up-candle vs down-candle
            (current.close > current.open ? 1 : -1) * current.volume / processed[i-1].volume,
        ];

        featureSet.push(featureVector);
        
        // The label is the future percent change
        const futurePrice = processed[i + CONFIG.predictionHorizon].close;
        const label = (futurePrice - current.close) / current.close;
        labelSet.push(label);
    }
    
    // 6. Normalization
    const featuresTensor = tf.tensor2d(featureSet);
    const mean = featuresTensor.mean(0);
    const std = tf.moments(featuresTensor, 0).variance.sqrt();
    scaler = { mean, std }; // Save for later use on new data
    const normalizedFeatures = featuresTensor.sub(mean).div(std);

    features = await normalizedFeatures.array();
    labels = labelSet;
    
    log(`Feature engineering complete. Created ${features.length} feature vectors.`, 'success');
}


// ===================================================================================
// 4. MODEL DEFINITION & TRAINING
// ===================================================================================

function createMLPModel(inputShape) {
    const model = tf.sequential();
    model.add(tf.layers.dense({ inputShape: [inputShape], units: 128, activation: 'relu' }));
    model.add(tf.layers.dropout({ rate: 0.3 }));
    model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
    model.add(tf.layers.dropout({ rate: 0.3 }));
    model.add(tf.layers.dense({ units: 1, activation: 'linear' })); // Linear activation for regression
    
    model.compile({
        optimizer: tf.train.adam(CONFIG.learningRate),
        loss: 'meanSquaredError' // MSE is standard for regression
    });
    return model;
}

function createLSTMModel(inputShape) {
    const model = tf.sequential();
    // LSTM is designed for sequences [timesteps, features]
    model.add(tf.layers.lstm({ 
        units: 64, 
        inputShape: [inputShape[0], inputShape[1]], 
        returnSequences: true 
    }));
    model.add(tf.layers.dropout({ rate: 0.3 }));
    model.add(tf.layers.lstm({ units: 32, returnSequences: false }));
    model.add(tf.layers.dropout({ rate: 0.3 }));
    model.add(tf.layers.dense({ units: 1, activation: 'linear' }));

    model.compile({
        optimizer: tf.train.adam(CONFIG.learningRate),
        loss: 'meanSquaredError'
    });
    return model;
    /* **NOTE on where a Transformer would go:**
    A Transformer model would replace the LSTM layers. It would involve creating custom
    layers for multi-head self-attention and positional encoding. This is significantly
    more complex but can be more powerful for capturing long-range dependencies.
    Due to the complexity, LSTM is a more practical choice for a browser environment.
    */
}

function prepareDataForModel(modelType, X, Y) {
    if (modelType === 'mlp') {
        return { X_train: tf.tensor2d(X), Y_train: tf.tensor1d(Y) };
    }
    if (modelType === 'lstm') {
        // Create sequences for LSTM
        const X_seq = [], Y_seq = [];
        for (let i = 0; i < X.length - CONFIG.sequenceLength; i++) {
            X_seq.push(X.slice(i, i + CONFIG.sequenceLength));
            Y_seq.push(Y[i + CONFIG.sequenceLength - 1]);
        }
        return { 
            X_train: tf.tensor3d(X_seq), 
            Y_train: tf.tensor1d(Y_seq) 
        };
    }
}

async function trainModelsWalkForward() {
    setButtonsState(true);
    log('Starting Walk-Forward Validation training...');

    /*
    **NOTE on Walk-Forward Validation:**
    A true backtest would loop from `splitIndex` to the end, training and predicting one step at a time.
    This is too slow for a browser. This implementation simulates it by performing ONE walk-forward
    training run on the most recent data block. A real backend would run the full loop.
    */
    
    const splitIndex = Math.floor(features.length * CONFIG.trainTestSplit);
    const X_train_full = features.slice(0, splitIndex);
    const Y_train_full = labels.slice(0, splitIndex);
    const X_test = features.slice(splitIndex);
    const Y_test = labels.slice(splitIndex);

    // --- Train MLP ---
    log('Training MLP model...');
    const mlpData = prepareDataForModel('mlp', X_train_full, Y_train_full);
    models.mlp = createMLPModel(features[0].length);
    await models.mlp.fit(mlpData.X_train, mlpData.Y_train, {
        epochs: CONFIG.epochs,
        batchSize: CONFIG.batchSize,
        callbacks: { onEpochEnd: (epoch, logs) => log(`MLP Epoch ${epoch+1}: loss = ${logs.loss.toFixed(6)}`) }
    });
    log('MLP training complete.', 'success');
    
    // --- Train LSTM ---
    log('Training LSTM model...');
    const lstmData = prepareDataForModel('lstm', X_train_full, Y_train_full);
    models.lstm = createLSTMModel([CONFIG.sequenceLength, features[0].length]);
    await models.lstm.fit(lstmData.X_train, lstmData.Y_train, {
        epochs: CONFIG.epochs,
        batchSize: CONFIG.batchSize,
        callbacks: { onEpochEnd: (epoch, logs) => log(`LSTM Epoch ${epoch+1}: loss = ${logs.loss.toFixed(6)}`) }
    });
    log('LSTM training complete.', 'success');
    
    // --- Evaluate and set ensemble weights ---
    log('Evaluating models to set ensemble weights...');
    await evaluateAndWeightModels(X_test, Y_test);

    setButtonsState(false);
}

async function evaluateAndWeightModels(X_test, Y_test) {
    // MLP Evaluation
    const mlpTestData = prepareDataForModel('mlp', X_test, Y_test);
    const mlpPreds = models.mlp.predict(mlpTestData.X_train);
    const mlpError = tf.losses.meanSquaredError(mlpTestData.Y_train, mlpPreds.reshape([-1])).dataSync()[0];
    log(`MLP Test RMSE: ${Math.sqrt(mlpError).toFixed(6)}`);

    // LSTM Evaluation
    const lstmTestData = prepareDataForModel('lstm', X_test, Y_test);
    const lstmPreds = models.lstm.predict(lstmTestData.X_train);
    const lstmError = tf.losses.meanSquaredError(lstmTestData.Y_train, lstmPreds.reshape([-1])).dataSync()[0];
    log(`LSTM Test RMSE: ${Math.sqrt(lstmError).toFixed(6)}`);

    // Performance-weighted ensembling
    const mlpPerf = 1 / mlpError;
    const lstmPerf = 1 / lstmError;
    const totalPerf = mlpPerf + lstmPerf;
    modelWeights.mlp = mlpPerf / totalPerf;
    modelWeights.lstm = lstmPerf / totalPerf;

    log(`Ensemble weights set: MLP=${modelWeights.mlp.toFixed(2)}, LSTM=${modelWeights.lstm.toFixed(2)}`, 'success');
}


// ===================================================================================
// 5. PREDICTION & SIGNALING
// ===================================================================================
async function predictNext() {
    setButtonsState(true);
    log('Predicting next candle...');
    
    // Get the last `sequenceLength` worth of feature vectors
    const lastSequence = features.slice(features.length - CONFIG.sequenceLength);
    if (lastSequence.length < CONFIG.sequenceLength) {
        log('Not enough data to form a full sequence for prediction.', 'error');
        setButtonsState(false);
        return;
    }

    // --- MLP Prediction (uses only the very last feature vector) ---
    const mlpInput = tf.tensor2d([lastSequence[lastSequence.length - 1]]);
    const mlpPrediction = models.mlp.predict(mlpInput).dataSync()[0];
    
    // --- LSTM Prediction (uses the full sequence) ---
    const lstmInput = tf.tensor3d([lastSequence]);
    const lstmPrediction = models.lstm.predict(lstmInput).dataSync()[0];

    // --- Weighted Ensemble Prediction ---
    const ensemblePrediction = (mlpPrediction * modelWeights.mlp) + (lstmPrediction * modelWeights.lstm);

    // Display predictions
    document.getElementById('mlpPred').textContent = `${(mlpPrediction * 100).toFixed(4)}%`;
    document.getElementById('lstmPred').textContent = `${(lstmPrediction * 100).toFixed(4)}%`;
    document.getElementById('ensemblePred').textContent = `${(ensemblePrediction * 100).toFixed(4)}%`;

    // --- Signal Generation Logic ---
    const lastDataPoint = rawData[rawData.length-1];
    const currentPrice = lastDataPoint.close;
    const predictedPrice = currentPrice * (1 + ensemblePrediction);

    const rollingVolatility = tf.moments(
        rawData.slice(-20).map(p => (p.close / p.open) - 1)
    ).variance;

    let signal = 'HOLD';
    let signalClass = 'hold';

    if (rollingVolatility < CONFIG.volatilityFilterThreshold) {
        signal = 'HOLD (Low Volatility)';
    } else if (ensemblePrediction > CONFIG.signalThreshold) {
        signal = `BUY (Target: ${predictedPrice.toFixed(4)})`;
        signalClass = 'buy';
    } else if (ensemblePrediction < -CONFIG.signalThreshold) {
        signal = `SELL (Target: ${predictedPrice.toFixed(4)})`;
        signalClass = 'sell';
    }

    const signalElement = document.getElementById('finalSignal');
    signalElement.textContent = signal;
    signalElement.className = signalClass;

    log(`Final Signal: ${signal}`, 'success');
    
    // Update chart with prediction marker
    updateChartWithSignal(lastDataPoint.time, signalClass);

    setButtonsState(false);
}

// ===================================================================================
// 6. VISUALIZATION (Chart.js)
// ===================================================================================
function initializeChart() {
    if (chart) chart.destroy();
    
    const ctx = document.getElementById('candleChart').getContext('2d');
    const chartData = rawData.slice(-500).map(d => ({
        x: d.time * 1000,
        o: d.open,
        h: d.high,
        l: d.low,
        c: d.close,
    }));
    
    chart = new Chart(ctx, {
        type: 'candlestick',
        data: {
            datasets: [{
                label: `${CONFIG.symbol} Price`,
                data: chartData,
                borderColor: 'white',
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'minute' },
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { color: 'white' }
                },
                y: {
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { color: 'white' }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    mode: 'index',
                    intersect: false
                }
            }
        }
    });
}

function updateChartWithSignal(time, signalClass) {
    if (!chart || signalClass === 'hold') return;

    const signalDataset = {
        type: 'scatter',
        data: [{
            x: time * 1000,
            y: rawData.find(d => d.time === time).close
        }],
        pointStyle: signalClass === 'buy' ? 'triangle' : 'rectRot',
        radius: 8,
        backgroundColor: signalClass === 'buy' ? 'rgba(76, 175, 80, 0.8)' : 'rgba(244, 67, 54, 0.8)',
        rotation: signalClass === 'buy' ? 0 : 45,
    };
    
    chart.data.datasets.push(signalDataset);
    chart.update();
}

// ===================================================================================
// 7. EVENT LISTENERS & INITIALIZATION
// ===================================================================================
document.addEventListener('DOMContentLoaded', () => {
    log('Application initialized. Please fetch data to begin.');
    setButtonsState(false); // Enable fetch button initially
    fetchDataBtn.addEventListener('click', fetchData);
    trainModelsBtn.addEventListener('click', trainModelsWalkForward);
    predictNextBtn.addEventListener('click', predictNext);
});

</script>
</body>
</html>
