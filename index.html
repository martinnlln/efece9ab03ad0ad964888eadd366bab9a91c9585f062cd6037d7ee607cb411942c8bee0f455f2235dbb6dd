<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Trading Terminal</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0B0E11;
            color: #D1D4DC;
            overflow: hidden;
        }
        
        .terminal-grid {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            grid-template-rows: 60px 1fr 250px;
            height: 100vh;
            gap: 1px;
            background: #000;
        }
        
        .panel { background: #131722; padding: 12px; }
        .header-panel { grid-column: 1 / -1; display: flex; align-items: center; gap: 16px; padding: 12px 20px; }
        .left-panel { grid-row: 2 / -1; overflow-y: auto; }
        .chart-panel { grid-row: 2; position: relative; }
        .right-panel { grid-row: 2 / -1; overflow-y: auto; }
        .bottom-panel { grid-column: 2; overflow-y: auto; }
        
        .search-container {
            position: relative;
            flex: 1;
            max-width: 400px;
        }
        
        .search-input {
            width: 100%;
            background: #1E222D;
            border: 1px solid #2A2E39;
            color: #D1D4DC;
            padding: 10px 16px;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #2962FF;
            background: #1E222D;
        }
        
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #1E222D;
            border: 1px solid #2A2E39;
            border-radius: 4px;
            margin-top: 4px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        }
        
        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #2A2E39;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.15s;
        }
        
        .search-result-item:hover {
            background: #2A2E39;
        }
        
        .symbol-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .symbol-name {
            font-weight: 600;
            font-size: 14px;
            color: #F0F0F0;
        }
        
        .symbol-desc {
            font-size: 12px;
            color: #787B86;
        }
        
        .timeframe-selector {
            display: flex;
            gap: 4px;
            background: #1E222D;
            padding: 4px;
            border-radius: 4px;
        }
        
        .timeframe-btn {
            background: transparent;
            border: none;
            color: #787B86;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s;
        }
        
        .timeframe-btn:hover {
            background: #2A2E39;
            color: #D1D4DC;
        }
        
        .timeframe-btn.active {
            background: #2962FF;
            color: #fff;
        }
        
        .price-display {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .current-price {
            font-size: 24px;
            font-weight: 700;
            color: #F0F0F0;
        }
        
        .price-change {
            font-size: 14px;
            font-weight: 500;
        }
        
        .price-up { color: #26A69A; }
        .price-down { color: #EF5350; }
        
        .indicator-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .indicator-item {
            background: #1E222D;
            padding: 12px;
            border-radius: 4px;
            border-left: 3px solid transparent;
        }
        
        .indicator-item.bullish { border-left-color: #26A69A; }
        .indicator-item.bearish { border-left-color: #EF5350; }
        .indicator-item.neutral { border-left-color: #787B86; }
        
        .indicator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .indicator-name {
            font-weight: 600;
            font-size: 13px;
            color: #F0F0F0;
        }
        
        .indicator-signal {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 3px;
            font-weight: 600;
        }
        
        .signal-buy { background: rgba(38, 166, 154, 0.2); color: #26A69A; }
        .signal-sell { background: rgba(239, 83, 80, 0.2); color: #EF5350; }
        .signal-hold { background: rgba(120, 123, 134, 0.2); color: #787B86; }
        
        .indicator-value {
            font-size: 12px;
            color: #787B86;
        }
        
        .ml-prediction {
            background: linear-gradient(135deg, #1E222D 0%, #2A2E39 100%);
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 12px;
        }
        
        .prediction-header {
            font-weight: 700;
            font-size: 16px;
            margin-bottom: 12px;
            color: #F0F0F0;
        }
        
        .prediction-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #2A2E39;
        }
        
        .prediction-item:last-child { border-bottom: none; }
        
        .signal-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 16px;
            margin-bottom: 16px;
        }
        
        .signal-badge.strong-buy { background: linear-gradient(135deg, #26A69A, #00897B); }
        .signal-badge.buy { background: linear-gradient(135deg, #4CAF50, #388E3C); }
        .signal-badge.hold { background: linear-gradient(135deg, #FFA726, #F57C00); }
        .signal-badge.sell { background: linear-gradient(135deg, #EF5350, #D32F2F); }
        .signal-badge.strong-sell { background: linear-gradient(135deg, #C62828, #8B0000); }
        
        .confidence-bar {
            height: 6px;
            background: #2A2E39;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #2962FF, #1E88E5);
            transition: width 0.5s;
        }
        
        .section-title {
            font-size: 12px;
            font-weight: 700;
            color: #787B86;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 20px 0 12px 0;
        }
        
        .watchlist-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: #1E222D;
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .watchlist-item:hover {
            background: #2A2E39;
        }
        
        .analysis-panel {
            background: #1E222D;
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 12px;
        }
        
        .analysis-text {
            font-size: 13px;
            line-height: 1.6;
            color: #D1D4DC;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 12px;
        }
        
        .metric-box {
            background: #2A2E39;
            padding: 10px;
            border-radius: 4px;
        }
        
        .metric-label {
            font-size: 11px;
            color: #787B86;
            margin-bottom: 4px;
        }
        
        .metric-value {
            font-size: 16px;
            font-weight: 700;
            color: #F0F0F0;
        }
        
        .loader {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.1);
            border-top-color: #2962FF;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(19, 23, 34, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 100;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: #2962FF;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #131722; }
        ::-webkit-scrollbar-thumb { background: #2A2E39; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #363A45; }
        
        .pattern-item {
            background: #2A2E39;
            padding: 10px 12px;
            border-radius: 4px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .tab-bar {
            display: flex;
            gap: 2px;
            background: #1E222D;
            padding: 4px;
            border-radius: 4px;
            margin-bottom: 12px;
        }
        
        .tab-btn {
            flex: 1;
            background: transparent;
            border: none;
            color: #787B86;
            padding: 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.15s;
        }
        
        .tab-btn:hover { background: #2A2E39; color: #D1D4DC; }
        .tab-btn.active { background: #2962FF; color: #fff; }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
    </style>
</head>
<body>
    <div class="terminal-grid">
        
        <!-- Header -->
        <div class="panel header-panel">
            <div class="search-container">
                <input 
                    type="text" 
                    id="searchInput" 
                    class="search-input" 
                    placeholder="Search markets (e.g., BTC, AAPL, ETH)..."
                    autocomplete="off"
                />
                <div id="searchResults" class="search-results" style="display: none;"></div>
            </div>
            
            <div class="timeframe-selector">
                <button class="timeframe-btn" data-tf="1">1m</button>
                <button class="timeframe-btn" data-tf="3">3m</button>
                <button class="timeframe-btn" data-tf="5">5m</button>
                <button class="timeframe-btn" data-tf="15">15m</button>
                <button class="timeframe-btn" data-tf="30">30m</button>
                <button class="timeframe-btn" data-tf="60">1H</button>
                <button class="timeframe-btn" data-tf="240">4H</button>
                <button class="timeframe-btn active" data-tf="D">1D</button>
                <button class="timeframe-btn" data-tf="W">1W</button>
                <button class="timeframe-btn" data-tf="M">1M</button>
            </div>
            
            <div class="price-display">
                <div class="current-price" id="currentPrice">--</div>
                <div class="price-change price-up" id="priceChange">-- (--)</div>
            </div>
        </div>
        
        <!-- Left Panel - Watchlist -->
        <div class="panel left-panel">
            <div class="section-title">Popular Markets</div>
            <div id="watchlist"></div>
            
            <div class="section-title">Top Gainers</div>
            <div id="topGainers"></div>
            
            <div class="section-title">Top Losers</div>
            <div id="topLosers"></div>
        </div>
        
        <!-- Chart Panel -->
        <div class="panel chart-panel">
            <div id="loadingOverlay" class="loading-overlay" style="display: none;">
                <div class="loading-spinner"></div>
                <div id="loadingText" style="color: #787B86;">Loading data...</div>
            </div>
            <div id="chartContainer" style="width: 100%; height: 100%;"></div>
        </div>
        
        <!-- Right Panel - Analysis -->
        <div class="panel right-panel">
            <div class="signal-badge hold" id="mainSignal">
                <span id="signalEmoji">⏸️</span>
                <span id="signalText">ANALYZING</span>
            </div>
            
            <div style="margin-bottom: 12px;">
                <div style="font-size: 12px; color: #787B86; margin-bottom: 4px;">
                    Confidence: <span id="confidenceValue" style="color: #F0F0F0; font-weight: 600;">--%</span>
                </div>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="tab-bar">
                <button class="tab-btn active" data-tab="indicators">Indicators</button>
                <button class="tab-btn" data-tab="patterns">Patterns</button>
                <button class="tab-btn" data-tab="ai">AI Models</button>
            </div>
            
            <!-- Indicators Tab -->
            <div id="indicatorsTab" class="tab-content active">
                <div id="indicatorList" class="indicator-list"></div>
            </div>
            
            <!-- Patterns Tab -->
            <div id="patternsTab" class="tab-content">
                <div class="section-title">Detected Patterns</div>
                <div id="patternsList"></div>
                
                <div class="section-title">Support & Resistance</div>
                <div id="srLevels"></div>
            </div>
            
            <!-- AI Tab -->
            <div id="aiTab" class="tab-content">
                <div class="ml-prediction">
                    <div class="prediction-header">🧠 LSTM Neural Network</div>
                    <div id="lstmPrediction"></div>
                </div>
                
                <div class="ml-prediction">
                    <div class="prediction-header">📊 Ensemble Models</div>
                    <div id="ensemblePrediction"></div>
                </div>
                
                <div class="analysis-panel">
                    <div style="font-weight: 700; margin-bottom: 8px; color: #F0F0F0;">Market Analysis</div>
                    <div class="analysis-text" id="analysisText">
                        Select a symbol and timeframe to begin analysis...
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Bottom Panel - Metrics -->
        <div class="panel bottom-panel">
            <div class="tab-bar">
                <button class="tab-btn active" data-tab="metrics">Performance</button>
                <button class="tab-btn" data-tab="backtest">Backtest</button>
                <button class="tab-btn" data-tab="levels">Key Levels</button>
            </div>
            
            <div id="metricsTab" class="tab-content active">
                <div class="metric-grid" id="metricsGrid"></div>
            </div>
            
            <div id="backtestTab" class="tab-content">
                <div class="metric-grid" id="backtestMetrics"></div>
            </div>
            
            <div id="levelsTab" class="tab-content">
                <div id="keyLevels"></div>
            </div>
        </div>
        
    </div>

    <script>
        // Global State
        const state = {
            chart: null,
            candleSeries: null,
            volumeSeries: null,
            currentSymbol: 'BTCUSDT',
            currentTimeframe: 'D',
            currentData: null,
            allSymbols: [],
            indicators: {},
            analysis: null
        };

        // Market Data APIs
        class MarketData {
            static async fetchAllCryptoSymbols() {
                try {
                    const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                    const data = await response.json();
                    return data.symbols
                        .filter(s => s.status === 'TRADING' && s.quoteAsset === 'USDT')
                        .map(s => ({
                            symbol: s.symbol,
                            baseAsset: s.baseAsset,
                            type: 'crypto',
                            name: s.baseAsset,
                            exchange: 'Binance'
                        }));
                } catch (error) {
                    console.error('Error fetching crypto symbols:', error);
                    return [];
                }
            }

            static async fetchCryptoData(symbol, interval, limit = 500) {
                try {
                    const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    return data.map(candle => ({
                        time: candle[0] / 1000,
                        open: parseFloat(candle[1]),
                        high: parseFloat(candle[2]),
                        low: parseFloat(candle[3]),
                        close: parseFloat(candle[4]),
                        volume: parseFloat(candle[5])
                    }));
                } catch (error) {
                    console.error('Error fetching data:', error);
                    throw error;
                }
            }

            static async fetch24hrTickers() {
                try {
                    const response = await fetch('https://api.binance.com/api/v3/ticker/24hr');
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching tickers:', error);
                    return [];
                }
            }

            static convertTimeframe(tf) {
                const map = {
                    '1': '1m', '3': '3m', '5': '5m', '15': '15m', '30': '30m',
                    '60': '1h', '240': '4h', 'D': '1d', 'W': '1w', 'M': '1M'
                };
                return map[tf] || '1d';
            }
        }

        // Technical Indicators
        class TechnicalIndicators {
            static calculateAll(data) {
                const closes = data.map(d => d.close);
                const highs = data.map(d => d.high);
                const lows = data.map(d => d.low);
                const volumes = data.map(d => d.volume);
                
                return {
                    rsi: this.RSI(closes, 14),
                    macd: this.MACD(closes),
                    sma20: this.SMA(closes, 20),
                    sma50: this.SMA(closes, 50),
                    sma200: this.SMA(closes, 200),
                    ema12: this.EMA(closes, 12),
                    ema26: this.EMA(closes, 26),
                    bb: this.BollingerBands(closes, 20, 2),
                    atr: this.ATR(highs, lows, closes, 14),
                    stoch: this.Stochastic(highs, lows, closes, 14),
                    adx: this.ADX(highs, lows, closes, 14),
                    obv: this.OBV(closes, volumes),
                    vwap: this.VWAP(highs, lows, closes, volumes)
                };
            }

            static SMA(data, period) {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                        result.push(sum / period);
                    }
                }
                return result;
            }

            static EMA(data, period) {
                const k = 2 / (period + 1);
                const result = [data[0]];
                for (let i = 1; i < data.length; i++) {
                    result.push(data[i] * k + result[i - 1] * (1 - k));
                }
                return result;
            }

            static RSI(data, period = 14) {
                const changes = data.slice(1).map((val, i) => val - data[i]);
                const result = [null];
                
                for (let i = period - 1; i < changes.length; i++) {
                    const gains = [];
                    const losses = [];
                    
                    for (let j = i - period + 1; j <= i; j++) {
                        if (changes[j] > 0) gains.push(changes[j]);
                        else losses.push(Math.abs(changes[j]));
                    }
                    
                    const avgGain = gains.length > 0 ? gains.reduce((a, b) => a + b, 0) / period : 0;
                    const avgLoss = losses.length > 0 ? losses.reduce((a, b) => a + b, 0) / period : 0;
                    
                    if (avgLoss === 0) result.push(100);
                    else {
                        const rs = avgGain / avgLoss;
                        result.push(100 - (100 / (1 + rs)));
                    }
                }
                
                while (result.length < data.length) result.unshift(null);
                return result;
            }

            static MACD(data) {
                const ema12 = this.EMA(data, 12);
                const ema26 = this.EMA(data, 26);
                const macdLine = ema12.map((v, i) => v - ema26[i]);
                const signal = this.EMA(macdLine.filter(v => v !== null && !isNaN(v)), 9);
                const histogram = macdLine.slice(-signal.length).map((v, i) => v - signal[i]);
                return { macdLine, signal, histogram };
            }

            static BollingerBands(data, period = 20, mult = 2) {
                const sma = this.SMA(data, period);
                const upper = [];
                const lower = [];
                
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1 || sma[i] === null) {
                        upper.push(null);
                        lower.push(null);
                    } else {
                        const slice = data.slice(i - period + 1, i + 1);
                        const mean = sma[i];
                        const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
                        const std = Math.sqrt(variance);
                        upper.push(mean + mult * std);
                        lower.push(mean - mult * std);
                    }
                }
                
                return { upper, middle: sma, lower };
            }

            static ATR(high, low, close, period = 14) {
                const tr = [high[0] - low[0]];
                for (let i = 1; i < close.length; i++) {
                    const hl = high[i] - low[i];
                    const hc = Math.abs(high[i] - close[i - 1]);
                    const lc = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(hl, hc, lc));
                }
                return this.SMA(tr, period);
            }

            static Stochastic(high, low, close, period = 14) {
                const result = [];
                for (let i = 0; i < close.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                    } else {
                        const highMax = Math.max(...high.slice(i - period + 1, i + 1));
                        const lowMin = Math.min(...low.slice(i - period + 1, i + 1));
                        const k = ((close[i] - lowMin) / (highMax - lowMin)) * 100;
                        result.push(k);
                    }
                }
                return result;
            }

            static ADX(high, low, close, period = 14) {
                const tr = [];
                const dmPlus = [];
                const dmMinus = [];
                
                for (let i = 1; i < close.length; i++) {
                    const hl = high[i] - low[i];
                    const hc = Math.abs(high[i] - close[i - 1]);
                    const lc = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(hl, hc, lc));
                    
                    const highDiff = high[i] - high[i - 1];
                    const lowDiff = low[i - 1] - low[i];
                    
                    dmPlus.push(highDiff > lowDiff && highDiff > 0 ? highDiff : 0);
                    dmMinus.push(lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0);
                }
                
                const atr = this.SMA(tr, period);
                const diPlus = dmPlus.map((v, i) => atr[i] && atr[i] !== 0 ? (v / atr[i]) * 100 : 0);
                const diMinus = dmMinus.map((v, i) => atr[i] && atr[i] !== 0 ? (v / atr[i]) * 100 : 0);
                
                const dx = diPlus.map((v, i) => {
                    const sum = v + diMinus[i];
                    return sum !== 0 ? (Math.abs(v - diMinus[i]) / sum) * 100 : 0;
                });
                
                return this.SMA(dx, period);
            }

            static OBV(close, volume) {
                const obv = [volume[0]];
                for (let i = 1; i < close.length; i++) {
                    if (close[i] > close[i - 1]) obv.push(obv[i - 1] + volume[i]);
                    else if (close[i] < close[i - 1]) obv.push(obv[i - 1] - volume[i]);
                    else obv.push(obv[i - 1]);
                }
                return obv;
            }

            static VWAP(high, low, close, volume) {
                let cumVolume = 0;
                let cumVolumePrice = 0;
                const result = [];
                
                for (let i = 0; i < close.length; i++) {
                    const typical = (high[i] + low[i] + close[i]) / 3;
                    cumVolumePrice += typical * volume[i];
                    cumVolume += volume[i];
                    result.push(cumVolumePrice / cumVolume);
                }
                
                return result;
            }
        }

        // ML Engine
        class MLEngine {
            static async trainLSTM(data) {
                try {
                    const closes = data.map(d => d.close);
                    const normalized = this.normalize(closes);
                    const sequences = this.prepareSequences(normalized.values, 60);
                    
                    if (sequences.length < 50) return null;
                    
                    const model = tf.sequential();
                    model.add(tf.layers.lstm({ units: 50, returnSequences: true, inputShape: [60, 1] }));
                    model.add(tf.layers.dropout({ rate: 0.2 }));
                    model.add(tf.layers.lstm({ units: 50 }));
                    model.add(tf.layers.dense({ units: 1 }));
                    
                    model.compile({ optimizer: tf.train.adam(0.001), loss: 'meanSquaredError' });
                    
                    const xs = tf.tensor3d(sequences.X.map(seq => seq.map(v => [v])));
                    const ys = tf.tensor2d(sequences.y.map(v => [v]));
                    
                    await model.fit(xs, ys, { epochs: 20, batchSize: 32, verbose: 0 });
                    
                    const lastSeq = normalized.values.slice(-60);
                    const input = tf.tensor3d([lastSeq.map(v => [v])]);
                    const prediction = model.predict(input);
                    const predValue = (await prediction.data())[0];
                    
                    xs.dispose();
                    ys.dispose();
                    input.dispose();
                    prediction.dispose();
                    
                    return normalized.denormalize(predValue);
                } catch (error) {
                    console.error('LSTM training error:', error);
                    return null;
                }
            }

            static normalize(data) {
                const values = data.filter(v => v !== null && !isNaN(v));
                const min = Math.min(...values);
                const max = Math.max(...values);
                const range = max - min || 1;
                
                return {
                    values: data.map(v => v !== null && !isNaN(v) ? (v - min) / range : 0),
                    denormalize: (v) => v * range + min,
                    min, max
                };
            }

            static prepareSequences(data, lookback) {
                const X = [], y = [];
                for (let i = lookback; i < data.length; i++) {
                    X.push(data.slice(i - lookback, i));
                    y.push(data[i]);
                }
                return { X, y };
            }

            static linearRegression(data) {
                const X = Array.from({ length: data.length }, (_, i) => i);
                const y = data;
                const n = X.length;
                const sumX = X.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = X.reduce((sum, x, i) => sum + x * y[i], 0);
                const sumXX = X.reduce((sum, x) => sum + x * x, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                return slope * data.length + intercept;
            }
        }

        // AI Analyst
        class AIAnalyst {
            static analyze(data, indicators) {
                const signals = this.generateSignals(data, indicators);
                const patterns = this.detectPatterns(data);
                const srLevels = this.findSupportResistance(data);
                
                const signalScore = this.calculateSignalScore(signals);
                const { signal, confidence } = this.determineSignal(signalScore);
                
                return {
                    signal,
                    confidence,
                    signals,
                    patterns,
                    srLevels,
                    analysis: this.generateAnalysisText(signal, signals, patterns, confidence)
                };
            }

            static generateSignals(data, indicators) {
                const closes = data.map(d => d.close);
                const lastIdx = closes.length - 1;
                const lastPrice = closes[lastIdx];
                
                const signals = {};
                
                // RSI
                const rsi = indicators.rsi[lastIdx];
                if (rsi < 30) signals.rsi = { signal: 'buy', value: rsi, reason: 'Oversold' };
                else if (rsi > 70) signals.rsi = { signal: 'sell', value: rsi, reason: 'Overbought' };
                else signals.rsi = { signal: 'neutral', value: rsi, reason: 'Neutral zone' };
                
                // MACD
                const macd = indicators.macd.histogram[indicators.macd.histogram.length - 1];
                const prevMacd = indicators.macd.histogram[indicators.macd.histogram.length - 2];
                if (macd > 0 && prevMacd < 0) signals.macd = { signal: 'buy', value: macd, reason: 'Bullish crossover' };
                else if (macd < 0 && prevMacd > 0) signals.macd = { signal: 'sell', value: macd, reason: 'Bearish crossover' };
                else if (macd > 0) signals.macd = { signal: 'buy', value: macd, reason: 'Positive momentum' };
                else signals.macd = { signal: 'sell', value: macd, reason: 'Negative momentum' };
                
                // Moving Averages
                const sma50 = indicators.sma50[lastIdx];
                const sma200 = indicators.sma200[lastIdx];
                if (sma50 && sma200) {
                    if (lastPrice > sma50 && sma50 > sma200) signals.ma = { signal: 'buy', reason: 'Above MAs (Golden)' };
                    else if (lastPrice < sma50 && sma50 < sma200) signals.ma = { signal: 'sell', reason: 'Below MAs (Death)' };
                    else signals.ma = { signal: 'neutral', reason: 'Mixed MA alignment' };
                }
                
                // Bollinger Bands
                const bbUpper = indicators.bb.upper[lastIdx];
                const bbLower = indicators.bb.lower[lastIdx];
                if (lastPrice < bbLower) signals.bb = { signal: 'buy', reason: 'Below lower band' };
                else if (lastPrice > bbUpper) signals.bb = { signal: 'sell', reason: 'Above upper band' };
                else signals.bb = { signal: 'neutral', reason: 'Within bands' };
                
                // Stochastic
                const stoch = indicators.stoch[lastIdx];
                if (stoch < 20) signals.stoch = { signal: 'buy', value: stoch, reason: 'Oversold' };
                else if (stoch > 80) signals.stoch = { signal: 'sell', value: stoch, reason: 'Overbought' };
                else signals.stoch = { signal: 'neutral', value: stoch, reason: 'Neutral' };
                
                // ADX
                const adx = indicators.adx[lastIdx];
                if (adx > 25) signals.adx = { signal: 'neutral', value: adx, reason: 'Strong trend' };
                else signals.adx = { signal: 'neutral', value: adx, reason: 'Weak trend' };
                
                return signals;
            }

            static calculateSignalScore(signals) {
                let score = 0;
                Object.values(signals).forEach(s => {
                    if (s.signal === 'buy') score += 1;
                    else if (s.signal === 'sell') score -= 1;
                });
                return score / Object.keys(signals).length;
            }

            static determineSignal(score) {
                let signal, confidence;
                
                if (score > 0.5) {
                    signal = 'STRONG BUY';
                    confidence = Math.min(score * 100, 95);
                } else if (score > 0.2) {
                    signal = 'BUY';
                    confidence = Math.min(score * 80, 85);
                } else if (score > -0.2) {
                    signal = 'HOLD';
                    confidence = 60;
                } else if (score > -0.5) {
                    signal = 'SELL';
                    confidence = Math.min(Math.abs(score) * 80, 85);
                } else {
                    signal = 'STRONG SELL';
                    confidence = Math.min(Math.abs(score) * 100, 95);
                }
                
                return { signal, confidence };
            }

            static detectPatterns(data) {
                const closes = data.map(d => d.close);
                const patterns = [];
                
                // Simple pattern detection
                const recent = closes.slice(-50);
                const trend = recent[recent.length - 1] > recent[0] ? 'bullish' : 'bearish';
                patterns.push({ type: trend === 'bullish' ? 'Uptrend' : 'Downtrend', confidence: 0.7 });
                
                return patterns;
            }

            static findSupportResistance(data) {
                const closes = data.map(d => d.close);
                const levels = [];
                
                // Find recent highs and lows
                for (let i = 5; i < closes.length - 5; i++) {
                    const slice = closes.slice(i - 5, i + 6);
                    const current = closes[i];
                    
                    if (current === Math.min(...slice)) {
                        levels.push({ type: 'support', price: current, strength: 1 });
                    } else if (current === Math.max(...slice)) {
                        levels.push({ type: 'resistance', price: current, strength: 1 });
                    }
                }
                
                // Cluster levels
                const clustered = [];
                levels.forEach(level => {
                    const existing = clustered.find(l => 
                        Math.abs(l.price - level.price) / level.price < 0.015 && l.type === level.type
                    );
                    
                    if (existing) existing.strength++;
                    else clustered.push({ ...level });
                });
                
                return clustered.sort((a, b) => b.strength - a.strength).slice(0, 5);
            }

            static generateAnalysisText(signal, signals, patterns, confidence) {
                let text = `<strong>${signal}</strong> signal with ${confidence.toFixed(0)}% confidence.<br><br>`;
                
                text += '<strong>Key Factors:</strong><br>';
                Object.entries(signals).forEach(([name, data]) => {
                    const emoji = data.signal === 'buy' ? '🟢' : data.signal === 'sell' ? '🔴' : '🟡';
                    text += `${emoji} ${name.toUpperCase()}: ${data.reason}`;
                    if (data.value !== undefined) text += ` (${data.value.toFixed(2)})`;
                    text += '<br>';
                });
                
                return text;
            }
        }

        // UI Functions
        function initChart() {
            const container = document.getElementById('chartContainer');
            state.chart = LightweightCharts.createChart(container, {
                layout: { background: { color: '#131722' }, textColor: '#D1D4DC' },
                grid: { vertLines: { color: '#1E222D' }, horzLines: { color: '#1E222D' } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                rightPriceScale: { borderColor: '#2A2E39' },
                timeScale: { borderColor: '#2A2E39', timeVisible: true },
                height: container.clientHeight,
                width: container.clientWidth
            });

            state.candleSeries = state.chart.addCandlestickSeries({
                upColor: '#26A69A',
                downColor: '#EF5350',
                borderVisible: false,
                wickUpColor: '#26A69A',
                wickDownColor: '#EF5350'
            });

            state.volumeSeries = state.chart.addHistogramSeries({
                color: '#26A69A',
                priceFormat: { type: 'volume' },
                priceScaleId: '',
                scaleMargins: { top: 0.8, bottom: 0 }
            });

            window.addEventListener('resize', () => {
                state.chart.applyOptions({ 
                    width: container.clientWidth,
                    height: container.clientHeight
                });
            });
        }

        async function loadMarketData(symbol, timeframe) {
            try {
                showLoading(true, 'Fetching market data...');
                
                const interval = MarketData.convertTimeframe(timeframe);
                const data = await MarketData.fetchCryptoData(symbol, interval, 500);
                
                state.currentData = data;
                
                // Update chart
                state.candleSeries.setData(data);
                state.volumeSeries.setData(data.map(d => ({
                    time: d.time,
                    value: d.volume,
                    color: d.close > d.open ? '#26A69A66' : '#EF535066'
                })));
                
                // Update price display
                const lastCandle = data[data.length - 1];
                const prevCandle = data[data.length - 2];
                const change = lastCandle.close - prevCandle.close;
                const changePercent = (change / prevCandle.close) * 100;
                
                document.getElementById('currentPrice').textContent = `$${lastCandle.close.toFixed(2)}`;
                document.getElementById('priceChange').textContent = 
                    `${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
                document.getElementById('priceChange').className = `price-change ${change >= 0 ? 'price-up' : 'price-down'}`;
                
                // Run analysis
                await runAnalysis(data);
                
                showLoading(false);
            } catch (error) {
                console.error('Error loading data:', error);
                showLoading(false);
                alert('Error loading data. Please try again.');
            }
        }

        async function runAnalysis(data) {
            showLoading(true, 'Analyzing market...');
            
            // Calculate indicators
            const indicators = TechnicalIndicators.calculateAll(data);
            state.indicators = indicators;
            
            // AI Analysis
            const analysis = AIAnalyst.analyze(data, indicators);
            state.analysis = analysis;
            
            // Update UI
            updateSignalDisplay(analysis);
            updateIndicators(analysis.signals);
            updatePatterns(analysis.patterns, analysis.srLevels);
            updateMetrics(data, indicators);
            
            // ML Predictions (async)
            setTimeout(async () => {
                showLoading(true, 'Training AI models...');
                const lstmPred = await MLEngine.trainLSTM(data);
                const linearPred = MLEngine.linearRegression(data.map(d => d.close));
                updateMLPredictions(lstmPred, linearPred, data[data.length - 1].close);
                showLoading(false);
            }, 100);
        }

        function updateSignalDisplay(analysis) {
            const signalMap = {
                'STRONG BUY': { class: 'strong-buy', emoji: '🚀' },
                'BUY': { class: 'buy', emoji: '📈' },
                'HOLD': { class: 'hold', emoji: '⏸️' },
                'SELL': { class: 'sell', emoji: '📉' },
                'STRONG SELL': { class: 'strong-sell', emoji: '⚠️' }
            };
            
            const signalInfo = signalMap[analysis.signal];
            const badge = document.getElementById('mainSignal');
            badge.className = `signal-badge ${signalInfo.class}`;
            document.getElementById('signalEmoji').textContent = signalInfo.emoji;
            document.getElementById('signalText').textContent = analysis.signal;
            document.getElementById('confidenceValue').textContent = `${analysis.confidence.toFixed(0)}%`;
            document.getElementById('confidenceFill').style.width = `${analysis.confidence}%`;
            document.getElementById('analysisText').innerHTML = analysis.analysis;
        }

        function updateIndicators(signals) {
            const container = document.getElementById('indicatorList');
            container.innerHTML = Object.entries(signals).map(([name, data]) => {
                const signalClass = data.signal === 'buy' ? 'bullish' : data.signal === 'sell' ? 'bearish' : 'neutral';
                const signalText = data.signal.toUpperCase();
                const signalBadgeClass = data.signal === 'buy' ? 'signal-buy' : data.signal === 'sell' ? 'signal-sell' : 'signal-hold';
                
                return `
                    <div class="indicator-item ${signalClass}">
                        <div class="indicator-header">
                            <span class="indicator-name">${name.toUpperCase()}</span>
                            <span class="indicator-signal ${signalBadgeClass}">${signalText}</span>
                        </div>
                        <div class="indicator-value">${data.reason}</div>
                    </div>
                `;
            }).join('');
        }

        function updatePatterns(patterns, srLevels) {
            document.getElementById('patternsList').innerHTML = patterns.map(p => `
                <div class="pattern-item">
                    <div>
                        <div style="font-weight: 600;">${p.type}</div>
                        <div style="font-size: 11px; color: #787B86;">Confidence: ${(p.confidence * 100).toFixed(0)}%</div>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('srLevels').innerHTML = srLevels.map(level => `
                <div class="pattern-item">
                    <div>
                        <div style="font-weight: 600; text-transform: uppercase;">${level.type}</div>
                        <div style="font-size: 12px; color: #F0F0F0; margin-top: 4px;">$${level.price.toFixed(2)}</div>
                    </div>
                    <div style="color: #FFA726;">${'⭐'.repeat(Math.min(level.strength, 5))}</div>
                </div>
            `).join('');
        }

        function updateMetrics(data, indicators) {
            const closes = data.map(d => d.close);
            const lastPrice = closes[closes.length - 1];
            const firstPrice = closes[0];
            const change = ((lastPrice - firstPrice) / firstPrice) * 100;
            
            const high = Math.max(...closes);
            const low = Math.min(...closes);
            const avgVolume = data.reduce((sum, d) => sum + d.volume, 0) / data.length;
            const lastVolume = data[data.length - 1].volume;
            const volumeRatio = lastVolume / avgVolume;
            
            const html = `
                <div class="metric-box">
                    <div class="metric-label">Period Change</div>
                    <div class="metric-value" style="color: ${change >= 0 ? '#26A69A' : '#EF5350'}">${change >= 0 ? '+' : ''}${change.toFixed(2)}%</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Period High</div>
                    <div class="metric-value">$${high.toFixed(2)}</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Period Low</div>
                    <div class="metric-value">$${low.toFixed(2)}</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Volume Ratio</div>
                    <div class="metric-value">${volumeRatio.toFixed(2)}x</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">RSI (14)</div>
                    <div class="metric-value">${indicators.rsi[indicators.rsi.length - 1]?.toFixed(2) || 'N/A'}</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">ATR (14)</div>
                    <div class="metric-value">${indicators.atr[indicators.atr.length - 1]?.toFixed(2) || 'N/A'}</div>
                </div>
            `;
            
            document.getElementById('metricsGrid').innerHTML = html;
        }

        function updateMLPredictions(lstmPred, linearPred, currentPrice) {
            const lstmChange = lstmPred ? ((lstmPred - currentPrice) / currentPrice * 100) : 0;
            const linearChange = ((linearPred - currentPrice) / currentPrice * 100);
            
            document.getElementById('lstmPrediction').innerHTML = `
                <div class="prediction-item">
                    <span>Predicted Price:</span>
                    <span style="font-weight: 700;">$${lstmPred ? lstmPred.toFixed(2) : 'Training...'}</span>
                </div>
                <div class="prediction-item">
                    <span>Expected Change:</span>
                    <span style="font-weight: 700; color: ${lstmChange >= 0 ? '#26A69A' : '#EF5350'}">${lstmChange >= 0 ? '+' : ''}${lstmChange.toFixed(2)}%</span>
                </div>
            `;
            
            document.getElementById('ensemblePrediction').innerHTML = `
                <div class="prediction-item">
                    <span>Linear Regression:</span>
                    <span style="font-weight: 700;">$${linearPred.toFixed(2)}</span>
                </div>
                <div class="prediction-item">
                    <span>Expected Change:</span>
                    <span style="font-weight: 700; color: ${linearChange >= 0 ? '#26A69A' : '#EF5350'}">${linearChange >= 0 ? '+' : ''}${linearChange.toFixed(2)}%</span>
                </div>
            `;
        }

        function showLoading(show, text = '') {
            document.getElementById('loadingOverlay').style.display = show ? 'flex' : 'none';
            if (text) document.getElementById('loadingText').textContent = text;
        }

        async function loadWatchlist() {
            const tickers = await MarketData.fetch24hrTickers();
            
            const popular = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'ADAUSDT', 'XRPUSDT'];
            const gainers = tickers
                .filter(t => t.symbol.endsWith('USDT'))
                .sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent))
                .slice(0, 5);
            const losers = tickers
                .filter(t => t.symbol.endsWith('USDT'))
                .sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent))
                .slice(0, 5);
            
            const renderList = (items, container) => {
                document.getElementById(container).innerHTML = items.map(symbol => {
                    const ticker = typeof symbol === 'string' ? tickers.find(t => t.symbol === symbol) : symbol;
                    if (!ticker) return '';
                    
                    const change = parseFloat(ticker.priceChangePercent);
                    return `
                        <div class="watchlist-item" data-symbol="${ticker.symbol}">
                            <div>
                                <div style="font-weight: 600;">${ticker.symbol.replace('USDT', '')}</div>
                                <div style="font-size: 11px; color: #787B86;">$${parseFloat(ticker.lastPrice).toFixed(2)}</div>
                            </div>
                            <div style="font-weight: 600; color: ${change >= 0 ? '#26A69A' : '#EF5350'}">
                                ${change >= 0 ? '+' : ''}${change.toFixed(2)}%
                            </div>
                        </div>
                    `;
                }).join('');
            };
            
            renderList(popular, 'watchlist');
            renderList(gainers, 'topGainers');
            renderList(losers, 'topLosers');
            
            document.querySelectorAll('.watchlist-item').forEach(item => {
                item.addEventListener('click', () => {
                    state.currentSymbol = item.dataset.symbol;
                    loadMarketData(state.currentSymbol, state.currentTimeframe);
                });
            });
        }

        // Search functionality
        let searchTimeout;
        document.getElementById('searchInput').addEventListener('input', async (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value.toUpperCase();
            
            if (query.length < 1) {
                document.getElementById('searchResults').style.display = 'none';
                return;
            }
            
            searchTimeout = setTimeout(async () => {
                if (state.allSymbols.length === 0) {
                    state.allSymbols = await MarketData.fetchAllCryptoSymbols();
                }
                
                const results = state.allSymbols
                    .filter(s => s.baseAsset.includes(query) || s.symbol.includes(query))
                    .slice(0, 20);
                
                const container = document.getElementById('searchResults');
                container.innerHTML = results.map(s => `
                    <div class="search-result-item" data-symbol="${s.symbol}">
                        <div class="symbol-info">
                            <div class="symbol-name">${s.baseAsset}/USDT</div>
                            <div class="symbol-desc">${s.exchange}</div>
                        </div>
                    </div>
                `).join('');
                
                container.style.display = results.length > 0 ? 'block' : 'none';
                
                container.querySelectorAll('.search-result-item').forEach(item => {
                    item.addEventListener('click', () => {
                        state.currentSymbol = item.dataset.symbol;
                        document.getElementById('searchInput').value = item.dataset.symbol;
                        container.style.display = 'none';
                        loadMarketData(state.currentSymbol, state.currentTimeframe);
                    });
                });
            }, 300);
        });

        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                document.getElementById('searchResults').style.display = 'none';
            }
        });

        // Timeframe selection
        document.querySelectorAll('.timeframe-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.currentTimeframe = btn.dataset.tf;
                loadMarketData(state.currentSymbol, state.currentTimeframe);
            });
        });

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;
                const parent = btn.closest('.panel');
                
                parent.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                parent.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                btn.classList.add('active');
                parent.querySelector(`#${tabName}Tab`).classList.add('active');
            });
        });

        // Initialize
        initChart();
        loadWatchlist();
        loadMarketData(state.currentSymbol, state.currentTimeframe);
    </script>
</body>
</html>
