<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIF/USDT ML Price Predictor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/3.4.3/luxon.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        // Data pipeline and feature engineering
        class DataPipeline {
            constructor() {
                this.rawData = [];
                this.features = [];
                this.labels = [];
            }

            addPriceData(data) {
                this.rawData.push({
                    timestamp: Date.now(),
                    open: parseFloat(data.o),
                    high: parseFloat(data.h),
                    low: parseFloat(data.l),
                    close: parseFloat(data.c),
                    volume: parseFloat(data.v),
                    trades: parseFloat(data.n || 0),
                    quoteVolume: parseFloat(data.q || 0)
                });

                // Keep only last 1000 data points
                if (this.rawData.length > config.maxDataPoints) {
                    this.rawData.shift();
                }

                this.engineerFeatures();
            }

            engineerFeatures() {
                if (this.rawData.length < 60) return; // Need minimum data for indicators

                const closes = this.rawData.map(d => d.close);
                const highs = this.rawData.map(d => d.high);
                const lows = this.rawData.map(d => d.low);
                const volumes = this.rawData.map(d => d.volume);
                const opens = this.rawData.map(d => d.open);

                // Technical indicators
                const ema20 = TechnicalIndicators.ema(closes, 20);
                const ema50 = TechnicalIndicators.ema(closes, 50);
                const rsi = TechnicalIndicators.rsi(closes, 14);
                const macdData = TechnicalIndicators.macd(closes);
                const bb = TechnicalIndicators.bollingerBands(closes);
                const vwap = TechnicalIndicators.vwap(highs, lows, closes, volumes);
                const obv = TechnicalIndicators.obv(closes, volumes);

                // Microstructure features
                const volatility = this.calculateVolatility(closes, 20);
                const momentum = this.calculateMomentum(closes, 10);
                const bidAskSpread = this.calculateBidAskSpread();
                const depthImbalance = this.calculateDepthImbalance();

                // Build feature matrix
                this.features = [];
                const minLength = Math.min(
                    closes.length, ema20.length, ema50.length, rsi.length,
                    macdData.macd.length, bb.upper.length, vwap.length, obv.length,
                    volatility.length, momentum.length
                );

                for (let i = 0; i < minLength; i++) {
                    const idx = closes.length - minLength + i;
                    this.features.push([
                        opens[idx], highs[idx], lows[idx], closes[idx], volumes[idx],
                        ema20[ema20.length - minLength + i] || closes[idx],
                        ema50[ema50.length - minLength + i] || closes[idx],
                        macdData.macd[macdData.macd.length - minLength + i] || 0,
                        macdData.signal[macdData.signal.length - minLength + i] || 0,
                        rsi[rsi.length - minLength + i] || 50,
                        bb.upper[bb.upper.length - minLength + i] || closes[idx],
                        bb.lower[bb.lower.length - minLength + i] || closes[idx],
                        bb.middle[bb.middle.length - minLength + i] || closes[idx],
                        vwap[vwap.length - minLength + i] || closes[idx],
                        obv[obv.length - minLength + i] || 0,
                        bidAskSpread[Math.min(bidAskSpread.length - 1, i)] || 0,
                        depthImbalance[Math.min(depthImbalance.length - 1, i)] || 0,
                        0, // tradeImbalance placeholder
                        volatility[volatility.length - minLength + i] || 0,
                        momentum[momentum.length - minLength + i] || 0
                    ]);
                }

                // Update state indicators
                state.indicators = {
                    ema20: ema20[ema20.length - 1],
                    ema50: ema50[ema50.length - 1],
                    rsi: rsi[rsi.length - 1],
                    macd: macdData.macd[macdData.macd.length - 1],
                    macdSignal: macdData.signal[macdData.signal.length - 1],
                    bbUpper: bb.upper[bb.upper.length - 1],
                    bbLower: bb.lower[bb.lower.length - 1],
                    bbMiddle: bb.middle[bb.middle.length - 1],
                    vwap: vwap[vwap.length - 1],
                    obv: obv[obv.length - 1]
                };
            }

            calculateVolatility(prices, period) {
                const volatility = [];
                for (let i = period; i < prices.length; i++) {
                    const slice = prices.slice(i - period, i);
                    const mean = slice.reduce((a, b) => a + b, 0) / slice.length;
                    const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / slice.length;
                    volatility.push(Math.sqrt(variance));
                }
                return volatility;
            }

            calculateMomentum(prices, period) {
                const momentum = [];
                for (let i = period; i < prices.length; i++) {
                    momentum.push((prices[i] - prices[i - period]) / prices[i - period]);
                }
                return momentum;
            }

            calculateBidAskSpread() {
                if (!state.orderbook.bids.length || !state.orderbook.asks.length) {
                    return [0];
                }
                const bestBid = parseFloat(state.orderbook.bids[0][0]);
                const bestAsk = parseFloat(state.orderbook.asks[0][0]);
                return [(bestAsk - bestBid) / bestAsk];
            }

            calculateDepthImbalance() {
                if (!state.orderbook.bids.length || !state.orderbook.asks.length) {
                    return [0];
                }
                
                const bidVolume = state.orderbook.bids.slice(0, 5).reduce((sum, bid) => sum + parseFloat(bid[1]), 0);
                const askVolume = state.orderbook.asks.slice(0, 5).reduce((sum, ask) => sum + parseFloat(ask[1]), 0);
                
                return [(bidVolume - askVolume) / (bidVolume + askVolume)];
            }

            createSequences(sequenceLength, predictionHorizon) {
                if (this.features.length < sequenceLength + predictionHorizon) {
                    return { X: null, y: null };
                }

                const sequences = [];
                const labels = [];
                const closes = this.rawData.map(d => d.close);

                for (let i = 0; i < this.features.length - sequenceLength - predictionHorizon; i++) {
                    sequences.push(this.features.slice(i, i + sequenceLength));
                    
                    // Label: future return
                    const currentPrice = closes[closes.length - this.features.length + i + sequenceLength - 1];
                    const futurePrice = closes[closes.length - this.features.length + i + sequenceLength + predictionHorizon - 1];
                    labels.push((futurePrice - currentPrice) / currentPrice);
                }

                return {
                    X: tf.tensor3d(sequences),
                    y: tf.tensor2d(labels.map(l => [l]))
                };
            }
        }

        // WebSocket connection manager
        class WebSocketManager {
            constructor() {
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
            }

            connect() {
                try {
                    const streams = [
                        `${config.symbol.toLowerCase()}@ticker`,
                        `${config.symbol.toLowerCase()}@trade`,
                        `${config.symbol.toLowerCase()}@depth10@100ms`,
                        `${config.symbol.toLowerCase()}@kline_1m`
                    ];
                    
                    const wsUrl = `${config.binanceWsUrl}${streams.join('/')}`;
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        state.connected = true;
                        this.reconnectAttempts = 0;
                        this.updateConnectionStatus();
                        log('Connected to Binance WebSocket', 'success');
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (error) {
                            log(`Error parsing WebSocket message: ${error.message}`, 'error');
                        }
                    };

                    this.ws.onclose = () => {
                        state.connected = false;
                        this.updateConnectionStatus();
                        log('WebSocket connection closed');
                        this.handleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        log(`WebSocket error: ${error.message}`, 'error');
                    };

                } catch (error) {
                    log(`Failed to connect: ${error.message}`, 'error');
                    this.handleReconnect();
                }
            }

            handleMessage(data) {
                if (data.stream) {
                    const stream = data.stream;
                    const eventData = data.data;

                    if (stream.includes('@ticker')) {
                        this.handleTicker(eventData);
                    } else if (stream.includes('@trade')) {
                        this.handleTrade(eventData);
                    } else if (stream.includes('@depth')) {
                        this.handleDepth(eventData);
                    } else if (stream.includes('@kline')) {
                        this.handleKline(eventData);
                    }
                }
            }

            handleTicker(data) {
                const currentPrice = parseFloat(data.c);
                const priceChange = parseFloat(data.P);
                
                document.getElementById('currentPrice').textContent = `${formatPrice(currentPrice)}`;
                
                const changeElement = document.getElementById('priceChange');
                changeElement.textContent = `${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(2)}%`;
                changeElement.className = `price-change ${priceChange >= 0 ? '' : 'negative'}`;
            }

            handleTrade(data) {
                const trade = {
                    price: parseFloat(data.p),
                    quantity: parseFloat(data.q),
                    time: new Date(data.T).toLocaleTimeString(),
                    isBuyerMaker: data.m
                };

                state.recentTrades.unshift(trade);
                if (state.recentTrades.length > 20) {
                    state.recentTrades.pop();
                }

                this.updateTradesTable();
            }

            handleDepth(data) {
                state.orderbook = {
                    bids: data.bids.slice(0, 10),
                    asks: data.asks.slice(0, 10)
                };

                this.updateOrderbookTable();
                this.updateSpread();
            }

            handleKline(data) {
                const kline = data.k;
                if (kline.x) { // Only process closed candles
                    dataPipeline.addPriceData(kline);
                    state.priceData.push({
                        timestamp: kline.t,
                        open: parseFloat(kline.o),
                        high: parseFloat(kline.h),
                        low: parseFloat(kline.l),
                        close: parseFloat(kline.c),
                        volume: parseFloat(kline.v)
                    });

                    if (state.priceData.length > config.maxDataPoints) {
                        state.priceData.shift();
                    }

                    updateChart();
                }
            }

            updateTradesTable() {
                const tbody = document.getElementById('recentTrades');
                tbody.innerHTML = state.recentTrades.slice(0, 10).map(trade => `
                    <tr>
                        <td class="${trade.isBuyerMaker ? 'sell-signal' : 'buy-signal'}">${formatPrice(trade.price)}</td>
                        <td>${trade.quantity.toFixed(2)}</td>
                        <td>${trade.time}</td>
                    </tr>
                `).join('');
            }

            updateOrderbookTable() {
                const asksBody = document.getElementById('orderbookAsks');
                const bidsBody = document.getElementById('orderbookBids');

                asksBody.innerHTML = state.orderbook.asks.slice(0, 5).reverse().map(ask => `
                    <tr>
                        <td class="ask-price">${formatPrice(ask[0])}</td>
                        <td>${parseFloat(ask[1]).toFixed(2)}</td>
                        <td>${(parseFloat(ask[0]) * parseFloat(ask[1])).toFixed(2)}</td>
                    </tr>
                `).join('');

                bidsBody.innerHTML = state.orderbook.bids.slice(0, 5).map(bid => `
                    <tr>
                        <td class="bid-price">${formatPrice(bid[0])}</td>
                        <td>${parseFloat(bid[1]).toFixed(2)}</td>
                        <td>${(parseFloat(bid[0]) * parseFloat(bid[1])).toFixed(2)}</td>
                    </tr>
                `).join('');
            }

            updateSpread() {
                if (state.orderbook.bids.length && state.orderbook.asks.length) {
                    const bestBid = parseFloat(state.orderbook.bids[0][0]);
                    const bestAsk = parseFloat(state.orderbook.asks[0][0]);
                    const spread = bestAsk - bestBid;
                    
                    document.getElementById('spreadPrice').textContent = `Spread: ${spread.toFixed(6)}`;
                }
            }

            updateConnectionStatus() {
                const statusDot = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                if (state.connected) {
                    statusDot.classList.add('connected');
                    statusText.textContent = 'Connected';
                } else {
                    statusDot.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                }
            }

            handleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    log(`Reconnecting... Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                    
                    setTimeout(() => {
                        this.connect();
                    }, this.reconnectDelay * this.reconnectAttempts);
                } else {
                    log('Max reconnection attempts reached', 'error');
                }
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                }
            }
        }

        // Chart manager using Chart.js
        class ChartManager {
            constructor() {
                this.chart = null;
                this.initChart();
            }

            initChart() {
                const ctx = document.getElementById('priceChart').getContext('2d');
                
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Price',
                                data: [],
                                borderColor: '#f0b90b',
                                backgroundColor: 'rgba(240, 185, 11, 0.1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                pointHoverRadius: 4,
                                tension: 0.1,
                                yAxisID: 'price'
                            },
                            {
                                label: 'EMA 20',
                                data: [],
                                borderColor: '#02c076',
                                borderWidth: 1,
                                pointRadius: 0,
                                hidden: true,
                                yAxisID: 'price'
                            },
                            {
                                label: 'EMA 50',
                                data: [],
                                borderColor: '#ff4747',
                                borderWidth: 1,
                                pointRadius: 0,
                                hidden: true,
                                yAxisID: 'price'
                            },
                            {
                                label: 'RSI',
                                data: [],
                                borderColor: '#8884d8',
                                borderWidth: 1,
                                pointRadius: 0,
                                hidden: true,
                                yAxisID: 'rsi'
                            },
                            {
                                label: 'MACD',
                                data: [],
                                borderColor: '#82ca9d',
                                borderWidth: 1,
                                pointRadius: 0,
                                hidden: true,
                                yAxisID: 'macd'
                            },
                            {
                                label: 'BB Upper',
                                data: [],
                                borderColor: 'rgba(255, 71, 71, 0.5)',
                                borderWidth: 1,
                                pointRadius: 0,
                                hidden: true,
                                yAxisID: 'price'
                            },
                            {
                                label: 'BB Lower',
                                data: [],
                                borderColor: 'rgba(255, 71, 71, 0.5)',
                                borderWidth: 1,
                                pointRadius: 0,
                                hidden: true,
                                yAxisID: 'price'
                            },
                            {
                                label: 'VWAP',
                                data: [],
                                borderColor: '#ffa726',
                                borderWidth: 1,
                                pointRadius: 0,
                                hidden: true,
                                yAxisID: 'price'
                            },
                            {
                                label: 'Buy Signal',
                                data: [],
                                backgroundColor: 'rgba(2, 192, 118, 0.8)',
                                pointRadius: 6,
                                pointStyle: 'triangle',
                                showLine: false,
                                yAxisID: 'price'
                            },
                            {
                                label: 'Sell Signal',
                                data: [],
                                backgroundColor: 'rgba(255, 71, 71, 0.8)',
                                pointRadius: 6,
                                pointStyle: 'rectRot',
                                showLine: false,
                                yAxisID: 'price'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                backgroundColor: '#1e2329',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#f0b90b',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    displayFormats: {
                                        minute: 'HH:mm'
                                    }
                                },
                                grid: {
                                    color: '#2b3139'
                                },
                                ticks: {
                                    color: '#848e9c'
                                }
                            },
                            price: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                grid: {
                                    color: '#2b3139'
                                },
                                ticks: {
                                    color: '#848e9c',
                                    callback: function(value) {
                                        return 'body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1421;
            color: #ffffff;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 1px;
        }

        .header {
            grid-column: 1 / -1;
            background: #1e2329;
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid #2b3139;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #f0b90b;
            margin-right: 30px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4747;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #02c076;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .sidebar {
            background: #1e2329;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2b3139;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #848e9c;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #848e9c;
            margin-bottom: 5px;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 8px 12px;
            background: #2b3139;
            border: 1px solid #3e434d;
            border-radius: 4px;
            color: #ffffff;
            font-size: 12px;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #f0b90b;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #848e9c;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .btn {
            padding: 10px 16px;
            background: #f0b90b;
            color: #000;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #e6a800;
        }

        .btn-secondary {
            background: #2b3139;
            color: #ffffff;
        }

        .btn-secondary:hover {
            background: #3e434d;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .chart-container {
            flex: 2;
            background: #1e2329;
            padding: 15px;
            position: relative;
        }

        .indicators-panel {
            flex: 1;
            background: #1e2329;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .right-panel {
            background: #1e2329;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #2b3139;
        }

        .orderbook-section, .trades-section, .signals-section {
            flex: 1;
            padding: 15px;
            border-bottom: 1px solid #2b3139;
            overflow-y: auto;
        }

        .trades-section {
            border-bottom: none;
        }

        .price-display {
            font-size: 24px;
            font-weight: bold;
            color: #02c076;
            margin-bottom: 10px;
        }

        .price-change {
            font-size: 14px;
            color: #02c076;
        }

        .price-change.negative {
            color: #ff4747;
        }

        .orderbook-table, .trades-table, .signals-table {
            width: 100%;
            font-size: 11px;
        }

        .orderbook-table th, .trades-table th, .signals-table th {
            color: #848e9c;
            font-weight: 600;
            padding: 8px 4px;
            text-align: right;
            border-bottom: 1px solid #2b3139;
        }

        .orderbook-table td, .trades-table td, .signals-table td {
            padding: 4px;
            text-align: right;
        }

        .ask-price { color: #ff4747; }
        .bid-price { color: #02c076; }

        .buy-signal { color: #02c076; font-weight: bold; }
        .sell-signal { color: #ff4747; font-weight: bold; }
        .hold-signal { color: #848e9c; }

        .model-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .metric-card {
            background: #2b3139;
            padding: 12px;
            border-radius: 4px;
        }

        .metric-label {
            font-size: 11px;
            color: #848e9c;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 16px;
            font-weight: bold;
        }

        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 2px solid #2b3139;
            border-top: 2px solid #f0b90b;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .log-panel {
            background: #0d1421;
            max-height: 100px;
            overflow-y: auto;
            padding: 10px;
            font-size: 10px;
            color: #848e9c;
            font-family: 'Courier New', monospace;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
        }

        #priceChart {
            background: #1e2329;
        }

        .error {
            color: #ff4747;
            background: rgba(255, 71, 71, 0.1);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            margin: 10px 0;
        }

        .success {
            color: #02c076;
            background: rgba(2, 192, 118, 0.1);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="logo">WIF/USDT ML Predictor</div>
            <div class="status-indicator">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="statusText">Connecting...</span>
                <div class="price-display" id="currentPrice">$0.0000</div>
                <div class="price-change" id="priceChange">+0.00%</div>
            </div>
        </header>

        <aside class="sidebar">
            <div class="section">
                <div class="section-title">Data Sources</div>
                <div class="control-group">
                    <label>Update Interval (ms)</label>
                    <input type="number" id="updateInterval" value="1000" min="500" max="10000">
                </div>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableBinance" checked>
                        <label for="enableBinance">Binance WS</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableCoinGecko">
                        <label for="enableCoinGecko">CoinGecko</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableWhaleAlert">
                        <label for="enableWhaleAlert">Whale Alert</label>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Technical Indicators</div>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showEMA" checked>
                        <label for="showEMA">EMA(20,50)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showMACD">
                        <label for="showMACD">MACD</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showRSI">
                        <label for="showRSI">RSI</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showBB">
                        <label for="showBB">Bollinger</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showVWAP">
                        <label for="showVWAP">VWAP</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showOBV">
                        <label for="showOBV">OBV</label>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">ML Models</div>
                <div class="control-group">
                    <label>Sequence Length</label>
                    <input type="number" id="sequenceLength" value="60" min="10" max="200">
                </div>
                <div class="control-group">
                    <label>Prediction Horizon</label>
                    <select id="predictionHorizon">
                        <option value="1">1 minute</option>
                        <option value="5">5 minutes</option>
                        <option value="15" selected>15 minutes</option>
                        <option value="30">30 minutes</option>
                        <option value="60">1 hour</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableLinear" checked>
                        <label for="enableLinear">Linear Reg</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableMLP" checked>
                        <label for="enableMLP">MLP</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableLSTM">
                        <label for="enableLSTM">LSTM</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableCNN">
                        <label for="enableCNN">1D-CNN</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableTransformer">
                        <label for="enableTransformer">Transformer</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableEnsemble">
                        <label for="enableEnsemble">Ensemble</label>
                    </div>
                </div>
            </div>

            <div class="section">
                <button class="btn" id="startTraining">Start Training</button>
                <button class="btn btn-secondary" id="startPrediction">Start Prediction</button>
                <button class="btn btn-secondary" id="runBacktest">Run Backtest</button>
            </div>
        </aside>

        <main class="main-content">
            <div class="chart-container">
                <div class="canvas-container">
                    <canvas id="priceChart"></canvas>
                </div>
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <span>Loading models...</span>
                </div>
            </div>
            
            <div class="indicators-panel">
                <div class="section-title">Model Performance</div>
                <div class="model-metrics" id="modelMetrics">
                    <div class="metric-card">
                        <div class="metric-label">Directional Accuracy</div>
                        <div class="metric-value" id="directionalAccuracy">---%</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Sharpe Ratio</div>
                        <div class="metric-value" id="sharpeRatio">---</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Max Drawdown</div>
                        <div class="metric-value" id="maxDrawdown">---%</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total Return</div>
                        <div class="metric-value" id="totalReturn">---%</div>
                    </div>
                </div>
                <div class="log-panel" id="logPanel"></div>
            </div>
        </main>

        <aside class="right-panel">
            <div class="orderbook-section">
                <div class="section-title">Order Book</div>
                <table class="orderbook-table">
                    <thead>
                        <tr>
                            <th>Price</th>
                            <th>Amount</th>
                            <th>Total</th>
                        </tr>
                    </thead>
                    <tbody id="orderbookAsks"></tbody>
                </table>
                <div class="price-display" id="spreadPrice" style="text-align: center; font-size: 14px; margin: 10px 0;">
                    Spread: $0.0000
                </div>
                <table class="orderbook-table">
                    <tbody id="orderbookBids"></tbody>
                </table>
            </div>

            <div class="trades-section">
                <div class="section-title">Recent Trades</div>
                <table class="trades-table">
                    <thead>
                        <tr>
                            <th>Price</th>
                            <th>Amount</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody id="recentTrades"></tbody>
                </table>
            </div>

            <div class="signals-section">
                <div class="section-title">Trading Signals</div>
                <table class="signals-table">
                    <thead>
                        <tr>
                            <th>Model</th>
                            <th>Signal</th>
                            <th>Confidence</th>
                            <th>Price</th>
                        </tr>
                    </thead>
                    <tbody id="tradingSignals"></tbody>
                </table>
            </div>
        </aside>
    </div>

    <script>
        // Global state and configuration
        const state = {
            connected: false,
            priceData: [],
            orderbook: { bids: [], asks: [] },
            recentTrades: [],
            indicators: {},
            models: {},
            predictions: {},
            signals: [],
            isTraining: false,
            isPredicting: false
        };

        const config = {
            symbol: 'WIFUSDT',
            binanceWsUrl: 'wss://stream.binance.com:9443/ws/',
            updateInterval: 1000,
            maxDataPoints: 1000,
            features: [
                'open', 'high', 'low', 'close', 'volume',
                'ema20', 'ema50', 'macd', 'macdSignal', 'rsi',
                'bbUpper', 'bbLower', 'bbMiddle', 'vwap', 'obv',
                'bidAskSpread', 'depthImbalance', 'tradeImbalance',
                'volatility', 'momentum'
            ]
        };

        // Utility functions
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logPanel = document.getElementById('logPanel');
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            logPanel.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        function formatPrice(price) {
            return parseFloat(price).toFixed(4);
        }

        function formatPercent(value) {
            return (value * 100).toFixed(2) + '%';
        }

        // Technical indicators implementation
        class TechnicalIndicators {
            static ema(data, period) {
                const k = 2 / (period + 1);
                let ema = [data[0]];
                
                for (let i = 1; i < data.length; i++) {
                    ema.push(data[i] * k + ema[i - 1] * (1 - k));
                }
                
                return ema;
            }

            static sma(data, period) {
                const sma = [];
                for (let i = period - 1; i < data.length; i++) {
                    const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                    sma.push(sum / period);
                }
                return sma;
            }

            static rsi(prices, period = 14) {
                const gains = [];
                const losses = [];
                
                for (let i = 1; i < prices.length; i++) {
                    const change = prices[i] - prices[i - 1];
                    gains.push(change > 0 ? change : 0);
                    losses.push(change < 0 ? -change : 0);
                }
                
                let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
                let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
                
                const rsi = [100 - (100 / (1 + avgGain / avgLoss))];
                
                for (let i = period; i < gains.length; i++) {
                    avgGain = (avgGain * (period - 1) + gains[i]) / period;
                    avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
                    rsi.push(100 - (100 / (1 + avgGain / avgLoss)));
                }
                
                return rsi;
            }

            static macd(prices, fast = 12, slow = 26, signal = 9) {
                const emaFast = this.ema(prices, fast);
                const emaSlow = this.ema(prices, slow);
                
                const macd = [];
                for (let i = 0; i < Math.min(emaFast.length, emaSlow.length); i++) {
                    macd.push(emaFast[i] - emaSlow[i]);
                }
                
                const macdSignal = this.ema(macd, signal);
                return { macd, signal: macdSignal };
            }

            static bollingerBands(prices, period = 20, stdDev = 2) {
                const sma = this.sma(prices, period);
                const bands = { upper: [], middle: [], lower: [] };
                
                for (let i = 0; i < sma.length; i++) {
                    const slice = prices.slice(i, i + period);
                    const mean = sma[i];
                    const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
                    const std = Math.sqrt(variance);
                    
                    bands.upper.push(mean + stdDev * std);
                    bands.middle.push(mean);
                    bands.lower.push(mean - stdDev * std);
                }
                
                return bands;
            }

            static vwap(highs, lows, closes, volumes) {
                const typical = [];
                const vwap = [];
                let cumVolume = 0;
                let cumVolumePrice = 0;
                
                for (let i = 0; i < closes.length; i++) {
                    const typicalPrice = (highs[i] + lows[i] + closes[i]) / 3;
                    typical.push(typicalPrice);
                    
                    cumVolume += volumes[i];
                    cumVolumePrice += typicalPrice * volumes[i];
                    
                    vwap.push(cumVolumePrice / cumVolume);
                }
                
                return vwap;
            }

            static obv(closes, volumes) {
                const obv = [volumes[0]];
                
                for (let i = 1; i < closes.length; i++) {
                    if (closes[i] > closes[i - 1]) {
                        obv.push(obv[i - 1] + volumes[i]);
                    } else if (closes[i] < closes[i - 1]) {
                        obv.push(obv[i - 1] - volumes[i]);
                    } else {
                        obv.push(obv[i - 1]);
                    }
                }
                
                return obv;
            }
        }

        // ML Models implementation
        class MLModels {
            constructor() {
                this.models = {};
                this.scaler = null;
            }

            normalizeData(data) {
                if (!this.scaler) {
                    this.scaler = {
                        mean: data.reduce((sum, val) => sum + val, 0) / data.length,
                        std: 0
                    };
                    
                    const variance = data.reduce((sum, val) => sum + Math.pow(val - this.scaler.mean, 2), 0) / data.length;
                    this.scaler.std = Math.sqrt(variance);
                }
                
                return data.map(val => (val - this.scaler.mean) / this.scaler.std);
            }

            createLinearModel(inputShape) {
                const model = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [inputShape], units: 1, activation: 'linear' })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }

            createMLPModel(inputShape) {
                const model = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [inputShape], units: 64, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }

            createLSTMModel(timesteps, features) {
                const model = tf.sequential({
                    layers: [
                        tf.layers.lstm({ 
                            inputShape: [timesteps, features], 
                            units: 50, 
                            returnSequences: true 
                        }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.lstm({ units: 50, returnSequences: false }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 25, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }

            createCNNModel(timesteps, features) {
                const model = tf.sequential({
                    layers: [
                        tf.layers.reshape({ inputShape: [timesteps, features], targetShape: [timesteps, features, 1] }),
                        tf.layers.conv2d({ filters: 64, kernelSize: [3, 1], activation: 'relu', padding: 'same' }),
                        tf.layers.conv2d({ filters: 64, kernelSize: [3, 1], activation: 'relu', padding: 'same' }),
                        tf.layers.maxPooling2d({ poolSize: [2, 1] }),
                        tf.layers.dropout({ rate: 0.25 }),
                        tf.layers.flatten(),
                        tf.layers.dense({ units: 50, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.5 }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }

            async trainModel(modelType, X, y, epochs = 50) {
                try {
                    log(`Training ${modelType} model...`);
                    
                    let model;
                    const inputShape = X.shape[1];
                    
                    switch (modelType) {
                        case 'linear':
                            model = this.createLinearModel(inputShape);
                            break;
                        case 'mlp':
                            model = this.createMLPModel(inputShape);
                            break;
                        case 'lstm':
                            model = this.createLSTMModel(X.shape[1], X.shape[2]);
                            break;
                        case 'cnn':
                            model = this.createCNNModel(X.shape[1], X.shape[2]);
                            break;
                        default:
                            throw new Error(`Unknown model type: ${modelType}`);
                    }
                    
                    const history = await model.fit(X, y, {
                        epochs: epochs,
                        batchSize: 32,
                        validationSplit: 0.2,
                        shuffle: true,
                        verbose: 0,
                        callbacks: {
                            onEpochEnd: (epoch, logs) => {
                                if (epoch % 10 === 0) {
                                    log(`${modelType} epoch ${epoch}: loss=${logs.loss.toFixed(4)}, val_loss=${logs.val_loss.toFixed(4)}`);
                                }
                            }
                        }
                    });
                    
                    this.models[modelType] = model;
                    log(`${modelType} model training completed`, 'success');
                    
                    return history;
                } catch (error) {
                    log(`Error training ${modelType} model: ${error.message}`, 'error');
                    throw error;
                }
            }

            predict(modelType, X) {
                if (!this.models[modelType]) {
                    throw new Error(`Model ${modelType} not trained yet`);
                }
                
                return this.models[modelType].predict(X);
            }
        }

         + value.toFixed(4);
                                    }
                                }
                            },
                            rsi: {
                                type: 'linear',
                                display: false,
                                position: 'right',
                                min: 0,
                                max: 100,
                                grid: {
                                    drawOnChartArea: false
                                }
                            },
                            macd: {
                                type: 'linear',
                                display: false,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false
                                }
                            }
                        },
                        animation: {
                            duration: 0
                        }
                    }
                });
            }

            updateChart() {
                if (!this.chart || state.priceData.length === 0) return;

                const labels = state.priceData.map(d => new Date(d.timestamp));
                const prices = state.priceData.map(d => d.close);
                
                // Update price data
                this.chart.data.labels = labels;
                this.chart.data.datasets[0].data = prices;

                // Update indicators if available
                if (state.indicators && state.priceData.length > 0) {
                    const indicatorLength = Math.min(prices.length, 100); // Show last 100 points
                    
                    // EMA lines
                    if (document.getElementById('showEMA').checked && state.indicators.ema20) {
                        this.chart.data.datasets[1].data = Array(prices.length - 1).fill(null).concat([state.indicators.ema20]);
                        this.chart.data.datasets[1].hidden = false;
                        
                        this.chart.data.datasets[2].data = Array(prices.length - 1).fill(null).concat([state.indicators.ema50]);
                        this.chart.data.datasets[2].hidden = false;
                    } else {
                        this.chart.data.datasets[1].hidden = true;
                        this.chart.data.datasets[2].hidden = true;
                    }

                    // RSI
                    if (document.getElementById('showRSI').checked && state.indicators.rsi) {
                        this.chart.data.datasets[3].data = Array(prices.length - 1).fill(null).concat([state.indicators.rsi]);
                        this.chart.data.datasets[3].hidden = false;
                        this.chart.options.scales.rsi.display = true;
                    } else {
                        this.chart.data.datasets[3].hidden = true;
                        this.chart.options.scales.rsi.display = false;
                    }

                    // MACD
                    if (document.getElementById('showMACD').checked && state.indicators.macd) {
                        this.chart.data.datasets[4].data = Array(prices.length - 1).fill(null).concat([state.indicators.macd]);
                        this.chart.data.datasets[4].hidden = false;
                        this.chart.options.scales.macd.display = true;
                    } else {
                        this.chart.data.datasets[4].hidden = true;
                        this.chart.options.scales.macd.display = false;
                    }

                    // Bollinger Bands
                    if (document.getElementById('showBB').checked && state.indicators.bbUpper) {
                        this.chart.data.datasets[5].data = Array(prices.length - 1).fill(null).concat([state.indicators.bbUpper]);
                        this.chart.data.datasets[6].data = Array(prices.length - 1).fill(null).concat([state.indicators.bbLower]);
                        this.chart.data.datasets[5].hidden = false;
                        this.chart.data.datasets[6].hidden = false;
                    } else {
                        this.chart.data.datasets[5].hidden = true;
                        this.chart.data.datasets[6].hidden = true;
                    }

                    // VWAP
                    if (document.getElementById('showVWAP').checked && state.indicators.vwap) {
                        this.chart.data.datasets[7].data = Array(prices.length - 1).fill(null).concat([state.indicators.vwap]);
                        this.chart.data.datasets[7].hidden = false;
                    } else {
                        this.chart.data.datasets[7].hidden = true;
                    }
                }

                // Update trading signals
                this.updateSignals();

                this.chart.update('none'); // Update without animation
            }

            updateSignals() {
                const buySignals = [];
                const sellSignals = [];

                state.signals.forEach((signal, index) => {
                    const dataIndex = state.priceData.length - state.signals.length + index;
                    if (dataIndex >= 0 && dataIndex < state.priceData.length) {
                        const price = state.priceData[dataIndex].close;
                        
                        if (signal.action === 'BUY') {
                            buySignals.push({ x: dataIndex, y: price });
                        } else if (signal.action === 'SELL') {
                            sellSignals.push({ x: dataIndex, y: price });
                        }
                    }
                });

                this.chart.data.datasets[8].data = buySignals;
                this.chart.data.datasets[9].data = sellSignals;
            }
        }

        // Signal generator
        class SignalGenerator {
            constructor() {
                this.models = new MLModels();
                this.lastSignals = {};
            }

            async generateSignals() {
                if (!state.isPredicting || state.priceData.length < 60) return;

                const signals = [];
                const currentPrice = state.priceData[state.priceData.length - 1].close;

                // Technical analysis signals
                const technicalSignal = this.generateTechnicalSignal();
                if (technicalSignal) {
                    signals.push({
                        model: 'Technical',
                        action: technicalSignal.action,
                        confidence: technicalSignal.confidence,
                        price: currentPrice,
                        timestamp: Date.now()
                    });
                }

                // ML model signals
                for (const modelType of Object.keys(this.models.models)) {
                    try {
                        const mlSignal = await this.generateMLSignal(modelType);
                        if (mlSignal) {
                            signals.push({
                                model: modelType.toUpperCase(),
                                action: mlSignal.action,
                                confidence: mlSignal.confidence,
                                price: currentPrice,
                                timestamp: Date.now()
                            });
                        }
                    } catch (error) {
                        log(`Error generating ${modelType} signal: ${error.message}`, 'error');
                    }
                }

                // Ensemble signal
                const ensembleSignal = this.generateEnsembleSignal(signals);
                if (ensembleSignal) {
                    signals.push(ensembleSignal);
                }

                state.signals = signals;
                this.updateSignalsTable();
            }

            generateTechnicalSignal() {
                if (!state.indicators) return null;

                const { rsi, macd, macdSignal, ema20, ema50 } = state.indicators;
                const currentPrice = state.priceData[state.priceData.length - 1].close;
                
                let bullishSignals = 0;
                let bearishSignals = 0;

                // RSI signals
                if (rsi < 30) bullishSignals += 2; // Oversold
                if (rsi > 70) bearishSignals += 2; // Overbought
                if (rsi > 50) bullishSignals += 1;
                if (rsi < 50) bearishSignals += 1;

                // MACD signals
                if (macd > macdSignal) bullishSignals += 1;
                if (macd < macdSignal) bearishSignals += 1;

                // EMA signals
                if (currentPrice > ema20 && ema20 > ema50) bullishSignals += 2;
                if (currentPrice < ema20 && ema20 < ema50) bearishSignals += 2;

                const totalSignals = bullishSignals + bearishSignals;
                if (totalSignals === 0) return null;

                const confidence = Math.abs(bullishSignals - bearishSignals) / Math.max(bullishSignals, bearishSignals);
                
                if (bullishSignals > bearishSignals && confidence > 0.3) {
                    return { action: 'BUY', confidence: confidence };
                } else if (bearishSignals > bullishSignals && confidence > 0.3) {
                    return { action: 'SELL', confidence: confidence };
                }

                return { action: 'HOLD', confidence: 0 };
            }

            async generateMLSignal(modelType) {
                try {
                    const sequenceLength = parseInt(document.getElementById('sequenceLength').value);
                    if (dataPipeline.features.length < sequenceLength) return null;

                    const features = dataPipeline.features.slice(-sequenceLength);
                    const X = tf.tensor3d([features]);
                    
                    const prediction = this.models.predict(modelType, X);
                    const predictionValue = await prediction.data();
                    
                    X.dispose();
                    prediction.dispose();

                    const expectedReturn = predictionValue[0];
                    const confidence = Math.min(Math.abs(expectedReturn) * 10, 1); // Scale to 0-1

                    let action = 'HOLD';
                    if (expectedReturn > 0.001) action = 'BUY'; // > 0.1% expected return
                    if (expectedReturn < -0.001) action = 'SELL'; // < -0.1% expected return

                    return { action, confidence };
                } catch (error) {
                    console.error(`Error in ML signal generation for ${modelType}:`, error);
                    return null;
                }
            }

            generateEnsembleSignal(signals) {
                if (signals.length < 2) return null;

                let buyScore = 0;
                let sellScore = 0;
                let totalConfidence = 0;

                signals.forEach(signal => {
                    if (signal.action === 'BUY') {
                        buyScore += signal.confidence;
                    } else if (signal.action === 'SELL') {
                        sellScore += signal.confidence;
                    }
                    totalConfidence += signal.confidence;
                });

                if (totalConfidence === 0) return null;

                const buyWeight = buyScore / totalConfidence;
                const sellWeight = sellScore / totalConfidence;
                
                const currentPrice = state.priceData[state.priceData.length - 1].close;
                let action = 'HOLD';
                let confidence = 0;

                if (buyWeight > 0.6) {
                    action = 'BUY';
                    confidence = buyWeight;
                } else if (sellWeight > 0.6) {
                    action = 'SELL';
                    confidence = sellWeight;
                }

                return {
                    model: 'ENSEMBLE',
                    action,
                    confidence,
                    price: currentPrice,
                    timestamp: Date.now()
                };
            }

            updateSignalsTable() {
                const tbody = document.getElementById('tradingSignals');
                tbody.innerHTML = state.signals.map(signal => `
                    <tr>
                        <td>${signal.model}</td>
                        <td class="${signal.action.toLowerCase()}-signal">${signal.action}</td>
                        <td>${(signal.confidence * 100).toFixed(1)}%</td>
                        <td>${formatPrice(signal.price)}</td>
                    </tr>
                `).join('');
            }
        }

        // Backtesting engine
        class BacktestEngine {
            constructor() {
                this.results = {};
            }

            async runBacktest(startDate, endDate, initialCapital = 10000) {
                try {
                    log('Starting backtest...', 'info');
                    document.getElementById('loadingIndicator').classList.add('show');

                    const testData = this.prepareBacktestData(startDate, endDate);
                    if (!testData || testData.length < 100) {
                        throw new Error('Insufficient data for backtesting');
                    }

                    const results = {
                        trades: [],
                        portfolio: [initialCapital],
                        returns: [],
                        signals: [],
                        metrics: {}
                    };

                    let capital = initialCapital;
                    let position = 0; // 0 = no position, 1 = long, -1 = short
                    let entryPrice = 0;
                    let totalTrades = 0;
                    let winningTrades = 0;

                    // Simulate trading based on signals
                    for (let i = 60; i < testData.length - 1; i++) {
                        const currentPrice = testData[i].close;
                        const nextPrice = testData[i + 1].close;
                        
                        // Generate signals for current position
                        const signal = this.generateBacktestSignal(testData, i);
                        results.signals.push(signal);

                        // Trading logic
                        if (position === 0 && signal.action === 'BUY') {
                            // Enter long position
                            position = 1;
                            entryPrice = currentPrice * 1.001; // Include slippage
                            results.trades.push({
                                type: 'BUY',
                                price: entryPrice,
                                timestamp: testData[i].timestamp,
                                signal: signal.model
                            });
                        } else if (position === 1 && (signal.action === 'SELL' || this.shouldStopLoss(currentPrice, entryPrice))) {
                            // Exit long position
                            const exitPrice = currentPrice * 0.999; // Include slippage
                            const tradeReturn = (exitPrice - entryPrice) / entryPrice - 0.001; // Include fees
                            
                            capital *= (1 + tradeReturn);
                            totalTrades++;
                            if (tradeReturn > 0) winningTrades++;

                            results.trades.push({
                                type: 'SELL',
                                price: exitPrice,
                                timestamp: testData[i].timestamp,
                                return: tradeReturn,
                                signal: signal.model
                            });

                            position = 0;
                            entryPrice = 0;
                        }

                        // Calculate portfolio value
                        let portfolioValue = capital;
                        if (position === 1) {
                            portfolioValue = capital * (currentPrice / entryPrice);
                        }

                        results.portfolio.push(portfolioValue);
                        results.returns.push((portfolioValue - initialCapital) / initialCapital);
                    }

                    // Calculate performance metrics
                    results.metrics = this.calculateMetrics(results, initialCapital);
                    
                    log(`Backtest completed. Total trades: ${totalTrades}, Win rate: ${(winningTrades/totalTrades*100).toFixed(1)}%`, 'success');
                    this.displayBacktestResults(results);
                    
                    return results;

                } catch (error) {
                    log(`Backtest error: ${error.message}`, 'error');
                    throw error;
                } finally {
                    document.getElementById('loadingIndicator').classList.remove('show');
                }
            }

            prepareBacktestData(startDate, endDate) {
                // For demo, use current price data
                // In real implementation, fetch historical data from API
                return state.priceData.slice(-500); // Use last 500 data points
            }

            generateBacktestSignal(data, index) {
                // Simplified signal generation for backtesting
                if (index < 20) return { action: 'HOLD', model: 'BACKTEST' };

                const closes = data.slice(index - 20, index + 1).map(d => d.close);
                const sma20 = closes.reduce((a, b) => a + b, 0) / closes.length;
                const sma5 = closes.slice(-5).reduce((a, b) => a + b, 0) / 5;
                
                const rsi = TechnicalIndicators.rsi(closes, 14);
                const currentRSI = rsi[rsi.length - 1];

                let action = 'HOLD';
                
                // Simple momentum + RSI strategy
                if (sma5 > sma20 * 1.002 && currentRSI < 70) {
                    action = 'BUY';
                } else if (sma5 < sma20 * 0.998 || currentRSI > 80) {
                    action = 'SELL';
                }

                return { action, model: 'BACKTEST' };
            }

            shouldStopLoss(currentPrice, entryPrice, stopLossPercent = 0.02) {
                return (entryPrice - currentPrice) / entryPrice > stopLossPercent;
            }

            calculateMetrics(results, initialCapital) {
                const returns = results.returns;
                const trades = results.trades;
                
                const totalReturn = (results.portfolio[results.portfolio.length - 1] - initialCapital) / initialCapital;
                
                // Sharpe ratio (annualized)
                const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
                const returnStd = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
                const sharpeRatio = returnStd > 0 ? (avgReturn * Math.sqrt(365 * 24 * 60)) / (returnStd * Math.sqrt(365 * 24 * 60)) : 0;

                // Maximum drawdown
                let maxDrawdown = 0;
                let peak = results.portfolio[0];
                
                for (const value of results.portfolio) {
                    if (value > peak) peak = value;
                    const drawdown = (peak - value) / peak;
                    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
                }

                // Win rate
                const profitableTrades = trades.filter(t => t.return && t.return > 0).length;
                const totalTrades = trades.filter(t => t.return !== undefined).length;
                const winRate = totalTrades > 0 ? profitableTrades / totalTrades : 0;

                return {
                    totalReturn,
                    sharpeRatio,
                    maxDrawdown,
                    winRate,
                    totalTrades,
                    profitableTrades
                };
            }

            displayBacktestResults(results) {
                const metrics = results.metrics;
                
                document.getElementById('directionalAccuracy').textContent = formatPercent(metrics.winRate);
                document.getElementById('sharpeRatio').textContent = metrics.sharpeRatio.toFixed(2);
                document.getElementById('maxDrawdown').textContent = formatPercent(metrics.maxDrawdown);
                document.getElementById('totalReturn').textContent = formatPercent(metrics.totalReturn);

                log(`Backtest Results:`, 'info');
                log(`Total Return: ${formatPercent(metrics.totalReturn)}`, 'info');
                log(`Sharpe Ratio: ${metrics.sharpeRatio.toFixed(2)}`, 'info');
                log(`Max Drawdown: ${formatPercent(metrics.maxDrawdown)}`, 'info');
                log(`Win Rate: ${formatPercent(metrics.winRate)}`, 'info');
                log(`Total Trades: ${metrics.totalTrades}`, 'info');
            }
        }

        // Training manager
        class TrainingManager {
            constructor() {
                this.models = new MLModels();
            }

            async startTraining() {
                if (state.isTraining) {
                    log('Training already in progress', 'error');
                    return;
                }

                try {
                    state.isTraining = true;
                    document.getElementById('loadingIndicator').classList.add('show');
                    log('Starting model training...', 'info');

                    // Check data availability
                    if (dataPipeline.features.length < 100) {
                        throw new Error('Insufficient data for training. Need at least 100 data points.');
                    }

                    const sequenceLength = parseInt(document.getElementById('sequenceLength').value);
                    const predictionHorizon = parseInt(document.getElementById('predictionHorizon').value);
                    
                    const { X, y } = dataPipeline.createSequences(sequenceLength, predictionHorizon);
                    
                    if (!X || !y) {
                        throw new Error('Failed to create training sequences');
                    }

                    log(`Training data shape: X=${X.shape}, y=${y.shape}`, 'info');

                    // Train enabled models
                    const enabledModels = this.getEnabledModels();
                    
                    for (const modelType of enabledModels) {
                        try {
                            await this.models.trainModel(modelType, X, y, 30); // 30 epochs for demo
                            log(`${modelType} model training completed successfully`, 'success');
                        } catch (error) {
                            log(`Failed to train ${modelType}: ${error.message}`, 'error');
                        }
                    }

                    // Clean up tensors
                    X.dispose();
                    y.dispose();

                    log('All model training completed', 'success');
                    
                    // Start prediction if not already running
                    if (!state.isPredicting) {
                        setTimeout(() => this.startPrediction(), 1000);
                    }

                } catch (error) {
                    log(`Training error: ${error.message}`, 'error');
                } finally {
                    state.isTraining = false;
                    document.getElementById('loadingIndicator').classList.remove('show');
                }
            }

            startPrediction() {
                if (state.isPredicting) {
                    state.isPredicting = false;
                    log('Prediction stopped', 'info');
                    return;
                }

                if (Object.keys(this.models.models).length === 0) {
                    log('No trained models available. Please train models first.', 'error');
                    return;
                }

                state.isPredicting = true;
                log('Real-time prediction started', 'success');
                
                // Start prediction loop
                this.predictionLoop();
            }

            async predictionLoop() {
                if (!state.isPredicting) return;

                try {
                    await signalGenerator.generateSignals();
                } catch (error) {
                    log(`Prediction error: ${error.message}`, 'error');
                }

                // Schedule next prediction
                setTimeout(() => this.predictionLoop(), 5000); // Every 5 seconds
            }

            getEnabledModels() {
                const models = [];
                if (document.getElementById('enableLinear').checked) models.push('linear');
                if (document.getElementById('enableMLP').checked) models.push('mlp');
                if (document.getElementById('enableLSTM').checked) models.push('lstm');
                if (document.getElementById('enableCNN').checked) models.push('cnn');
                return models;
            }
        }

        // Initialize global objects
        const wsManager = new WebSocketManager();
        const chartManager = new ChartManager();
        const dataPipeline = new DataPipeline();
        const signalGenerator = new SignalGenerator();
        const backtestEngine = new BacktestEngine();
        const trainingManager = new TrainingManager();

        // Chart update function
        function updateChart() {
            chartManager.updateChart();
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            log('WIF/USDT ML Predictor initialized', 'success');
            
            // Connect to WebSocket
            wsManager.connect();

            // Button event listeners
            document.getElementById('startTraining').addEventListener('click', () => {
                trainingManager.startTraining();
            });

            document.getElementById('startPrediction').addEventListener('click', () => {
                trainingManager.startPrediction();
            });

            document.getElementById('runBacktest').addEventListener('click', () => {
                backtestEngine.runBacktest(
                    Date.now() - 30 * 24 * 60 * 60 * 1000, // 30 days ago
                    Date.now(),
                    10000 // $10,000 initial capital
                );
            });

            // Indicator checkbox listeners
            document.getElementById('showEMA').addEventListener('change', updateChart);
            document.getElementById('showMACD').addEventListener('change', updateChart);
            document.getElementById('showRSI').addEventListener('change', updateChart);
            document.getElementById('showBB').addEventListener('change', updateChart);
            document.getElementById('showVWAP').addEventListener('change', updateChart);
            document.getElementById('showOBV').addEventListener('change', updateChart);

            // Auto-retrain every hour
            setInterval(() => {
                if (state.priceData.length >= 200 && !state.isTraining) {
                    log('Auto-retraining models...', 'info');
                    trainingManager.startTraining();
                }
            }, 60 * 60 * 1000); // 1 hour

            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                wsManager.disconnect();
                state.isPredicting = false;
                state.isTraining = false;
            });
        });

        // Additional whale alert and social sentiment integration
        class WhaleAlertManager {
            constructor() {
                this.alerts = [];
                this.enabled = false;
            }

            enable() {
                this.enabled = true;
                // In production, implement WebSocket connection to Whale Alert API
                // this.connectWhaleAlert();
                
                // For demo, simulate whale alerts
                this.simulateWhaleAlerts();
            }

            simulateWhaleAlerts() {
                if (!this.enabled) return;

                setInterval(() => {
                    const randomAmount = Math.random() * 1000000;
                    if (randomAmount > 100000) { // Only significant transfers
                        const alert = {
                            amount: randomAmount,
                            symbol: 'WIF',
                            from: 'unknown',
                            to: 'binance',
                            timestamp: Date.now(),
                            impact: this.calculateImpact(randomAmount)
                        };
                        
                        this.alerts.unshift(alert);
                        if (this.alerts.length > 10) {
                            this.alerts.pop();
                        }
                        
                        log(`Whale Alert: ${randomAmount.toFixed(0)} WIF transferred to Binance`, 'info');
                        this.updateWhaleMetrics();
                    }
                }, 30000); // Every 30 seconds
            }

            calculateImpact(amount) {
                // Simplified impact calculation
                const totalSupply = 998000000000; // WIF total supply
                const impact = amount / totalSupply;
                
                if (impact > 0.001) return 'HIGH';
                if (impact > 0.0001) return 'MEDIUM';
                return 'LOW';
            }

            updateWhaleMetrics() {
                // Calculate whale pressure index
                const recentAlerts = this.alerts.filter(a => Date.now() - a.timestamp < 60 * 60 * 1000);
                const totalVolume = recentAlerts.reduce((sum, a) => sum + a.amount, 0);
                
                const whaleIndex = Math.min(totalVolume / 10000000, 1); // Normalize to 0-1
                
                // Update UI or state with whale metrics
                state.whaleMetrics = {
                    pressure: whaleIndex,
                    recentAlerts: recentAlerts.length,
                    totalVolume: totalVolume
                };
            }
        }

        class SocialSentimentManager {
            constructor() {
                this.sentiment = 0.5; // Neutral
                this.enabled = false;
            }

            enable() {
                this.enabled = true;
                // In production, implement Twitter API, Reddit API, etc.
                // this.connectSocialAPIs();
                
                // For demo, simulate sentiment changes
                this.simulateSentiment();
            }

            simulateSentiment() {
                if (!this.enabled) return;

                setInterval(() => {
                    // Random walk for sentiment
                    const change = (Math.random() - 0.5) * 0.1;
                    this.sentiment = Math.max(0, Math.min(1, this.sentiment + change));
                    
                    state.socialSentiment = {
                        score: this.sentiment,
                        trend: change > 0 ? 'POSITIVE' : 'NEGATIVE',
                        strength: Math.abs(change) * 10
                    };
                    
                    if (Math.abs(change) > 0.03) {
                        log(`Social sentiment shift: ${state.socialSentiment.trend} (${(this.sentiment * 100).toFixed(1)}%)`, 'info');
                    }
                }, 60000); // Every minute
            }
        }

        // Initialize additional managers
        const whaleAlert = new WhaleAlertManager();
        const socialSentiment = new SocialSentimentManager();

        // Enable whale alerts and social sentiment when data sources are enabled
        document.getElementById('enableWhaleAlert').addEventListener('change', (e) => {
            if (e.target.checked) {
                whaleAlert.enable();
            } else {
                whaleAlert.enabled = false;
            }
        });

        // Advanced composite signals
        class CompositeSignalGenerator {
            constructor() {
                this.whalePressureWeight = 0.2;
                this.socialSentimentWeight = 0.15;
                this.technicalWeight = 0.4;
                this.mlWeight = 0.25;
            }

            generateCompositeSignal() {
                let compositeScore = 0;
                let totalWeight = 0;

                // Technical analysis component
                const technicalSignal = signalGenerator.generateTechnicalSignal();
                if (technicalSignal) {
                    const technicalScore = technicalSignal.action === 'BUY' ? 1 : 
                                         technicalSignal.action === 'SELL' ? -1 : 0;
                    compositeScore += technicalScore * technicalSignal.confidence * this.technicalWeight;
                    totalWeight += this.technicalWeight;
                }

                // Whale pressure component
                if (state.whaleMetrics) {
                    const whaleScore = state.whaleMetrics.pressure > 0.5 ? -0.5 : 0.5; // High whale activity = bearish
                    compositeScore += whaleScore * this.whalePressureWeight;
                    totalWeight += this.whalePressureWeight;
                }

                // Social sentiment component
                if (state.socialSentiment) {
                    const sentimentScore = (state.socialSentiment.score - 0.5) * 2; // Scale to -1 to 1
                    compositeScore += sentimentScore * this.socialSentimentWeight;
                    totalWeight += this.socialSentimentWeight;
                }

                // ML ensemble component
                const mlSignals = state.signals.filter(s => s.model !== 'Technical' && s.model !== 'ENSEMBLE');
                if (mlSignals.length > 0) {
                    const avgMLScore = mlSignals.reduce((sum, s) => {
                        const score = s.action === 'BUY' ? 1 : s.action === 'SELL' ? -1 : 0;
                        return sum + score * s.confidence;
                    }, 0) / mlSignals.length;
                    
                    compositeScore += avgMLScore * this.mlWeight;
                    totalWeight += this.mlWeight;
                }

                if (totalWeight === 0) return null;

                const normalizedScore = compositeScore / totalWeight;
                const confidence = Math.abs(normalizedScore);
                
                let action = 'HOLD';
                if (normalizedScore > 0.3) action = 'BUY';
                if (normalizedScore < -0.3) action = 'SELL';

                return {
                    model: 'COMPOSITE',
                    action,
                    confidence,
                    price: state.priceData[state.priceData.length - 1]?.close || 0,
                    timestamp: Date.now(),
                    components: {
                        technical: technicalSignal?.confidence || 0,
                        whale: state.whaleMetrics?.pressure || 0,
                        sentiment: state.socialSentiment?.score || 0.5,
                        ml: mlSignals.length
                    }
                };
            }
        }

        const compositeSignalGenerator = new CompositeSignalGenerator();

        // Enhanced signal generation with composite signals
        const originalGenerateSignals = signalGenerator.generateSignals.bind(signalGenerator);
        signalGenerator.generateSignals = async function() {
            await originalGenerateSignals();
            
            // Add composite signal
            const compositeSignal = compositeSignalGenerator.generateCompositeSignal();
            if (compositeSignal) {
                state.signals.push(compositeSignal);
                this.updateSignalsTable();
            }
        };

        log('Advanced WIF/USDT ML Price Predictor loaded successfully', 'success');
        log('Features: Real-time data, 6 ML models, Technical analysis, Whale alerts, Social sentiment', 'info');
        log('Ready to connect and start trading analysis...', 'info');
    </script>
</body>
</html>body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1421;
            color: #ffffff;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 1px;
        }

        .header {
            grid-column: 1 / -1;
            background: #1e2329;
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid #2b3139;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #f0b90b;
            margin-right: 30px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4747;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #02c076;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .sidebar {
            background: #1e2329;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2b3139;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #848e9c;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #848e9c;
            margin-bottom: 5px;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 8px 12px;
            background: #2b3139;
            border: 1px solid #3e434d;
            border-radius: 4px;
            color: #ffffff;
            font-size: 12px;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #f0b90b;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #848e9c;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .btn {
            padding: 10px 16px;
            background: #f0b90b;
            color: #000;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #e6a800;
        }

        .btn-secondary {
            background: #2b3139;
            color: #ffffff;
        }

        .btn-secondary:hover {
            background: #3e434d;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .chart-container {
            flex: 2;
            background: #1e2329;
            padding: 15px;
            position: relative;
        }

        .indicators-panel {
            flex: 1;
            background: #1e2329;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .right-panel {
            background: #1e2329;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #2b3139;
        }

        .orderbook-section, .trades-section, .signals-section {
            flex: 1;
            padding: 15px;
            border-bottom: 1px solid #2b3139;
            overflow-y: auto;
        }

        .trades-section {
            border-bottom: none;
        }

        .price-display {
            font-size: 24px;
            font-weight: bold;
            color: #02c076;
            margin-bottom: 10px;
        }

        .price-change {
            font-size: 14px;
            color: #02c076;
        }

        .price-change.negative {
            color: #ff4747;
        }

        .orderbook-table, .trades-table, .signals-table {
            width: 100%;
            font-size: 11px;
        }

        .orderbook-table th, .trades-table th, .signals-table th {
            color: #848e9c;
            font-weight: 600;
            padding: 8px 4px;
            text-align: right;
            border-bottom: 1px solid #2b3139;
        }

        .orderbook-table td, .trades-table td, .signals-table td {
            padding: 4px;
            text-align: right;
        }

        .ask-price { color: #ff4747; }
        .bid-price { color: #02c076; }

        .buy-signal { color: #02c076; font-weight: bold; }
        .sell-signal { color: #ff4747; font-weight: bold; }
        .hold-signal { color: #848e9c; }

        .model-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .metric-card {
            background: #2b3139;
            padding: 12px;
            border-radius: 4px;
        }

        .metric-label {
            font-size: 11px;
            color: #848e9c;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 16px;
            font-weight: bold;
        }

        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 2px solid #2b3139;
            border-top: 2px solid #f0b90b;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .log-panel {
            background: #0d1421;
            max-height: 100px;
            overflow-y: auto;
            padding: 10px;
            font-size: 10px;
            color: #848e9c;
            font-family: 'Courier New', monospace;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
        }

        #priceChart {
            background: #1e2329;
        }

        .error {
            color: #ff4747;
            background: rgba(255, 71, 71, 0.1);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            margin: 10px 0;
        }

        .success {
            color: #02c076;
            background: rgba(2, 192, 118, 0.1);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="logo">WIF/USDT ML Predictor</div>
            <div class="status-indicator">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="statusText">Connecting...</span>
                <div class="price-display" id="currentPrice">$0.0000</div>
                <div class="price-change" id="priceChange">+0.00%</div>
            </div>
        </header>

        <aside class="sidebar">
            <div class="section">
                <div class="section-title">Data Sources</div>
                <div class="control-group">
                    <label>Update Interval (ms)</label>
                    <input type="number" id="updateInterval" value="1000" min="500" max="10000">
                </div>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableBinance" checked>
                        <label for="enableBinance">Binance WS</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableCoinGecko">
                        <label for="enableCoinGecko">CoinGecko</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableWhaleAlert">
                        <label for="enableWhaleAlert">Whale Alert</label>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Technical Indicators</div>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showEMA" checked>
                        <label for="showEMA">EMA(20,50)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showMACD">
                        <label for="showMACD">MACD</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showRSI">
                        <label for="showRSI">RSI</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showBB">
                        <label for="showBB">Bollinger</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showVWAP">
                        <label for="showVWAP">VWAP</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showOBV">
                        <label for="showOBV">OBV</label>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">ML Models</div>
                <div class="control-group">
                    <label>Sequence Length</label>
                    <input type="number" id="sequenceLength" value="60" min="10" max="200">
                </div>
                <div class="control-group">
                    <label>Prediction Horizon</label>
                    <select id="predictionHorizon">
                        <option value="1">1 minute</option>
                        <option value="5">5 minutes</option>
                        <option value="15" selected>15 minutes</option>
                        <option value="30">30 minutes</option>
                        <option value="60">1 hour</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableLinear" checked>
                        <label for="enableLinear">Linear Reg</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableMLP" checked>
                        <label for="enableMLP">MLP</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableLSTM">
                        <label for="enableLSTM">LSTM</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableCNN">
                        <label for="enableCNN">1D-CNN</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableTransformer">
                        <label for="enableTransformer">Transformer</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableEnsemble">
                        <label for="enableEnsemble">Ensemble</label>
                    </div>
                </div>
            </div>

            <div class="section">
                <button class="btn" id="startTraining">Start Training</button>
                <button class="btn btn-secondary" id="startPrediction">Start Prediction</button>
                <button class="btn btn-secondary" id="runBacktest">Run Backtest</button>
            </div>
        </aside>

        <main class="main-content">
            <div class="chart-container">
                <div class="canvas-container">
                    <canvas id="priceChart"></canvas>
                </div>
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <span>Loading models...</span>
                </div>
            </div>
            
            <div class="indicators-panel">
                <div class="section-title">Model Performance</div>
                <div class="model-metrics" id="modelMetrics">
                    <div class="metric-card">
                        <div class="metric-label">Directional Accuracy</div>
                        <div class="metric-value" id="directionalAccuracy">---%</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Sharpe Ratio</div>
                        <div class="metric-value" id="sharpeRatio">---</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Max Drawdown</div>
                        <div class="metric-value" id="maxDrawdown">---%</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total Return</div>
                        <div class="metric-value" id="totalReturn">---%</div>
                    </div>
                </div>
                <div class="log-panel" id="logPanel"></div>
            </div>
        </main>

        <aside class="right-panel">
            <div class="orderbook-section">
                <div class="section-title">Order Book</div>
                <table class="orderbook-table">
                    <thead>
                        <tr>
                            <th>Price</th>
                            <th>Amount</th>
                            <th>Total</th>
                        </tr>
                    </thead>
                    <tbody id="orderbookAsks"></tbody>
                </table>
                <div class="price-display" id="spreadPrice" style="text-align: center; font-size: 14px; margin: 10px 0;">
                    Spread: $0.0000
                </div>
                <table class="orderbook-table">
                    <tbody id="orderbookBids"></tbody>
                </table>
            </div>

            <div class="trades-section">
                <div class="section-title">Recent Trades</div>
                <table class="trades-table">
                    <thead>
                        <tr>
                            <th>Price</th>
                            <th>Amount</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody id="recentTrades"></tbody>
                </table>
            </div>

            <div class="signals-section">
                <div class="section-title">Trading Signals</div>
                <table class="signals-table">
                    <thead>
                        <tr>
                            <th>Model</th>
                            <th>Signal</th>
                            <th>Confidence</th>
                            <th>Price</th>
                        </tr>
                    </thead>
                    <tbody id="tradingSignals"></tbody>
                </table>
            </div>
        </aside>
    </div>

    <script>
        // Global state and configuration
        const state = {
            connected: false,
            priceData: [],
            orderbook: { bids: [], asks: [] },
            recentTrades: [],
            indicators: {},
            models: {},
            predictions: {},
            signals: [],
            isTraining: false,
            isPredicting: false
        };

        const config = {
            symbol: 'WIFUSDT',
            binanceWsUrl: 'wss://stream.binance.com:9443/ws/',
            updateInterval: 1000,
            maxDataPoints: 1000,
            features: [
                'open', 'high', 'low', 'close', 'volume',
                'ema20', 'ema50', 'macd', 'macdSignal', 'rsi',
                'bbUpper', 'bbLower', 'bbMiddle', 'vwap', 'obv',
                'bidAskSpread', 'depthImbalance', 'tradeImbalance',
                'volatility', 'momentum'
            ]
        };

        // Utility functions
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logPanel = document.getElementById('logPanel');
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            logPanel.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        function formatPrice(price) {
            return parseFloat(price).toFixed(4);
        }

        function formatPercent(value) {
            return (value * 100).toFixed(2) + '%';
        }

        // Technical indicators implementation
        class TechnicalIndicators {
            static ema(data, period) {
                const k = 2 / (period + 1);
                let ema = [data[0]];
                
                for (let i = 1; i < data.length; i++) {
                    ema.push(data[i] * k + ema[i - 1] * (1 - k));
                }
                
                return ema;
            }

            static sma(data, period) {
                const sma = [];
                for (let i = period - 1; i < data.length; i++) {
                    const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                    sma.push(sum / period);
                }
                return sma;
            }

            static rsi(prices, period = 14) {
                const gains = [];
                const losses = [];
                
                for (let i = 1; i < prices.length; i++) {
                    const change = prices[i] - prices[i - 1];
                    gains.push(change > 0 ? change : 0);
                    losses.push(change < 0 ? -change : 0);
                }
                
                let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
                let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
                
                const rsi = [100 - (100 / (1 + avgGain / avgLoss))];
                
                for (let i = period; i < gains.length; i++) {
                    avgGain = (avgGain * (period - 1) + gains[i]) / period;
                    avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
                    rsi.push(100 - (100 / (1 + avgGain / avgLoss)));
                }
                
                return rsi;
            }

            static macd(prices, fast = 12, slow = 26, signal = 9) {
                const emaFast = this.ema(prices, fast);
                const emaSlow = this.ema(prices, slow);
                
                const macd = [];
                for (let i = 0; i < Math.min(emaFast.length, emaSlow.length); i++) {
                    macd.push(emaFast[i] - emaSlow[i]);
                }
                
                const macdSignal = this.ema(macd, signal);
                return { macd, signal: macdSignal };
            }

            static bollingerBands(prices, period = 20, stdDev = 2) {
                const sma = this.sma(prices, period);
                const bands = { upper: [], middle: [], lower: [] };
                
                for (let i = 0; i < sma.length; i++) {
                    const slice = prices.slice(i, i + period);
                    const mean = sma[i];
                    const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
                    const std = Math.sqrt(variance);
                    
                    bands.upper.push(mean + stdDev * std);
                    bands.middle.push(mean);
                    bands.lower.push(mean - stdDev * std);
                }
                
                return bands;
            }

            static vwap(highs, lows, closes, volumes) {
                const typical = [];
                const vwap = [];
                let cumVolume = 0;
                let cumVolumePrice = 0;
                
                for (let i = 0; i < closes.length; i++) {
                    const typicalPrice = (highs[i] + lows[i] + closes[i]) / 3;
                    typical.push(typicalPrice);
                    
                    cumVolume += volumes[i];
                    cumVolumePrice += typicalPrice * volumes[i];
                    
                    vwap.push(cumVolumePrice / cumVolume);
                }
                
                return vwap;
            }

            static obv(closes, volumes) {
                const obv = [volumes[0]];
                
                for (let i = 1; i < closes.length; i++) {
                    if (closes[i] > closes[i - 1]) {
                        obv.push(obv[i - 1] + volumes[i]);
                    } else if (closes[i] < closes[i - 1]) {
                        obv.push(obv[i - 1] - volumes[i]);
                    } else {
                        obv.push(obv[i - 1]);
                    }
                }
                
                return obv;
            }
        }

        // ML Models implementation
        class MLModels {
            constructor() {
                this.models = {};
                this.scaler = null;
            }

            normalizeData(data) {
                if (!this.scaler) {
                    this.scaler = {
                        mean: data.reduce((sum, val) => sum + val, 0) / data.length,
                        std: 0
                    };
                    
                    const variance = data.reduce((sum, val) => sum + Math.pow(val - this.scaler.mean, 2), 0) / data.length;
                    this.scaler.std = Math.sqrt(variance);
                }
                
                return data.map(val => (val - this.scaler.mean) / this.scaler.std);
            }

            createLinearModel(inputShape) {
                const model = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [inputShape], units: 1, activation: 'linear' })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }

            createMLPModel(inputShape) {
                const model = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [inputShape], units: 64, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }

            createLSTMModel(timesteps, features) {
                const model = tf.sequential({
                    layers: [
                        tf.layers.lstm({ 
                            inputShape: [timesteps, features], 
                            units: 50, 
                            returnSequences: true 
                        }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.lstm({ units: 50, returnSequences: false }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 25, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }

            createCNNModel(timesteps, features) {
                const model = tf.sequential({
                    layers: [
                        tf.layers.reshape({ inputShape: [timesteps, features], targetShape: [timesteps, features, 1] }),
                        tf.layers.conv2d({ filters: 64, kernelSize: [3, 1], activation: 'relu', padding: 'same' }),
                        tf.layers.conv2d({ filters: 64, kernelSize: [3, 1], activation: 'relu', padding: 'same' }),
                        tf.layers.maxPooling2d({ poolSize: [2, 1] }),
                        tf.layers.dropout({ rate: 0.25 }),
                        tf.layers.flatten(),
                        tf.layers.dense({ units: 50, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.5 }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
                
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                
                return model;
            }

            async trainModel(modelType, X, y, epochs = 50) {
                try {
                    log(`Training ${modelType} model...`);
                    
                    let model;
                    const inputShape = X.shape[1];
                    
                    switch (modelType) {
                        case 'linear':
                            model = this.createLinearModel(inputShape);
                            break;
                        case 'mlp':
                            model = this.createMLPModel(inputShape);
                            break;
                        case 'lstm':
                            model = this.createLSTMModel(X.shape[1], X.shape[2]);
                            break;
                        case 'cnn':
                            model = this.createCNNModel(X.shape[1], X.shape[2]);
                            break;
                        default:
                            throw new Error(`Unknown model type: ${modelType}`);
                    }
                    
                    const history = await model.fit(X, y, {
                        epochs: epochs,
                        batchSize: 32,
                        validationSplit: 0.2,
                        shuffle: true,
                        verbose: 0,
                        callbacks: {
                            onEpochEnd: (epoch, logs) => {
                                if (epoch % 10 === 0) {
                                    log(`${modelType} epoch ${epoch}: loss=${logs.loss.toFixed(4)}, val_loss=${logs.val_loss.toFixed(4)}`);
                                }
                            }
                        }
                    });
                    
                    this.models[modelType] = model;
                    log(`${modelType} model training completed`, 'success');
                    
                    return history;
                } catch (error) {
                    log(`Error training ${modelType} model: ${error.message}`, 'error');
                    throw error;
                }
            }

            predict(modelType, X) {
                if (!this.models[modelType]) {
                    throw new Error(`Model ${modelType} not trained yet`);
                }
                
                return this.models[modelType].predict(X);
            }
        }
