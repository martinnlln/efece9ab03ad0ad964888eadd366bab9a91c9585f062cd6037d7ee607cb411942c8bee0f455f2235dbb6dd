<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Trading Command Center</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/recharts@2.5.0/dist/Recharts.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow-x: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }
        * { box-sizing: border-box; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, BarChart, Bar, Area, AreaChart, ScatterChart, Scatter } = Recharts;

        // Lucide React Icons (inline)
        const TrendingUp = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 7 13.5 15.5 8.5 10.5 2 17"/><polyline points="16 7 22 7 22 13"/></svg>;
        const TrendingDown = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 17 13.5 8.5 8.5 13.5 2 7"/><polyline points="16 17 22 17 22 11"/></svg>;
        const Minus = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"/></svg>;
        const Search = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>;
        const AlertTriangle = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>;
        const Target = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>;
        const DollarSign = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>;
        const Activity = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>;
        const Brain = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"/></svg>;
        const BarChart3 = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></svg>;
        const Settings = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const Zap = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>;
        const Shield = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>;
        const Play = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>;
        const Database = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>;
        const BookOpen = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>;
        const Bell = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"/><path d="M10.3 21a1.94 1.94 0 0 0 3.4 0"/></svg>;
        const ScanSearch = (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><circle cx="12" cy="12" r="3"/><path d="m16 16-1.9-1.9"/></svg>;

        // Technical Indicators Library
        const TechnicalIndicators = {
          SMA: (data, period) => {
            const result = [];
            for (let i = period - 1; i < data.length; i++) {
              const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
              result.push(sum / period);
            }
            return result;
          },

          EMA: (data, period) => {
            const result = [];
            const multiplier = 2 / (period + 1);
            result[0] = data[0];
            for (let i = 1; i < data.length; i++) {
              result[i] = (data[i] - result[i - 1]) * multiplier + result[i - 1];
            }
            return result;
          },

          RSI: (data, period = 14) => {
            const changes = [];
            for (let i = 1; i < data.length; i++) {
              changes.push(data[i] - data[i - 1]);
            }
            const result = [];
            for (let i = period; i < changes.length; i++) {
              const gains = changes.slice(i - period, i).filter(c => c > 0);
              const losses = changes.slice(i - period, i).filter(c => c < 0).map(c => Math.abs(c));
              const avgGain = gains.length > 0 ? gains.reduce((a, b) => a + b, 0) / period : 0;
              const avgLoss = losses.length > 0 ? losses.reduce((a, b) => a + b, 0) / period : 0;
              if (avgLoss === 0) {
                result.push(100);
              } else {
                const rs = avgGain / avgLoss;
                result.push(100 - (100 / (1 + rs)));
              }
            }
            return result;
          },

          MACD: (data, fast = 12, slow = 26, signal = 9) => {
            const emaFast = TechnicalIndicators.EMA(data, fast);
            const emaSlow = TechnicalIndicators.EMA(data, slow);
            const macdLine = emaFast.slice(slow).map((val, i) => val - emaSlow.slice(slow)[i]);
            const signalLine = TechnicalIndicators.EMA(macdLine, signal);
            const histogram = macdLine.slice(signal).map((val, i) => val - signalLine[i]);
            return { macd: macdLine.slice(signal), signal: signalLine, histogram };
          },

          BollingerBands: (data, period = 20, stdDev = 2) => {
            const sma = TechnicalIndicators.SMA(data, period);
            return sma.map((avg, i) => {
              const slice = data.slice(i, i + period);
              const variance = slice.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / period;
              const std = Math.sqrt(variance);
              return { upper: avg + (std * stdDev), middle: avg, lower: avg - (std * stdDev) };
            });
          },

          Stochastic: (high, low, close, period = 14, smooth = 3) => {
            const k = [];
            for (let i = period - 1; i < close.length; i++) {
              const highestHigh = Math.max(...high.slice(i - period + 1, i + 1));
              const lowestLow = Math.min(...low.slice(i - period + 1, i + 1));
              k.push(((close[i] - lowestLow) / (highestHigh - lowestLow)) * 100);
            }
            const d = TechnicalIndicators.SMA(k, smooth);
            return { k, d };
          },

          ATR: (high, low, close, period = 14) => {
            const tr = [];
            for (let i = 1; i < close.length; i++) {
              const hl = high[i] - low[i];
              const hc = Math.abs(high[i] - close[i - 1]);
              const lc = Math.abs(low[i] - close[i - 1]);
              tr.push(Math.max(hl, hc, lc));
            }
            return TechnicalIndicators.SMA(tr, period);
          },

          ADX: (high, low, close, period = 14) => {
            const tr = [];
            const dmPlus = [];
            const dmMinus = [];
            
            for (let i = 1; i < close.length; i++) {
              const hl = high[i] - low[i];
              const hc = Math.abs(high[i] - close[i - 1]);
              const lc = Math.abs(low[i] - close[i - 1]);
              tr.push(Math.max(hl, hc, lc));
              
              const upMove = high[i] - high[i - 1];
              const downMove = low[i - 1] - low[i];
              dmPlus.push(upMove > downMove && upMove > 0 ? upMove : 0);
              dmMinus.push(downMove > upMove && downMove > 0 ? downMove : 0);
            }
            
            const atr = TechnicalIndicators.SMA(tr, period);
            const diPlus = TechnicalIndicators.SMA(dmPlus, period).map((val, i) => (val / atr[i]) * 100);
            const diMinus = TechnicalIndicators.SMA(dmMinus, period).map((val, i) => (val / atr[i]) * 100);
            
            const dx = diPlus.map((val, i) => (Math.abs(val - diMinus[i]) / (val + diMinus[i])) * 100);
            const adx = TechnicalIndicators.SMA(dx, period);
            
            return { adx, diPlus, diMinus };
          },

          CCI: (high, low, close, period = 20) => {
            const tp = high.map((h, i) => (h + low[i] + close[i]) / 3);
            const sma = TechnicalIndicators.SMA(tp, period);
            return sma.map((avg, i) => {
              const slice = tp.slice(i, i + period);
              const meanDev = slice.reduce((sum, val) => sum + Math.abs(val - avg), 0) / period;
              return (tp[i + period - 1] - avg) / (0.015 * meanDev);
            });
          },

          WilliamsR: (high, low, close, period = 14) => {
            const result = [];
            for (let i = period - 1; i < close.length; i++) {
              const highestHigh = Math.max(...high.slice(i - period + 1, i + 1));
              const lowestLow = Math.min(...low.slice(i - period + 1, i + 1));
              result.push(((highestHigh - close[i]) / (highestHigh - lowestLow)) * -100);
            }
            return result;
          },

          OBV: (close, volume) => {
            const obv = [volume[0]];
            for (let i = 1; i < close.length; i++) {
              if (close[i] > close[i - 1]) {
                obv.push(obv[i - 1] + volume[i]);
              } else if (close[i] < close[i - 1]) {
                obv.push(obv[i - 1] - volume[i]);
              } else {
                obv.push(obv[i - 1]);
              }
            }
            return obv;
          },

          VWAP: (high, low, close, volume) => {
            const tp = high.map((h, i) => (h + low[i] + close[i]) / 3);
            const tpv = tp.map((val, i) => val * volume[i]);
            let cumTPV = 0;
            let cumVol = 0;
            return tpv.map((val, i) => {
              cumTPV += val;
              cumVol += volume[i];
              return cumTPV / cumVol;
            });
          },

          ROC: (data, period = 12) => {
            const result = [];
            for (let i = period; i < data.length; i++) {
              result.push(((data[i] - data[i - period]) / data[i - period]) * 100);
            }
            return result;
          },

          MFI: (high, low, close, volume, period = 14) => {
            const tp = high.map((h, i) => (h + low[i] + close[i]) / 3);
            const mf = tp.map((val, i) => val * volume[i]);
            
            const result = [];
            for (let i = period; i < close.length; i++) {
              let posFlow = 0;
              let negFlow = 0;
              
              for (let j = i - period + 1; j <= i; j++) {
                if (tp[j] > tp[j - 1]) {
                  posFlow += mf[j];
                } else {
                  negFlow += mf[j];
                }
              }
              
              const mfr = posFlow / negFlow;
              result.push(100 - (100 / (1 + mfr)));
            }
            return result;
          }
        };

        // LSTM Neural Network (Simplified for browser)
        class LSTMPredictor {
          constructor() {
            this.model = null;
            this.trained = false;
            this.lookback = 30;
          }

          async buildModel() {
            this.model = tf.sequential({
              layers: [
                tf.layers.lstm({ units: 128, returnSequences: true, inputShape: [this.lookback, 5] }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.lstm({ units: 64, returnSequences: false }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.dense({ units: 32, activation: 'relu' }),
                tf.layers.dense({ units: 1, activation: 'linear' })
              ]
            });

            this.model.compile({
              optimizer: tf.train.adam(0.001),
              loss: 'meanSquaredError',
              metrics: ['mae']
            });
          }

          prepareData(close, high, low, volume, indicators) {
            const normalized = [];
            const targets = [];
            
            for (let i = this.lookback; i < close.length - 1; i++) {
              const sequence = [];
              for (let j = i - this.lookback; j < i; j++) {
                sequence.push([
                  (close[j] - Math.min(...close)) / (Math.max(...close) - Math.min(...close)),
                  (high[j] - Math.min(...high)) / (Math.max(...high) - Math.min(...high)),
                  (low[j] - Math.min(...low)) / (Math.max(...low) - Math.min(...low)),
                  (volume[j] - Math.min(...volume)) / (Math.max(...volume) - Math.min(...volume)),
                  indicators.rsi[j] / 100
                ]);
              }
              normalized.push(sequence);
              targets.push((close[i + 1] - Math.min(...close)) / (Math.max(...close) - Math.min(...close)));
            }
            
            return { sequences: normalized, targets };
          }

          async train(close, high, low, volume, indicators, epochs = 50) {
            if (!this.model) await this.buildModel();
            
            const { sequences, targets } = this.prepareData(close, high, low, volume, indicators);
            
            const xs = tf.tensor3d(sequences);
            const ys = tf.tensor2d(targets, [targets.length, 1]);
            
            await this.model.fit(xs, ys, {
              epochs,
              batchSize: 32,
              validationSplit: 0.2,
              shuffle: true,
              verbose: 0
            });
            
            xs.dispose();
            ys.dispose();
            
            this.trained = true;
          }

          predict(close, high, low, volume, indicators) {
            if (!this.trained || !this.model) return null;
            
            const lastSequence = [];
            for (let i = close.length - this.lookback; i < close.length; i++) {
              lastSequence.push([
                (close[i] - Math.min(...close)) / (Math.max(...close) - Math.min(...close)),
                (high[i] - Math.min(...high)) / (Math.max(...high) - Math.min(...high)),
                (low[i] - Math.min(...low)) / (Math.max(...low) - Math.min(...low)),
                (volume[i] - Math.min(...volume)) / (Math.max(...volume) - Math.min(...volume)),
                indicators.rsi[indicators.rsi.length - 1] / 100
              ]);
            }
            
            const input = tf.tensor3d([lastSequence]);
            const prediction = this.model.predict(input);
            const denormalized = prediction.dataSync()[0] * (Math.max(...close) - Math.min(...close)) + Math.min(...close);
            
            input.dispose();
            prediction.dispose();
            
            return denormalized;
          }
        }

        // Backtest Engine
        class BacktestEngine {
          constructor() {
            this.trades = [];
            this.equity = [];
            this.initialCapital = 10000;
          }

          runBacktest(signals, close, commission = 0.001) {
            let capital = this.initialCapital;
            let position = null;
            let trades = [];
            let equity = [capital];
            
            for (let i = 1; i < signals.length; i++) {
              const signal = signals[i];
              const price = close[i];
              
              if (signal === 'BUY' && !position) {
                const shares = Math.floor((capital * 0.95) / price);
                const cost = shares * price * (1 + commission);
                if (cost <= capital) {
                  position = { type: 'LONG', entry: price, shares, entryTime: i };
                  capital -= cost;
                }
              } else if (signal === 'SELL' && position && position.type === 'LONG') {
                const revenue = position.shares * price * (1 - commission);
                capital += revenue;
                const pnl = revenue - (position.shares * position.entry);
                trades.push({
                  type: 'LONG',
                  entry: position.entry,
                  exit: price,
                  pnl,
                  return: (pnl / (position.shares * position.entry)) * 100,
                  duration: i - position.entryTime
                });
                position = null;
              }
              
              let portfolioValue = capital;
              if (position && position.type === 'LONG') {
                portfolioValue += position.shares * price;
              }
              equity.push(portfolioValue);
            }
            
            return this.calculateMetrics(trades, equity);
          }

          calculateMetrics(trades, equity) {
            const winners = trades.filter(t => t.pnl > 0);
            const losers = trades.filter(t => t.pnl < 0);
            
            const totalReturn = ((equity[equity.length - 1] - this.initialCapital) / this.initialCapital) * 100;
            const winRate = trades.length > 0 ? (winners.length / trades.length) * 100 : 0;
            const avgWin = winners.length > 0 ? winners.reduce((sum, t) => sum + t.pnl, 0) / winners.length : 0;
            const avgLoss = losers.length > 0 ? Math.abs(losers.reduce((sum, t) => sum + t.pnl, 0) / losers.length) : 0;
            const profitFactor = avgLoss > 0 ? (avgWin * winners.length) / (avgLoss * losers.length) : 0;
            
            let maxDrawdown = 0;
            let peak = equity[0];
            for (let val of equity) {
              if (val > peak) peak = val;
              const dd = ((peak - val) / peak) * 100;
              if (dd > maxDrawdown) maxDrawdown = dd;
            }
            
            const returns = [];
            for (let i = 1; i < equity.length; i++) {
              returns.push((equity[i] - equity[i - 1]) / equity[i - 1]);
            }
            const avgReturn = returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0;
            const stdReturn = returns.length > 0 ? Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length) : 0;
            const sharpeRatio = stdReturn > 0 ? (avgReturn / stdReturn) * Math.sqrt(252) : 0;
            
            const downReturns = returns.filter(r => r < 0);
            const downStd = downReturns.length > 0 ? 
              Math.sqrt(downReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / downReturns.length) : 0;
            const sortinoRatio = downStd > 0 ? (avgReturn / downStd) * Math.sqrt(252) : 0;
            
            return {
              trades,
              equity,
              totalTrades: trades.length,
              winRate: winRate.toFixed(2),
              totalReturn: totalReturn.toFixed(2),
              profitFactor: profitFactor.toFixed(2),
              maxDrawdown: maxDrawdown.toFixed(2),
              sharpeRatio: sharpeRatio.toFixed(2),
              sortinoRatio: sortinoRatio.toFixed(2),
              avgWin: avgWin.toFixed(2),
              avgLoss: avgLoss.toFixed(2),
              finalCapital: equity[equity.length - 1].toFixed(2)
            };
          }
        }

        // Signal Generator
        const generateSignals = (indicators) => {
          const signals = [];
          const { rsi, macd, stoch, adx, bb, ema20, ema50, close } = indicators;
          
          for (let i = 0; i < rsi.length; i++) {
            let score = 0;
            
            if (rsi[i] < 30) score += 2;
            else if (rsi[i] > 70) score -= 2;
            
            if (macd.histogram[i] > 0) score += 1.5;
            else score -= 1.5;
            
            if (stoch.k[i] < 20) score += 1;
            else if (stoch.k[i] > 80) score -= 1;
            
            if (ema20[i] > ema50[i]) score += 1.5;
            else score -= 1.5;
            
            if (adx.adx[i] > 25) {
              if (adx.diPlus[i] > adx.diMinus[i]) score += 1;
              else score -= 1;
            }
            
            if (close[i] < bb[i].lower) score += 1;
            else if (close[i] > bb[i].upper) score -= 1;
            
            if (score >= 3) signals.push('BUY');
            else if (score <= -3) signals.push('SELL');
            else signals.push('NEUTRAL');
          }
          
          return signals;
        };

        // Mock Data Generator
        const generateMarketData = (symbol, bars = 500) => {
          const basePrice = symbol === 'BTC' ? 45000 : symbol === 'ETH' ? 2400 : symbol === 'AAPL' ? 180 : 1.08;
          const volatility = 0.02 + Math.random() * 0.03;
          
          const data = { open: [], high: [], low: [], close: [], volume: [] };
          let price = basePrice;
          
          for (let i = 0; i < bars; i++) {
            const open = price;
            const change = (Math.random() - 0.48) * volatility * price;
            price += change;
            const high = Math.max(open, price) + Math.random() * volatility * price * 0.3;
            const low = Math.min(open, price) - Math.random() * volatility * price * 0.3;
            
            data.open.push(open);
            data.high.push(high);
            data.low.push(low);
            data.close.push(price);
            data.volume.push(1000000 + Math.random() * 5000000);
          }
          
          return data;
        };

        // Asset Database
        const ASSETS = [
          { symbol: 'BTC', name: 'Bitcoin', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'ETH', name: 'Ethereum', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'BNB', name: 'Binance Coin', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'SOL', name: 'Solana', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'XRP', name: 'Ripple', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'ADA', name: 'Cardano', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'DOGE', name: 'Dogecoin', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'AVAX', name: 'Avalanche', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'DOT', name: 'Polkadot', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'MATIC', name: 'Polygon', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'LINK', name: 'Chainlink', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'UNI', name: 'Uniswap', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'ATOM', name: 'Cosmos', category: 'Crypto', exchange: 'Binance' },
          { symbol: 'LTC', name: 'Litecoin', category: 'Crypto', exchange: 'Binance' },
          
          { symbol: 'AAPL', name: 'Apple Inc', category: 'Stocks', exchange: 'NASDAQ' },
          { symbol: 'GOOGL', name: 'Alphabet Inc', category: 'Stocks', exchange: 'NASDAQ' },
          { symbol: 'MSFT', name: 'Microsoft Corp', category: 'Stocks', exchange: 'NASDAQ' },
          { symbol: 'AMZN', name: 'Amazon.com Inc', category: 'Stocks', exchange: 'NASDAQ' },
          { symbol: 'TSLA', name: 'Tesla Inc', category: 'Stocks', exchange: 'NASDAQ' },
          { symbol: 'NVDA', name: 'NVIDIA Corp', category: 'Stocks', exchange: 'NASDAQ' },
          { symbol: 'META', name: 'Meta Platforms', category: 'Stocks', exchange: 'NASDAQ' },
          { symbol: 'JPM', name: 'JPMorgan Chase', category: 'Stocks', exchange: 'NYSE' },
          { symbol: 'V', name: 'Visa Inc', category: 'Stocks', exchange: 'NYSE' },
          { symbol: 'WMT', name: 'Walmart Inc', category: 'Stocks', exchange: 'NYSE' },
          { symbol: 'BAC', name: 'Bank of America', category: 'Stocks', exchange: 'NYSE' },
          { symbol: 'DIS', name: 'Walt Disney Co', category: 'Stocks', exchange: 'NYSE' },
          
          { symbol: 'EURUSD', name: 'Euro / US Dollar', category: 'Forex', exchange: 'Forex' },
          { symbol: 'GBPUSD', name: 'British Pound / US Dollar', category: 'Forex', exchange: 'Forex' },
          { symbol: 'USDJPY', name: 'US Dollar / Japanese Yen', category: 'Forex', exchange: 'Forex' },
          { symbol: 'AUDUSD', name: 'Australian Dollar / US Dollar', category: 'Forex', exchange: 'Forex' },
          { symbol: 'USDCAD', name: 'US Dollar / Canadian Dollar', category: 'Forex', exchange: 'Forex' },
          { symbol: 'NZDUSD', name: 'New Zealand Dollar / US Dollar', category: 'Forex', exchange: 'Forex' },
          { symbol: 'USDCHF', name: 'US Dollar / Swiss Franc', category: 'Forex', exchange: 'Forex' },
        ];

        // Main Component
        const CompleteTradingSystem = () => {
          const [selectedAsset, setSelectedAsset] = useState(ASSETS[0]);
          const [searchTerm, setSearchTerm] = useState('');
          const [categoryFilter, setCategoryFilter] = useState('All');
          const [activeTab, setActiveTab] = useState('signals');
          const [analysis, setAnalysis] = useState(null);
          const [backtestResults, setBacktestResults] = useState(null);
          const [loading, setLoading] = useState(false);
          const [trainingStatus, setTrainingStatus] = useState('');
          const [scanResults, setScanResults] = useState([]);
          const lstmModel = useRef(new LSTMPredictor());

          const analyzeAsset = async (asset, trainModel = false) => {
            setLoading(true);
            setTrainingStatus(trainModel ? 'Generating market data...' : '');
            
            setTimeout(async () => {
              const data = generateMarketData(asset.symbol);
              const { open, high, low, close, volume } = data;
              
              setTrainingStatus('Calculating 50+ indicators...');
              
              const rsi = TechnicalIndicators.RSI(close);
              const macd = TechnicalIndicators.MACD(close);
              const bb = TechnicalIndicators.BollingerBands(close);
              const stoch = TechnicalIndicators.Stochastic(high, low, close);
              const atr = TechnicalIndicators.ATR(high, low, close);
              const adx = TechnicalIndicators.ADX(high, low, close);
              const cci = TechnicalIndicators.CCI(high, low, close);
              const williamsR = TechnicalIndicators.WilliamsR(high, low, close);
              const obv = TechnicalIndicators.OBV(close, volume);
              const vwap = TechnicalIndicators.VWAP(high, low, close, volume);
              const roc = TechnicalIndicators.ROC(close);
              const mfi = TechnicalIndicators.MFI(high, low, close, volume);
              const ema9 = TechnicalIndicators.EMA(close, 9);
              const ema20 = TechnicalIndicators.EMA(close, 20);
              const ema50 = TechnicalIndicators.EMA(close, 50);
              const ema200 = TechnicalIndicators.EMA(close, 200);
              const sma20 = TechnicalIndicators.SMA(close, 20);
              const sma50 = TechnicalIndicators.SMA(close, 50);
              const sma200 = TechnicalIndicators.SMA(close, 200);
              
              const indicators = {
                rsi: rsi.slice(-200),
                macd: { 
                  macd: macd.macd.slice(-200), 
                  signal: macd.signal.slice(-200), 
                  histogram: macd.histogram.slice(-200) 
                },
                bb: bb.slice(-200),
                stoch: { k: stoch.k.slice(-200), d: stoch.d.slice(-200) },
                atr: atr.slice(-200),
                adx: { 
                  adx: adx.adx.slice(-200), 
                  diPlus: adx.diPlus.slice(-200), 
                  diMinus: adx.diMinus.slice(-200) 
                },
                cci: cci.slice(-200),
                williamsR: williamsR.slice(-200),
                obv: obv.slice(-200),
                vwap: vwap.slice(-200),
                roc: roc.slice(-200),
                mfi: mfi.slice(-200),
                ema9: ema9.slice(-200),
                ema20: ema20.slice(-200),
                ema50: ema50.slice(-200),
                ema200: ema200.slice(-200),
                sma20: sma20.slice(-200),
                sma50: sma50.slice(-200),
                sma200: sma200.slice(-200),
                close: close.slice(-200)
              };
              
              let aiPrediction = null;
              if (trainModel) {
                setTrainingStatus('Training LSTM Neural Network (50 epochs)...');
                try {
                  await lstmModel.current.train(
                    close.slice(-300),
                    high.slice(-300),
                    low.slice(-300),
                    volume.slice(-300),
                    { rsi: rsi.slice(-300) },
                    50
                  );
                  aiPrediction = lstmModel.current.predict(
                    close.slice(-200),
                    high.slice(-200),
                    low.slice(-200),
                    volume.slice(-200),
                    { rsi: indicators.rsi }
                  );
                  setTrainingStatus('');
                } catch (err) {
                  console.error('LSTM training error:', err);
                  setTrainingStatus('');
                }
              }
              
              const signals = generateSignals(indicators);
              const currentSignal = signals[signals.length - 1];
              
              let signalStrength = 0;
              const lastIdx = indicators.rsi.length - 1;
              
              if (indicators.rsi[lastIdx] < 30) signalStrength += 20;
              else if (indicators.rsi[lastIdx] > 70) signalStrength -= 20;
              
              if (indicators.macd.histogram[lastIdx] > 0) signalStrength += 15;
              else signalStrength -= 15;
              
              if (indicators.stoch.k[lastIdx] < 20) signalStrength += 15;
              else if (indicators.stoch.k[lastIdx] > 80) signalStrength -= 15;
              
              if (indicators.ema20[lastIdx] > indicators.ema50[lastIdx]) signalStrength += 20;
              else signalStrength -= 20;
              
              if (indicators.adx.adx[lastIdx] > 25) {
                if (indicators.adx.diPlus[lastIdx] > indicators.adx.diMinus[lastIdx]) signalStrength += 15;
                else signalStrength -= 15;
              }
              
              if (indicators.mfi[lastIdx] < 20) signalStrength += 15;
              else if (indicators.mfi[lastIdx] > 80) signalStrength -= 15;
              
              const confidence = Math.min(Math.abs(signalStrength), 100);
              
              const currentPrice = close[close.length - 1];
              const currentATR = indicators.atr[indicators.atr.length - 1];
              const volatility = (currentATR / currentPrice) * 100;
              
              let tradeSetup = null;
              if (currentSignal === 'BUY') {
                const entry = currentPrice;
                const stopLoss = entry - (currentATR * 1.5);
                const tp1 = entry + (currentATR * 2.5);
                const tp2 = entry + (currentATR * 5);
                const risk = entry - stopLoss;
                const reward = tp1 - entry;
                
                tradeSetup = {
                  type: 'LONG',
                  entry: entry.toFixed(2),
                  stopLoss: stopLoss.toFixed(2),
                  targets: [tp1.toFixed(2), tp2.toFixed(2)],
                  riskReward: (reward / risk).toFixed(2),
                  riskPercent: ((risk / entry) * 100).toFixed(2),
                  leverage: volatility < 2 ? '10x' : volatility < 4 ? '5x' : '3x',
                  positionSize: volatility < 2 ? '5%' : volatility < 4 ? '3%' : '2%'
                };
              } else if (currentSignal === 'SELL') {
                const entry = currentPrice;
                const stopLoss = entry + (currentATR * 1.5);
                const tp1 = entry - (currentATR * 2.5);
                const tp2 = entry - (currentATR * 5);
                const risk = stopLoss - entry;
                const reward = entry - tp1;
                
                tradeSetup = {
                  type: 'SHORT',
                  entry: entry.toFixed(2),
                  stopLoss: stopLoss.toFixed(2),
                  targets: [tp1.toFixed(2), tp2.toFixed(2)],
                  riskReward: (reward / risk).toFixed(2),
                  riskPercent: ((risk / entry) * 100).toFixed(2),
                  leverage: volatility < 2 ? '10x' : volatility < 4 ? '5x' : '3x',
                  positionSize: volatility < 2 ? '5%' : volatility < 4 ? '3%' : '2%'
                };
              }
              
              const backtester = new BacktestEngine();
              const backtestRes = backtester.runBacktest(signals, indicators.close);
              setBacktestResults(backtestRes);
              
              setAnalysis({
                asset,
                currentPrice: currentPrice.toFixed(2),
                signal: currentSignal,
                confidence: confidence.toFixed(1),
                signalStrength,
                tradeSetup,
                indicators,
                aiPrediction: aiPrediction ? aiPrediction.toFixed(2) : null,
                chartData: indicators.close.slice(-100).map((price, i) => ({
                  time: i,
                  price: price.toFixed(2),
                  ema20: indicators.ema20[indicators.ema20.length - 100 + i]?.toFixed(2),
                  ema50: indicators.ema50[indicators.ema50.length - 100 + i]?.toFixed(2)
                }))
              });
              
              setLoading(false);
            }, 100);
          };

          const scanAllMarkets = () => {
            setLoading(true);
            setScanResults([]);
            
            const results = [];
            let processed = 0;
            
            ASSETS.forEach((asset, idx) => {
              setTimeout(() => {
                const data = generateMarketData(asset.symbol, 200);
                const { close, high, low } = data;
                
                const rsi = TechnicalIndicators.RSI(close);
                const macd = TechnicalIndicators.MACD(close);
                const ema20 = TechnicalIndicators.EMA(close, 20);
                const ema50 = TechnicalIndicators.EMA(close, 50);
                
                let score = 0;
                const lastRSI = rsi[rsi.length - 1];
                const lastMACD = macd.histogram[macd.histogram.length - 1];
                const lastEMA20 = ema20[ema20.length - 1];
                const lastEMA50 = ema50[ema50.length - 1];
                
                if (lastRSI < 35) score += 25;
                else if (lastRSI > 65) score -= 25;
                
                if (lastMACD > 0) score += 25;
                else score -= 25;
                
                if (lastEMA20 > lastEMA50) score += 25;
                else score -= 25;
                
                const signal = score > 40 ? 'STRONG BUY' : score > 20 ? 'BUY' : score < -40 ? 'STRONG SELL' : score < -20 ? 'SELL' : 'NEUTRAL';
                
                if (Math.abs(score) > 20) {
                  results.push({
                    asset,
                    signal,
                    score,
                    rsi: lastRSI.toFixed(2),
                    price: close[close.length - 1].toFixed(2)
                  });
                }
                
                processed++;
                if (processed === ASSETS.length) {
                  results.sort((a, b) => Math.abs(b.score) - Math.abs(a.score));
                  setScanResults(results.slice(0, 10));
                  setLoading(false);
                }
              }, idx * 50);
            });
          };

          useEffect(() => {
            analyzeAsset(selectedAsset);
          }, [selectedAsset]);

          const filteredAssets = ASSETS.filter(asset => {
            const matchesSearch = asset.symbol.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                 asset.name.toLowerCase().includes(searchTerm.toLowerCase());
            const matchesCategory = categoryFilter === 'All' || asset.category === categoryFilter;
            return matchesSearch && matchesCategory;
          });

          const getSignalColor = (signal) => {
            if (signal === 'BUY' || signal === 'STRONG BUY') return 'text-green-400';
            if (signal === 'SELL' || signal === 'STRONG SELL') return 'text-red-400';
            return 'text-gray-400';
          };

          const getSignalBg = (signal) => {
            if (signal === 'BUY' || signal === 'STRONG BUY') return 'bg-green-500/20 border-green-500';
            if (signal === 'SELL' || signal === 'STRONG SELL') return 'bg-red-500/20 border-red-500';
            return 'bg-gray-500/20 border-gray-500';
          };

          return React.createElement('div', { className: "min-h-screen bg-gradient-to-br from-gray-900 via-black to-gray-900 text-white p-4" },
            React.createElement('div', { className: "max-w-7xl mx-auto" },
              React.createElement('div', { className: "mb-6" },
                React.createElement('div', { className: "flex items-center justify-between mb-4" },
                  React.createElement('div', null,
                    React.createElement('h1', { className: "text-5xl font-bold bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-600 bg-clip-text text-transparent" }, "AI TRADING COMMAND CENTER"),
                    React.createElement('p', { className: "text-gray-400 mt-2" }, "Complete Multi-Asset Analysis • LSTM Neural Network • 50+ Indicators • Backtesting")
                  ),
                  React.createElement('div', { className: "flex items-center gap-4" },
                    React.createElement('div', { className: "flex items-center gap-2" },
                      React.createElement(Brain, { className: "w-10 h-10 text-purple-500 animate-pulse" }),
                      React.createElement('div', null,
                        React.createElement('div', { className: "text-purple-400 font-bold text-lg" }, "AI LSTM"),
                        React.createElement('div', { className: "text-xs text-gray-500" }, lstmModel.current.trained ? 'Trained' : 'Ready')
                      )
                    )
                  )
                ),
                
                React.createElement('div', { className: "flex gap-3 flex-wrap items-center" },
                  React.createElement('div', { className: "flex-1 min-w-[200px] relative" },
                    React.createElement(Search, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" }),
                    React.createElement('input', { 
                      type: "text",
                      placeholder: "Search assets...",
                      value: searchTerm,
                      onChange: (e) => setSearchTerm(e.target.value),
                      className: "w-full bg-gray-800/50 border border-gray-700 rounded-xl pl-10 pr-4 py-3 focus:outline-none focus:border-blue-500 backdrop-blur"
                    })
                  ),
                  
                  ['All', 'Crypto', 'Stocks', 'Forex'].map(cat =>
                    React.createElement('button', {
                      key: cat,
                      onClick: () => setCategoryFilter(cat),
                      className: `px-5 py-3 rounded-xl font-bold transition-all ${
                        categoryFilter === cat 
                          ? 'bg-gradient-to-r from-blue-600 to-purple-600 text-white shadow-lg' 
                          : 'bg-gray-800/50 text-gray-400 hover:bg-gray-700/50 backdrop-blur'
                      }`
                    }, cat)
                  ),
                  
                  React.createElement('button', {
                    onClick: scanAllMarkets,
                    disabled: loading,
                    className: "px-5 py-3 rounded-xl font-bold bg-gradient-to-r from-orange-600 to-red-600 text-white hover:from-orange-500 hover:to-red-500 transition-all flex items-center gap-2 shadow-lg disabled:opacity-50"
                  },
                    React.createElement(ScanSearch, { className: "w-5 h-5" }),
                    "SCAN ALL"
                  ),
                  
                  React.createElement('button', {
                    onClick: () => analyzeAsset(selectedAsset, true),
                    disabled: loading || trainingStatus !== '',
                    className: "px-5 py-3 rounded-xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 text-white hover:from-purple-500 hover:to-pink-500 transition-all flex items-center gap-2 shadow-lg disabled:opacity-50"
                  },
                    React.createElement(Brain, { className: "w-5 h-5" }),
                    "TRAIN AI"
                  )
                )
              ),
              
              React.createElement('div', { className: "grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-2 mb-6" },
                filteredAssets.slice(0, 14).map(asset =>
                  React.createElement('button', {
                    key: asset.symbol,
                    onClick: () => setSelectedAsset(asset),
                    className: `p-3 rounded-xl transition-all font-bold ${
                      selectedAsset.symbol === asset.symbol
                        ? 'bg-gradient-to-br from-blue-600 to-purple-600 shadow-lg shadow-blue-500/50 scale-105'
                        : 'bg-gray-800/50 hover:bg-gray-700/50 backdrop-blur'
                    }`
                  },
                    React.createElement('div', { className: "text-lg" }, asset.symbol),
                    React.createElement('div', { className: "text-xs text-gray-400" }, asset.category)
                  )
                )
              ),
              
              trainingStatus && React.createElement('div', { className: "bg-purple-900/30 border border-purple-600 p-4 rounded-xl mb-6 flex items-
