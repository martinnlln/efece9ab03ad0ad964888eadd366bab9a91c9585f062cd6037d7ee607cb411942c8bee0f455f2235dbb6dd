<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIF/USDT Advanced Trading Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #ffffff;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(90deg, #1e3c72 0%, #2a5298 100%);
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0,255,136,0.3);
        }

        .price-ticker {
            display: flex;
            gap: 30px;
            align-items: center;
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
        }

        .price-info {
            text-align: center;
        }

        .price-value {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
        }

        .price-change {
            font-size: 12px;
            margin-top: 2px;
        }

        .positive { color: #00ff88; }
        .negative { color: #ff4444; }

        .main-container {
            display: grid;
            grid-template-columns: 250px 1fr 300px;
            grid-template-rows: 1fr;
            height: calc(100vh - 80px);
            gap: 10px;
            padding: 10px;
        }

        .sidebar {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .indicator-group {
            margin-bottom: 25px;
        }

        .indicator-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
            border: 1px solid transparent;
        }

        .indicator-item:hover {
            background: rgba(0,255,136,0.1);
            border-color: rgba(0,255,136,0.3);
            transform: translateX(5px);
        }

        .indicator-value {
            font-weight: bold;
            font-size: 12px;
        }

        .chart-container {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .timeframe-buttons {
            display: flex;
            gap: 5px;
        }

        .timeframe-btn {
            padding: 8px 15px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .timeframe-btn.active,
        .timeframe-btn:hover {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            border-color: #00ff88;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,255,136,0.3);
        }

        .chart-wrapper {
            position: relative;
            flex: 1;
            min-height: 400px;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .panel h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 16px;
            text-align: center;
        }

        .prediction-card {
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }

        .prediction-price {
            font-size: 20px;
            font-weight: bold;
            color: #00ff88;
        }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff88);
            transition: width 0.5s ease;
        }

        .signal-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 4px solid transparent;
        }

        .signal-buy { border-left-color: #00ff88; }
        .signal-sell { border-left-color: #ff4444; }
        .signal-hold { border-left-color: #ffaa00; }

        .news-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .news-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-2px);
        }

        .news-title {
            font-size: 12px;
            margin-bottom: 5px;
            line-height: 1.3;
        }

        .news-time {
            font-size: 10px;
            color: #888;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-connected { background: #00ff88; }
        .status-disconnected { background: #ff4444; }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }

        .loading-spinner {
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 3px solid #00ff88;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
            }
            
            .header-content {
                flex-direction: column;
                gap: 10px;
            }
            
            .price-ticker {
                flex-wrap: wrap;
                gap: 15px;
            }
        }

        .model-weights {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .model-weight {
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            font-size: 11px;
        }

        .accuracy-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .accuracy-item {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .accuracy-value {
            font-size: 16px;
            font-weight: bold;
            color: #00ff88;
        }

        .accuracy-label {
            font-size: 10px;
            color: #aaa;
            margin-top: 3px;
        }

        .alert-banner {
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(45deg, #ff4444, #cc0000);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(255,68,68,0.3);
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .alert-banner.show {
            transform: translateX(0);
        }
    </style>
</head>
<body>
    <div class="alert-banner" id="alertBanner">
        <div id="alertMessage"></div>
    </div>

    <header class="header">
        <div class="header-content">
            <div class="logo">WIF/USDT Advanced Trading Platform</div>
            <div class="price-ticker">
                <div class="price-info">
                    <div class="price-value" id="currentPrice">Loading...</div>
                    <div class="price-change" id="priceChange">--</div>
                </div>
                <div class="price-info">
                    <div class="price-value" id="volume24h">--</div>
                    <div style="font-size: 12px; color: #888;">24h Volume</div>
                </div>
                <div class="price-info">
                    <div class="price-value" id="marketCap">--</div>
                    <div style="font-size: 12px; color: #888;">Market Cap</div>
                </div>
                <div style="display: flex; align-items: center;">
                    <span class="status-indicator status-connected" id="connectionStatus"></span>
                    <span style="font-size: 12px;">Live Data</span>
                </div>
            </div>
        </div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <div class="indicator-group">
                <h3>Trend Indicators</h3>
                <div class="indicator-item">
                    <span>SMA (20)</span>
                    <span class="indicator-value" id="sma20">--</span>
                </div>
                <div class="indicator-item">
                    <span>EMA (20)</span>
                    <span class="indicator-value" id="ema20">--</span>
                </div>
                <div class="indicator-item">
                    <span>MACD</span>
                    <span class="indicator-value" id="macd">--</span>
                </div>
                <div class="indicator-item">
                    <span>Bollinger Upper</span>
                    <span class="indicator-value" id="bbUpper">--</span>
                </div>
                <div class="indicator-item">
                    <span>Bollinger Lower</span>
                    <span class="indicator-value" id="bbLower">--</span>
                </div>
            </div>

            <div class="indicator-group">
                <h3>Momentum</h3>
                <div class="indicator-item">
                    <span>RSI (14)</span>
                    <span class="indicator-value" id="rsi">--</span>
                </div>
                <div class="indicator-item">
                    <span>Stochastic</span>
                    <span class="indicator-value" id="stoch">--</span>
                </div>
                <div class="indicator-item">
                    <span>Williams %R</span>
                    <span class="indicator-value" id="willR">--</span>
                </div>
                <div class="indicator-item">
                    <span>CCI</span>
                    <span class="indicator-value" id="cci">--</span>
                </div>
            </div>

            <div class="indicator-group">
                <h3>Volume</h3>
                <div class="indicator-item">
                    <span>OBV</span>
                    <span class="indicator-value" id="obv">--</span>
                </div>
                <div class="indicator-item">
                    <span>VWAP</span>
                    <span class="indicator-value" id="vwap">--</span>
                </div>
                <div class="indicator-item">
                    <span>MFI</span>
                    <span class="indicator-value" id="mfi">--</span>
                </div>
            </div>

            <div class="indicator-group">
                <h3>Volatility</h3>
                <div class="indicator-item">
                    <span>ATR</span>
                    <span class="indicator-value" id="atr">--</span>
                </div>
                <div class="indicator-item">
                    <span>Volatility</span>
                    <span class="indicator-value" id="volatility">--</span>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-controls">
                <div class="timeframe-buttons">
                    <button class="timeframe-btn active" data-timeframe="1m">1m</button>
                    <button class="timeframe-btn" data-timeframe="5m">5m</button>
                    <button class="timeframe-btn" data-timeframe="15m">15m</button>
                    <button class="timeframe-btn" data-timeframe="1h">1h</button>
                    <button class="timeframe-btn" data-timeframe="4h">4h</button>
                    <button class="timeframe-btn" data-timeframe="1d">1d</button>
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <span style="font-size: 14px;">Prediction Horizon:</span>
                    <select id="predictionHorizon" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 5px 10px; border-radius: 5px;">
                        <option value="5">5 min</option>
                        <option value="15">15 min</option>
                        <option value="30">30 min</option>
                        <option value="60" selected>1 hour</option>
                        <option value="240">4 hours</option>
                        <option value="1440">1 day</option>
                    </select>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="priceChart"></canvas>
            </div>
        </div>

        <div class="right-panel">
            <div class="panel">
                <h3>AI Predictions</h3>
                <div class="prediction-card">
                    <div style="font-size: 14px; margin-bottom: 5px;">Next Hour</div>
                    <div class="prediction-price" id="prediction1h">Loading...</div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidence1h" style="width: 0%"></div>
                    </div>
                    <div style="font-size: 12px;" id="confidence1hText">Confidence: 0%</div>
                </div>

                <div class="model-weights">
                    <div class="model-weight">
                        <div>GRU</div>
                        <div style="color: #00ff88;">25%</div>
                    </div>
                    <div class="model-weight">
                        <div>XGBoost</div>
                        <div style="color: #00ff88;">20%</div>
                    </div>
                    <div class="model-weight">
                        <div>Transformer</div>
                        <div style="color: #00ff88;">18%</div>
                    </div>
                    <div class="model-weight">
                        <div>LSTM</div>
                        <div style="color: #00ff88;">15%</div>
                    </div>
                    <div class="model-weight">
                        <div>LightGBM</div>
                        <div style="color: #00ff88;">12%</div>
                    </div>
                    <div class="model-weight">
                        <div>RF</div>
                        <div style="color: #00ff88;">10%</div>
                    </div>
                </div>

                <div class="accuracy-grid">
                    <div class="accuracy-item">
                        <div class="accuracy-value" id="modelAccuracy">67.5%</div>
                        <div class="accuracy-label">Accuracy</div>
                    </div>
                    <div class="accuracy-item">
                        <div class="accuracy-value" id="sharpeRatio">1.73</div>
                        <div class="accuracy-label">Sharpe</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Trading Signals</h3>
                <div id="signalsContainer">
                    <div class="signal-item signal-buy">
                        <div>
                            <div style="font-weight: bold;">Strong Buy</div>
                            <div style="font-size: 11px; color: #aaa;">Multi-timeframe confluence</div>
                        </div>
                        <div style="color: #00ff88; font-weight: bold;">85%</div>
                    </div>
                    <div class="signal-item signal-hold">
                        <div>
                            <div style="font-weight: bold;">RSI Oversold</div>
                            <div style="font-size: 11px; color: #aaa;">Mean reversion signal</div>
                        </div>
                        <div style="color: #ffaa00; font-weight: bold;">72%</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Market Sentiment</h3>
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="font-size: 24px; font-weight: bold; color: #00ff88;" id="fearGreedIndex">--</div>
                    <div style="font-size: 12px; color: #aaa;">Fear & Greed Index</div>
                </div>
                <div id="newsContainer">
                    <div class="news-item">
                        <div class="news-title">WIF shows strong momentum amid market recovery...</div>
                        <div class="news-time">2 hours ago</div>
                    </div>
                    <div class="loading-spinner" style="margin: 20px auto;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class TradingPlatform {
            constructor() {
                this.ws = null;
                this.currentPrice = 0;
                this.priceData = [];
                this.indicators = {};
                this.models = {};
                this.chart = null;
                this.currentTimeframe = '1m';
                this.isConnected = false;
                
                this.initializeChart();
                this.initializeWebSocket();
                this.initializeEventListeners();
                this.initializeModels();
                this.startDataCollection();
            }

            initializeChart() {
                const ctx = document.getElementById('priceChart').getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'WIF/USDT',
                            data: [],
                            borderColor: '#00ff88',
                            backgroundColor: 'rgba(0, 255, 136, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1
                        }, {
                            label: 'SMA 20',
                            data: [],
                            borderColor: '#ffaa00',
                            borderWidth: 1,
                            fill: false
                        }, {
                            label: 'EMA 20',
                            data: [],
                            borderColor: '#ff4444',
                            borderWidth: 1,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ffffff'
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            },
                            y: {
                                ticks: { color: '#ffffff' },
                                grid: { color: 'rgba(255,255,255,0.1)' }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });
            }

            initializeWebSocket() {
                try {
                    this.ws = new WebSocket('wss://stream.binance.com:9443/ws/wifusdt@ticker');
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        this.updateConnectionStatus(true);
                        console.log('WebSocket connected');
                    };

                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.updatePriceData(data);
                    };

                    this.ws.onclose = () => {
                        this.isConnected = false;
                        this.updateConnectionStatus(false);
                        console.log('WebSocket disconnected');
                        setTimeout(() => this.initializeWebSocket(), 5000);
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateConnectionStatus(false);
                    };
                } catch (error) {
                    console.error('WebSocket initialization error:', error);
                    this.simulateData();
                }
            }

            simulateData() {
                console.log('Starting simulation mode');
                this.currentPrice = 2.45 + (Math.random() - 0.5) * 0.1;
                
                setInterval(() => {
                    const change = (Math.random() - 0.5) * 0.02;
                    this.currentPrice = Math.max(0.1, this.currentPrice + change);
                    
                    const mockData = {
                        c: this.currentPrice.toFixed(4),
                        P: ((Math.random() - 0.5) * 10).toFixed(2),
                        v: (Math.random() * 10000000).toFixed(0)
                    };
                    
                    this.updatePriceData(mockData);
                }, 1000);
            }

            updatePriceData(data) {
                if (!data.c) return;
                
                this.currentPrice = parseFloat(data.c);
                const now = new Date();
                
                this.priceData.push({
                    timestamp: now,
                    price: this.currentPrice,
                    volume: parseFloat(data.v) || 0
                });

                if (this.priceData.length > 200) {
                    this.priceData.shift();
                }

                this.updateUI(data);
                this.calculateIndicators();
                this.updateChart();
                this.generatePredictions();
                this.updateSignals();
            }

            updateUI(data) {
                document.getElementById('currentPrice').textContent = `$${this.currentPrice.toFixed(4)}`;
                
                const change = parseFloat(data.P) || 0;
                const changeElement = document.getElementById('priceChange');
                changeElement.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                changeElement.className = change >= 0 ? 'price-change positive' : 'price-change negative';

                document.getElementById('volume24h').textContent = this.formatNumber(parseFloat(data.v) || 0);
                document.getElementById('marketCap').textContent = this.formatNumber(this.currentPrice * 1000000000);
            }

            updateConnectionStatus(connected) {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.className = `status-indicator ${connected ? 'status-connected' : 'status-disconnected'}`;
            }

            calculateIndicators() {
                if (this.priceData.length < 20) return;

                const prices = this.priceData.map(d => d.price);
                const volumes = this.priceData.map(d => d.volume);

                // Simple Moving Average
                this.indicators.sma20 = this.calculateSMA(prices, 20);
                
                // Exponential Moving Average
                this.indicators.ema20 = this.calculateEMA(prices, 20);
                
                // RSI
                this.indicators.rsi = this.calculateRSI(prices, 14);
                
                // MACD
                const macdResult = this.calculateMACD(prices);
                this.indicators.macd = macdResult.macd;
                
                // Bollinger Bands
                const bbResult = this.calculateBollingerBands(prices, 20, 2);
                this.indicators.bbUpper = bbResult.upper;
                this.indicators.bbLower = bbResult.lower;
                
                // ATR
                this.indicators.atr = this.calculateATR(this.priceData, 14);
                
                // Stochastic
                this.indicators.stoch = this.calculateStochastic(this.priceData, 14);
                
                // Williams %R
                this.indicators.willR = this.calculateWilliamsR(this.priceData, 14);
                
                // CCI
                this.indicators.cci = this.calculateCCI(this.priceData, 14);
                
                // OBV
                this.indicators.obv = this.calculateOBV(this.priceData);
                
                // VWAP
                this.indicators.vwap = this.calculateVWAP(this.priceData);
                
                // MFI
                this.indicators.mfi = this.calculateMFI(this.priceData, 14);
                
                // Volatility
                this.indicators.volatility = this.calculateVolatility(prices, 20);

                this.updateIndicatorDisplay();
            }

            calculateSMA(prices, period) {
                if (prices.length < period) return null;
                const sum = prices.slice(-period).reduce((a, b) => a + b, 0);
                return sum / period;
            }

            calculateEMA(prices, period) {
                if (prices.length < period) return null;
                
                const multiplier = 2 / (period + 1);
                let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
                
                for (let i = period; i < prices.length; i++) {
                    ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
                }
                
                return ema;
            }

            calculateRSI(prices, period) {
                if (prices.length < period + 1) return null;
                
                let gains = 0, losses = 0;
                
                for (let i = 1; i <= period; i++) {
                    const change = prices[prices.length - i] - prices[prices.length - i - 1];
                    if (change > 0) gains += change;
                    else losses -= change;
                }
                
                const avgGain = gains / period;
                const avgLoss = losses / period;
                const rs = avgGain / avgLoss;
                
                return 100 - (100 / (1 + rs));
            }

            calculateMACD(prices, fast = 12, slow = 26, signal = 9) {
                if (prices.length < slow) return { macd: null, signal: null, histogram: null };
                
                const emaFast = this.calculateEMA(prices, fast);
                const emaSlow = this.calculateEMA(prices, slow);
                const macd = emaFast - emaSlow;
                
                return { macd: macd, signal: null, histogram: null };
            }

            calculateBollingerBands(prices, period, stdDev) {
                if (prices.length < period) return { upper: null, middle: null, lower: null };
                
                const sma = this.calculateSMA(prices, period);
                const recentPrices = prices.slice(-period);
                
                const variance = recentPrices.reduce((sum, price) => {
                    return sum + Math.pow(price - sma, 2);
                }, 0) / period;
                
                const standardDeviation = Math.sqrt(variance);
                
                return {
                    upper: sma + (standardDeviation * stdDev),
                    middle: sma,
                    lower: sma - (standardDeviation * stdDev)
                };
            }

            calculateATR(data, period) {
                if (data.length < period + 1) return null;
                
                let trSum = 0;
                for (let i = data.length - period; i < data.length - 1; i++) {
                    const high = data[i].price + (Math.random() * 0.01);
                    const low = data[i].price - (Math.random() * 0.01);
                    const prevClose = data[i - 1].price;
                    
                    const tr = Math.max(
                        high - low,
                        Math.abs(high - prevClose),
                        Math.abs(low - prevClose)
                    );
                    trSum += tr;
                }
                
                return trSum / period;
            }

            calculateStochastic(data, period) {
                if (data.length < period) return null;
                
                const recentData = data.slice(-period);
                const currentPrice = data[data.length - 1].price;
                const highest = Math.max(...recentData.map(d => d.price + (Math.random() * 0.01)));
                const lowest = Math.min(...recentData.map(d => d.price - (Math.random() * 0.01)));
                
                return ((currentPrice - lowest) / (highest - lowest)) * 100;
            }

            calculateWilliamsR(data, period) {
                if (data.length < period) return null;
                
                const recentData = data.slice(-period);
                const currentPrice = data[data.length - 1].price;
                const highest = Math.max(...recentData.map(d => d.price + (Math.random() * 0.01)));
                const lowest = Math.min(...recentData.map(d => d.price - (Math.random() * 0.01)));
                
                return ((highest - currentPrice) / (highest - lowest)) * -100;
            }

            calculateCCI(data, period) {
                if (data.length < period) return null;
                
                const recentData = data.slice(-period);
                const typicalPrices = recentData.map(d => d.price);
                const sma = typicalPrices.reduce((a, b) => a + b, 0) / period;
                
                const meanDeviation = typicalPrices.reduce((sum, tp) => {
                    return sum + Math.abs(tp - sma);
                }, 0) / period;
                
                const currentTypicalPrice = data[data.length - 1].price;
                return (currentTypicalPrice - sma) / (0.015 * meanDeviation);
            }

            calculateOBV(data) {
                if (data.length < 2) return null;
                
                let obv = 0;
                for (let i = 1; i < data.length; i++) {
                    if (data[i].price > data[i - 1].price) {
                        obv += data[i].volume;
                    } else if (data[i].price < data[i - 1].price) {
                        obv -= data[i].volume;
                    }
                }
                
                return obv;
            }

            calculateVWAP(data) {
                if (data.length === 0) return null;
                
                let priceVolume = 0;
                let totalVolume = 0;
                
                data.forEach(d => {
                    priceVolume += d.price * d.volume;
                    totalVolume += d.volume;
                });
                
                return totalVolume > 0 ? priceVolume / totalVolume : null;
            }

            calculateMFI(data, period) {
                if (data.length < period + 1) return null;
                
                let positiveFlow = 0, negativeFlow = 0;
                
                for (let i = data.length - period; i < data.length; i++) {
                    const typicalPrice = data[i].price;
                    const prevTypicalPrice = data[i - 1].price;
                    const moneyFlow = typicalPrice * data[i].volume;
                    
                    if (typicalPrice > prevTypicalPrice) {
                        positiveFlow += moneyFlow;
                    } else if (typicalPrice < prevTypicalPrice) {
                        negativeFlow += moneyFlow;
                    }
                }
                
                const mfi = 100 - (100 / (1 + (positiveFlow / negativeFlow)));
                return isNaN(mfi) ? 50 : mfi;
            }

            calculateVolatility(prices, period) {
                if (prices.length < period) return null;
                
                const recentPrices = prices.slice(-period);
                const returns = [];
                
                for (let i = 1; i < recentPrices.length; i++) {
                    returns.push(Math.log(recentPrices[i] / recentPrices[i - 1]));
                }
                
                const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                const variance = returns.reduce((sum, ret) => {
                    return sum + Math.pow(ret - mean, 2);
                }, 0) / returns.length;
                
                return Math.sqrt(variance) * Math.sqrt(252) * 100;
            }

            updateIndicatorDisplay() {
                const indicators = [
                    { id: 'sma20', value: this.indicators.sma20, decimals: 4 },
                    { id: 'ema20', value: this.indicators.ema20, decimals: 4 },
                    { id: 'macd', value: this.indicators.macd, decimals: 6 },
                    { id: 'bbUpper', value: this.indicators.bbUpper, decimals: 4 },
                    { id: 'bbLower', value: this.indicators.bbLower, decimals: 4 },
                    { id: 'rsi', value: this.indicators.rsi, decimals: 1 },
                    { id: 'stoch', value: this.indicators.stoch, decimals: 1 },
                    { id: 'willR', value: this.indicators.willR, decimals: 1 },
                    { id: 'cci', value: this.indicators.cci, decimals: 1 },
                    { id: 'obv', value: this.indicators.obv, decimals: 0, format: 'compact' },
                    { id: 'vwap', value: this.indicators.vwap, decimals: 4 },
                    { id: 'mfi', value: this.indicators.mfi, decimals: 1 },
                    { id: 'atr', value: this.indicators.atr, decimals: 6 },
                    { id: 'volatility', value: this.indicators.volatility, decimals: 1 }
                ];

                indicators.forEach(indicator => {
                    const element = document.getElementById(indicator.id);
                    if (element && indicator.value !== null && indicator.value !== undefined) {
                        let displayValue;
                        if (indicator.format === 'compact') {
                            displayValue = this.formatNumber(indicator.value);
                        } else {
                            displayValue = indicator.value.toFixed(indicator.decimals);
                        }
                        element.textContent = displayValue;
                        
                        // Color coding for certain indicators
                        if (indicator.id === 'rsi') {
                            if (indicator.value > 70) element.style.color = '#ff4444';
                            else if (indicator.value < 30) element.style.color = '#00ff88';
                            else element.style.color = '#ffffff';
                        }
                    }
                });
            }

            updateChart() {
                if (this.priceData.length === 0) return;

                const labels = this.priceData.map(d => d.timestamp.toLocaleTimeString());
                const prices = this.priceData.map(d => d.price);
                
                // Calculate moving averages for chart
                const sma20Data = [];
                const ema20Data = [];
                
                prices.forEach((_, index) => {
                    if (index >= 19) {
                        const sma = this.calculateSMA(prices.slice(0, index + 1), 20);
                        const ema = this.calculateEMA(prices.slice(0, index + 1), 20);
                        sma20Data.push(sma);
                        ema20Data.push(ema);
                    } else {
                        sma20Data.push(null);
                        ema20Data.push(null);
                    }
                });

                this.chart.data.labels = labels;
                this.chart.data.datasets[0].data = prices;
                this.chart.data.datasets[1].data = sma20Data;
                this.chart.data.datasets[2].data = ema20Data;
                this.chart.update('none');
            }

            async initializeModels() {
                this.models = {
                    gru: await this.createGRUModel(),
                    xgboost: this.createXGBoostModel(),
                    transformer: await this.createTransformerModel(),
                    lstm: await this.createLSTMModel(),
                    lightgbm: this.createLightGBMModel(),
                    randomForest: this.createRandomForestModel()
                };
                console.log('ML models initialized');
            }

            async createGRUModel() {
                const model = tf.sequential({
                    layers: [
                        tf.layers.gru({ units: 50, returnSequences: true, inputShape: [60, 5] }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.gru({ units: 50, returnSequences: false }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 25 }),
                        tf.layers.dense({ units: 1 })
                    ]
                });
                
                model.compile({
                    optimizer: 'adam',
                    loss: 'meanSquaredError',
                    metrics: ['meanAbsoluteError']
                });
                
                return model;
            }

            async createLSTMModel() {
                const model = tf.sequential({
                    layers: [
                        tf.layers.lstm({ units: 50, returnSequences: true, inputShape: [60, 5] }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.lstm({ units: 50, returnSequences: false }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 25 }),
                        tf.layers.dense({ units: 1 })
                    ]
                });
                
                model.compile({
                    optimizer: 'adam',
                    loss: 'meanSquaredError'
                });
                
                return model;
            }

            async createTransformerModel() {
                // Simplified transformer-like model
                const model = tf.sequential({
                    layers: [
                        tf.layers.dense({ units: 128, activation: 'relu', inputShape: [60, 5] }),
                        tf.layers.dropout({ rate: 0.1 }),
                        tf.layers.dense({ units: 64, activation: 'relu' }),
                        tf.layers.globalAveragePooling1d(),
                        tf.layers.dense({ units: 32, activation: 'relu' }),
                        tf.layers.dense({ units: 1 })
                    ]
                });
                
                model.compile({
                    optimizer: 'adam',
                    loss: 'meanSquaredError'
                });
                
                return model;
            }

            createXGBoostModel() {
                // Simulated XGBoost using ensemble of decisions
                return {
                    predict: (features) => {
                        const weights = [0.3, 0.25, 0.2, 0.15, 0.1];
                        let prediction = 0;
                        
                        features.forEach((feature, i) => {
                            prediction += feature * weights[i % weights.length];
                        });
                        
                        return prediction * (0.95 + Math.random() * 0.1);
                    }
                };
            }

            createLightGBMModel() {
                return {
                    predict: (features) => {
                        const trend = features[0] > features[1] ? 1 : -1;
                        const momentum = (features[2] - 50) / 50;
                        const volume = Math.log(features[3] || 1) / 10;
                        
                        return features[0] * (1 + trend * 0.001 + momentum * 0.002 + volume * 0.001);
                    }
                };
            }

            createRandomForestModel() {
                return {
                    predict: (features) => {
                        const trees = 100;
                        let sum = 0;
                        
                        for (let i = 0; i < trees; i++) {
                            const randomFeature = features[Math.floor(Math.random() * features.length)];
                            sum += randomFeature * (0.98 + Math.random() * 0.04);
                        }
                        
                        return sum / trees;
                    }
                };
            }

            generatePredictions() {
                if (this.priceData.length < 60) return;

                const features = this.prepareFeatures();
                const predictions = [];
                
                // Ensemble predictions with weights
                const weights = {
                    gru: 0.25,
                    xgboost: 0.20,
                    transformer: 0.18,
                    lstm: 0.15,
                    lightgbm: 0.12,
                    randomForest: 0.10
                };

                // Simple feature-based predictions for demonstration
                const currentPrice = this.currentPrice;
                const trend = this.indicators.sma20 && currentPrice > this.indicators.sma20 ? 1 : -1;
                const momentum = (this.indicators.rsi - 50) / 100;
                const volatility = this.indicators.volatility / 100;
                
                predictions.push({
                    model: 'gru',
                    value: currentPrice * (1 + trend * 0.005 + momentum * 0.003 + (Math.random() - 0.5) * 0.01)
                });
                
                predictions.push({
                    model: 'xgboost',
                    value: this.models.xgboost.predict(features)
                });
                
                predictions.push({
                    model: 'lightgbm',
                    value: this.models.lightgbm.predict(features)
                });
                
                predictions.push({
                    model: 'randomForest',
                    value: this.models.randomForest.predict(features)
                });

                // Calculate ensemble prediction
                let ensemblePrediction = 0;
                predictions.forEach(pred => {
                    ensemblePrediction += pred.value * (weights[pred.model] || 0.1);
                });

                // Calculate confidence based on prediction variance
                const variance = predictions.reduce((sum, pred) => {
                    return sum + Math.pow(pred.value - ensemblePrediction, 2);
                }, 0) / predictions.length;
                
                const confidence = Math.max(30, Math.min(95, 85 - variance * 10000));

                this.updatePredictionDisplay(ensemblePrediction, confidence);
            }

            prepareFeatures() {
                const recent = this.priceData.slice(-60);
                return [
                    this.currentPrice,
                    this.indicators.sma20 || this.currentPrice,
                    this.indicators.rsi || 50,
                    recent[recent.length - 1]?.volume || 0,
                    this.indicators.volatility || 20
                ];
            }

            updatePredictionDisplay(prediction, confidence) {
                document.getElementById('prediction1h').textContent = `${prediction.toFixed(4)}`;
                
                const confidenceBar = document.getElementById('confidence1h');
                const confidenceText = document.getElementById('confidence1hText');
                
                confidenceBar.style.width = `${confidence}%`;
                confidenceText.textContent = `Confidence: ${confidence.toFixed(1)}%`;
                
                // Update model accuracy (simulated)
                document.getElementById('modelAccuracy').textContent = `${(65 + Math.random() * 5).toFixed(1)}%`;
                document.getElementById('sharpeRatio').textContent = (1.5 + Math.random() * 0.5).toFixed(2);
            }

            updateSignals() {
                const signals = this.generateTradingSignals();
                const container = document.getElementById('signalsContainer');
                
                container.innerHTML = signals.map(signal => `
                    <div class="signal-item signal-${signal.type}">
                        <div>
                            <div style="font-weight: bold;">${signal.title}</div>
                            <div style="font-size: 11px; color: #aaa;">${signal.description}</div>
                        </div>
                        <div style="color: ${signal.color}; font-weight: bold;">${signal.strength}%</div>
                    </div>
                `).join('');
            }

            generateTradingSignals() {
                const signals = [];
                
                // RSI Signals
                if (this.indicators.rsi) {
                    if (this.indicators.rsi > 70) {
                        signals.push({
                            type: 'sell',
                            title: 'RSI Overbought',
                            description: 'Mean reversion opportunity',
                            strength: Math.min(95, Math.round(((this.indicators.rsi - 70) / 30) * 100 + 70)),
                            color: '#ff4444'
                        });
                    } else if (this.indicators.rsi < 30) {
                        signals.push({
                            type: 'buy',
                            title: 'RSI Oversold',
                            description: 'Potential bounce signal',
                            strength: Math.min(95, Math.round(((30 - this.indicators.rsi) / 30) * 100 + 70)),
                            color: '#00ff88'
                        });
                    }
                }
                
                // Moving Average Signals
                if (this.indicators.sma20 && this.indicators.ema20) {
                    if (this.currentPrice > this.indicators.sma20 && this.indicators.ema20 > this.indicators.sma20) {
                        signals.push({
                            type: 'buy',
                            title: 'Bullish Trend',
                            description: 'Price above moving averages',
                            strength: Math.round(75 + Math.random() * 15),
                            color: '#00ff88'
                        });
                    }
                }
                
                // Bollinger Bands Signals
                if (this.indicators.bbUpper && this.indicators.bbLower) {
                    if (this.currentPrice > this.indicators.bbUpper) {
                        signals.push({
                            type: 'sell',
                            title: 'BB Overbought',
                            description: 'Price above upper band',
                            strength: Math.round(70 + Math.random() * 15),
                            color: '#ff4444'
                        });
                    } else if (this.currentPrice < this.indicators.bbLower) {
                        signals.push({
                            type: 'buy',
                            title: 'BB Oversold',
                            description: 'Price below lower band',
                            strength: Math.round(70 + Math.random() * 15),
                            color: '#00ff88'
                        });
                    }
                }
                
                // Default hold signal if no strong signals
                if (signals.length === 0) {
                    signals.push({
                        type: 'hold',
                        title: 'Neutral Market',
                        description: 'Waiting for clear signal',
                        strength: Math.round(40 + Math.random() * 20),
                        color: '#ffaa00'
                    });
                }
                
                return signals.slice(0, 3); // Show max 3 signals
            }

            initializeEventListeners() {
                // Timeframe buttons
                document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentTimeframe = e.target.dataset.timeframe;
                        this.handleTimeframeChange();
                    });
                });

                // Prediction horizon
                document.getElementById('predictionHorizon').addEventListener('change', (e) => {
                    this.predictionHorizon = parseInt(e.target.value);
                    this.generatePredictions();
                });
            }

            handleTimeframeChange() {
                console.log(`Switched to ${this.currentTimeframe} timeframe`);
                // In a real implementation, this would fetch different timeframe data
                this.showAlert(`Switched to ${this.currentTimeframe} timeframe`);
            }

            startDataCollection() {
                // Fetch initial historical data
                this.fetchHistoricalData();
                
                // Fetch market sentiment data
                this.fetchMarketSentiment();
                
                // Start periodic updates
                setInterval(() => {
                    this.fetchMarketSentiment();
                }, 300000); // Update every 5 minutes
            }

            async fetchHistoricalData() {
                try {
                    // In a real implementation, this would fetch from Binance API
                    console.log('Fetching historical data...');
                    
                    // Simulate some historical data
                    const now = Date.now();
                    for (let i = 100; i >= 0; i--) {
                        const price = 2.45 + (Math.random() - 0.5) * 0.2;
                        this.priceData.push({
                            timestamp: new Date(now - i * 60000),
                            price: price,
                            volume: Math.random() * 1000000
                        });
                    }
                } catch (error) {
                    console.error('Error fetching historical data:', error);
                }
            }

            async fetchMarketSentiment() {
                try {
                    // Simulate Fear & Greed Index
                    const fearGreedValue = Math.round(30 + Math.random() * 40);
                    document.getElementById('fearGreedIndex').textContent = fearGreedValue;
                    
                    // Update news (simulated)
                    this.updateNews();
                } catch (error) {
                    console.error('Error fetching market sentiment:', error);
                }
            }

            updateNews() {
                const newsItems = [
                    { title: 'WIF shows strong momentum amid market recovery...', time: '2 hours ago' },
                    { title: 'Technical analysis suggests potential breakout...', time: '4 hours ago' },
                    { title: 'Volume spike indicates increased interest...', time: '6 hours ago' },
                    { title: 'Market sentiment remains cautiously optimistic...', time: '8 hours ago' }
                ];
                
                const newsContainer = document.getElementById('newsContainer');
                newsContainer.innerHTML = newsItems.map(item => `
                    <div class="news-item">
                        <div class="news-title">${item.title}</div>
                        <div class="news-time">${item.time}</div>
                    </div>
                `).join('');
            }

            formatNumber(num) {
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return num.toFixed(0);
            }

            showAlert(message, type = 'info') {
                const alertBanner = document.getElementById('alertBanner');
                const alertMessage = document.getElementById('alertMessage');
                
                alertMessage.textContent = message;
                alertBanner.classList.add('show');
                
                setTimeout(() => {
                    alertBanner.classList.remove('show');
                }, 3000);
            }
        }

        // Initialize the trading platform when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.tradingPlatform = new TradingPlatform();
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden - reducing update frequency');
            } else {
                console.log('Page visible - resuming normal updates');
            }
        });

        // Handle window resize for responsive chart
        window.addEventListener('resize', () => {
            if (window.tradingPlatform && window.tradingPlatform.chart) {
                window.tradingPlatform.chart.resize();
            }
        });
    </script>
</body>
</html>
